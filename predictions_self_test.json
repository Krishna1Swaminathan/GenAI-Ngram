[
  {
    "context": "public void testRoundToDouble_negativeTwoToThe54MinusThree ( ) { new RoundToDoubleTester ( BigDecimal . valueOf ( ( - 1L < < 54 ) - 3 ) ) . setExpectation ( - Math . pow ( 2 , 54 ) , DOWN , CEILING ) . setExpectation ( DoubleUtils . nextDown ( - Math . pow ( 2 , 54 ) ) , FLOOR , UP , HALF_DOWN , HALF_UP , HALF_EVEN ) . roundUnnecessaryShouldThrow ( ) . test ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testNewDataInput_readUTF ( ) { byte[] data = new byte[17] ; data[1] = 15 ; System . arraycopy ( \"Kilroy was here\" . getBytes ( UTF_8 ) , 0 , data , 2 , 15 ) ; ByteArrayDataInput in = ByteStreams . newDataInput ( data ) ; assertEquals ( \"Kilroy was here\" , in . readUTF ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEnumMapWithInitialEmptyEnumMap ( ) { EnumMap < SomeEnum , Integer > original = Maps . newEnumMap ( SomeEnum . class ) ; EnumMap < SomeEnum , Integer > copy = Maps . newEnumMap ( original ) ; assertEquals ( original , copy ) ; assertNotSame ( original , copy ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Map < String , String > create ( Entry < String , String > [] entries ) { Map < String , String > map = new LinkedHashMap < > ( ) ; for ( Entry < String , String > entry : entries ) { map . put ( entry . getKey ( ) , encode ( entry . getValue ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void putEdgeValue_undirected_orderMismatch ( ) { graph = ValueGraphBuilder . undirected ( ) . build ( ) ; IllegalArgumentException e = assertThrows ( IllegalArgumentException . class , ( ) - > graph . putEdgeValue ( EndpointPair . ordered ( 1 , 2 ) , \"irrelevant\" ) ) ; assertThat ( e ) . hasMessageThat ( ) . contains ( ENDPOINTS_MISMATCH ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testElapsed_micros ( ) { stopwatch . start ( ) ; ticker . advance ( 999 ) ; assertEquals ( 0 , stopwatch . elapsed ( MICROSECONDS ) ) ; ticker . advance ( 1 ) ; assertEquals ( 1 , stopwatch . elapsed ( MICROSECONDS ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public TestSubjectGenerator < ? > getInnerGenerator ( ) { return generator ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E extends @Nullable Object > CompactLinkedHashSet < E > create ( ) { return new CompactLinkedHashSet < > ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Multiset < AnEnum > create ( Object . . . elements ) { AnEnum[] array = new AnEnum[elements . length] ; int i = 0 ; for ( Object e : elements ) { array[i + + ] = ( AnEnum ) e ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected List < Short > create ( Short[] elements ) { Short[] prefix = { Short . MIN_VALUE , Short . MAX_VALUE",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int setCount ( @ParametricNullness E element , int count ) { return delegate ( ) . setCount ( element , count ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < E > edgesConnecting ( N nodeU , N nodeV ) { NetworkConnections < N , E > connectionsU = checkedConnections ( nodeU ) ; if ( ! allowsSelfLoops & & nodeU = = nodeV ) { / / just an optimization , only check reference equality return ImmutableSet . of ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public NavigableMap < K , V > subMap ( K fromKey , boolean fromInclusive , K toKey , boolean toInclusive ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate ( ) . subMap ( fromKey , fromInclusive , toKey , toInclusive ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testClear ( ) { AtomicLongMap < Object > map = AtomicLongMap . create ( ) ; for ( int i = 0 ; i < ITERATIONS ; i + + ) { map . put ( new Object ( ) , i ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private TypeToken < ? super T > getSupertypeFromUpperBounds ( Class < ? super T > supertype , Type[] upperBounds ) { for ( Type upperBound : upperBounds ) { @SuppressWarnings ( \"unchecked\" ) / / T's upperbound is < ? super T > . TypeToken < ? super T > bound = ( TypeToken < ? super T > ) of ( upperBound ) ; if ( bound . isSubtypeOf ( supertype ) ) { @SuppressWarnings ( { \"rawtypes\" , \"unchecked\"",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRemovalListener_expired ( ) { FakeTicker ticker = new FakeTicker ( ) ; QueuingRemovalListener < Object , Object > listener = queuingRemovalListener ( ) ; LocalCache < Object , Object > map = makeLocalCache ( createCacheBuilder ( ) . concurrencyLevel ( 1 ) . expireAfterWrite ( 3 , NANOSECONDS ) . ticker ( ticker ) . removalListener ( listener ) ) ; assertThat ( listener . isEmpty ( ) ) . isTrue ( ) ; Object one = new Object ( ) ; Object two = new Object ( ) ; Object three = new Object ( ) ; Object four = new Object ( ) ; Object five = new Object ( ) ; map . put ( one , two ) ; ticker . advance ( 1 ) ; map . put ( two , three ) ; ticker . advance ( 1 ) ; map . put ( three , four ) ; assertThat ( listener . isEmpty ( ) ) . isTrue ( ) ; ticker . advance ( 1 ) ; map . put ( four , five ) ; assertNotified ( listener , one , two , RemovalCause . EXPIRED ) ; assertThat ( listener . isEmpty ( ) ) . isTrue ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public < T extends @Nullable Object > T[] toArray ( T[] array ) { return delegate ( ) . toArray ( array ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private void assertOperationEquals ( int a , int b , String op , int expected , int actual ) { if ( expected ! = actual ) { fail ( \"Expected for \" + a + \" \" + op + \" \" + b + \" = \" + expected + \" , but got \" + actual ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < V > replaceValues ( @ParametricNullness K key , Iterable < ? extends V > values ) { return ( Set < V > ) super . replaceValues ( key , values ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void immutableValueGraphBuilder_appliesGraphBuilderConfig ( ) { ImmutableValueGraph < String , Integer > emptyGraph = ValueGraphBuilder . directed ( ) . allowsSelfLoops ( true ) . nodeOrder ( ElementOrder . < String > natural ( ) ) . < String , Integer > immutable ( ) . build ( ) ; assertThat ( emptyGraph . isDirected ( ) ) . isTrue ( ) ; assertThat ( emptyGraph . allowsSelfLoops ( ) ) . isTrue ( ) ; assertThat ( emptyGraph . nodeOrder ( ) ) . isEqualTo ( ElementOrder . < String > natural ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public E next ( ) { return transferElement ( nextElements , previousElements ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static Test suite ( ) { TestSuite suite = new TestSuite ( IteratorsTest . class . getSimpleName ( ) ) ; suite . addTest ( testsForRemoveAllAndRetainAll ( ) ) ; suite . addTestSuite ( IteratorsTest . class ) ; return suite ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSerialization_andThen ( ) { Converter < String , Long > converterA = Longs . stringConverter ( ) ; Converter < Long , String > reverseConverter = Longs . stringConverter ( ) . reverse ( ) ; Converter < String , String > composedConverter = converterA . andThen ( reverseConverter ) ; SerializableTester . reserializeAndAssert ( composedConverter ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static Test suite ( ) { List < Feature < ? > > allFeatures = Arrays . < Feature < ? > > asList ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_VALUES , CollectionFeature . FAILS_FAST_ON_CONCURRENT_MODIFICATION , CollectionFeature . GENERAL_PURPOSE , CollectionFeature . REMOVE_OPERATIONS , CollectionFeature . SERIALIZABLE , CollectionFeature . KNOWN_ORDER , CollectionFeature . SUPPORTS_ADD , CollectionFeature . SUPPORTS_REMOVE ) ; TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( CompactLinkedHashSetTest . class ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String[] elements ) { return CompactLinkedHashSet . create ( asList ( elements ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Test testsForTreeMapWithComparator ( ) { return NavigableMapTestSuiteBuilder . using ( new TestStringSortedMapGenerator ( ) { @Override protected SortedMap < String , String > create ( Entry < String , String > [] entries ) { return populate ( new TreeMap < String , String > ( arbitraryNullFriendlyComparator ( ) ) , entries ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < K , V > ImmutableMap < K , V > ofEntries ( Entry < ? extends K , ? extends V > . . . entries ) { @SuppressWarnings ( \"unchecked\" ) / / we will only ever read these Entry < K , V > [] entries2 = ( Entry < K , V > [] ) entries ; return RegularImmutableMap . fromEntries ( entries2 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < T extends @Nullable Object > @Nullable T find ( Iterator < ? extends T > iterator , Predicate < ? super T > predicate , @Nullable T defaultValue ) { checkNotNull ( iterator ) ; checkNotNull ( predicate ) ; while ( iterator . hasNext ( ) ) { T t = iterator . next ( ) ; if ( predicate . apply ( t ) ) { return t ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public InputStream openStream ( ) { return new In ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private void testRangesByLowerBounds ( TreeRangeSet < Integer > rangeSet , Iterable < Range < Integer > > expectedRanges ) { NavigableMap < Cut < Integer > , Range < Integer > > expectedRangesByLowerBound = Maps . newTreeMap ( ) ; for ( Range < Integer > range : expectedRanges ) { expectedRangesByLowerBound . put ( range . lowerBound , range ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testGet_comparable ( ) { @SuppressWarnings ( \"unchecked\" ) / / The null value can compare with any Object Comparable < Object > comparable = ArbitraryInstances . get ( Comparable . class ) ; assertEquals ( 0 , comparable . compareTo ( comparable ) ) ; assertThat ( comparable . compareTo ( \"\" ) ) . isGreaterThan ( 0 ) ; assertThrows ( NullPointerException . class , ( ) - > comparable . compareTo ( null ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < R , C , V > ArrayTable < R , C , V > create ( Table < R , C , ? extends @Nullable V > table ) { return ( table instanceof ArrayTable ) ? new ArrayTable < R , C , V > ( ( ArrayTable < R , C , V > ) table ) : new ArrayTable < R , C , V > ( table ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public TypeToken < T > getOwnerType ( ) { return ( TypeToken < T > ) TypeToken . of ( getDeclaringClass ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private boolean timeFindCaller ( int reps , int recurse ) { return recurse > 0 ? timeFindCaller ( reps , recurse - 1 ) : mode . timeIt ( reps , breakAt ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ImmutableList < E > asList ( ) { return isEmpty ( ) ? ImmutableList . of ( ) : ImmutableList . asImmutableList ( toArray ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testMax ( ) { assertThat ( max ( LEAST ) ) . isEqualTo ( LEAST ) ; assertThat ( max ( GREATEST ) ) . isEqualTo ( GREATEST ) ; assertThat ( max ( 8 . 0 , 6 . 0 , 7 . 0 , 5 . 0 , 3 . 0 , 0 . 0 , 9 . 0 ) ) . isEqualTo ( 9 . 0 ) ; assertThat ( max ( - 0 . 0 , 0 . 0 ) ) . isEqualTo ( 0 . 0 ) ; assertThat ( max ( 0 . 0 , - 0 . 0 ) ) . isEqualTo ( 0 . 0 ) ; assertThat ( max ( NUMBERS ) ) . isEqualTo ( GREATEST ) ; assertThat ( Double . isNaN ( max ( VALUES ) ) ) . isTrue ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCreation_expectedSize_withContents ( ) { MinMaxPriorityQueue < Integer > queue = rawtypeToWildcard ( MinMaxPriorityQueue . expectedSize ( 8 ) ) . create ( NUMBERS ) ; assertEquals ( 6 , queue . size ( ) ) ; assertEquals ( 8 , queue . capacity ( ) ) ; checkUnbounded ( queue ) ; checkNatural ( queue ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < T > Class < T > unwrap ( Class < T > type ) { checkNotNull ( type ) ; / / cast is safe: long . class and Long . class are both of type Class < Long > @SuppressWarnings ( \"unchecked\" ) Class < T > unwrapped = ( Class < T > ) WRAPPER_TO_PRIMITIVE_TYPE . get ( type ) ; return ( unwrapped = = null ) ? type : unwrapped ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSetCountOutOfTailBoundsOne ( ) { expectSetCountFailure ( sortedMultiset . tailMultiset ( a . getElement ( ) , OPEN ) , a ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public long getAndAdd ( K key , long delta ) { return getAndAccumulate ( key , delta , Long::sum ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int count ( @Nullable Object element ) { Collection < V > values = Maps . safeGet ( multimap . asMap ( ) , element ) ; return ( values = = null ) ? 0 : values . size ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean isDone ( ) { * return map . isEmpty ( ) ; *",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testMappingWithSlope_nanSlope ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > LinearTransformation . mapping ( 1 . 2 , 3 . 4 ) . withSlope ( Double . NaN ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { return \"Hashing . fingerprint2011 ( ) \" ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public NavigableMap < K , V > descendingMap ( ) { return asMap ( set . descendingSet ( ) , function ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEqualsMultisetWithNullValue ( ) { new EqualsTester ( ) . addEqualityGroup ( getMultiset ( ) ) . addEqualityGroup ( getSubjectGenerator ( ) . create ( createArrayWithNullElement ( ) ) , getSubjectGenerator ( ) . create ( createArrayWithNullElement ( ) ) ) . testEquals ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ReentrantReadWriteLock newReentrantReadWriteLock ( E rank , boolean fair ) { return policy = = Policies . DISABLED ? new ReentrantReadWriteLock ( fair ) / / requireNonNull is safe because createNodes inserts an entry for every E . / / ( If the caller passes `null` for the `rank` parameter , this will throw , but that's OK . ) : new CycleDetectingReentrantReadWriteLock ( requireNonNull ( lockGraphNodes . get ( rank ) ) , fair ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public byte[] getExpected ( byte[] bytes ) { return checkNotNull ( bytes ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testNulls ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicStaticMethods ( HostSpecifier . class ) ; tester . testAllPublicInstanceMethods ( HostSpecifier . fromValid ( \"google . com\" ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void forGraph_depthFirstPreOrder_multigraph ( ) { Traverser < Character > traverser = Traverser . forGraph ( MULTI_GRAPH ) ; assertEqualCharNodes ( traverser . depthFirstPreOrder ( 'a' ) , \"abdc\" ) ; assertEqualCharNodes ( traverser . depthFirstPreOrder ( 'b' ) , \"bd\" ) ; assertEqualCharNodes ( traverser . depthFirstPreOrder ( 'c' ) , \"cabd\" ) ; assertEqualCharNodes ( traverser . depthFirstPreOrder ( 'd' ) , \"d\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected by * the monitor , thereby causing some guard to be satisfied . * * < p > In addition , any thread that has been signalled when its guard was satisfied acquires the * responsibility of signalling the next thread when it again relinquishes the lock . Unlike a * normal Condition , there is no guarantee that an interrupted thread has not been signalled , * since the concurrency control must manage multiple Conditions . So this method must generally be * called when waits are interrupted . * * < p > On the other hand , if a signalled thread wakes up to discover that its guard is still not * satisfied , it does * not * need to call this method before returning to wait . This can only * happen due to spurious wakeup ( ignorable ) or another thread acquiring the lock before the * current thread can and returning the guard to the unsatisfied state . In the latter case the * other thread ( last thread modifying the state protected by the monitor ) takes over the * responsibility of signalling the next waiter . * * < p > This method must not be called from within a beginWaitingFor / endWaitingFor block , or else * the current thread's guard might be mistakenly signalled , leading to a lost signal . * / @GuardedBy ( \"lock\" ) private void signalNextWaiter ( ) { for ( Guard guard = activeGuards ; guard ! = null ; guard = guard . next ) { if ( isSatisfied ( guard ) ) { guard . condition . signal ( ) ; break ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable E lower ( @ParametricNullness E e ) { return delegate . lower ( e ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testLexicographical ( ) { Ordering < String > ordering = Ordering . natural ( ) ; Ordering < Iterable < String > > lexy = ordering . lexicographical ( ) ; ImmutableList < String > empty = ImmutableList . of ( ) ; ImmutableList < String > a = ImmutableList . of ( \"a\" ) ; ImmutableList < String > aa = ImmutableList . of ( \"a\" , \"a\" ) ; ImmutableList < String > ab = ImmutableList . of ( \"a\" , \"b\" ) ; ImmutableList < String > b = ImmutableList . of ( \"b\" ) ; testComparator ( lexy , empty , a , aa , ab , b ) ; new EqualsTester ( ) . addEqualityGroup ( lexy , ordering . lexicographical ( ) ) . addEqualityGroup ( numberOrdering . lexicographical ( ) ) . addEqualityGroup ( Ordering . natural ( ) ) . testEquals ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Collection < Method > suppressForHashtable ( ) { return emptySet ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testNewParameterizedType_invalidTypeParameters ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Types . newParameterizedTypeWithOwner ( Map . class , Entry . class , String . class ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private void doEnterScenarioSetUp ( ) { switch ( scenario ) { case SATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING: enterSatisfyGuardAndLeaveInCurrentThread ( ) ; break ; case UNSATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING: break ; case SATISFIED_AND_OCCUPIED_BEFORE_ENTERING: enterSatisfyGuardAndLeaveInCurrentThread ( ) ; enterAndRemainOccupyingInAnotherThread ( ) ; break ; case SATISFIED_UNOCCUPIED_AND_INTERRUPTED_BEFORE_ENTERING: enterSatisfyGuardAndLeaveInCurrentThread ( ) ; Thread . currentThread ( ) . interrupt ( ) ; break ; default: throw new AssertionError ( \"unsupported scenario: \" + scenario ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testTrueFirst ( ) { assertThat ( Booleans . trueFirst ( ) . compare ( true , true ) ) . isEqualTo ( 0 ) ; assertThat ( Booleans . trueFirst ( ) . compare ( false , false ) ) . isEqualTo ( 0 ) ; assertThat ( Booleans . trueFirst ( ) . compare ( true , false ) ) . isLessThan ( 0 ) ; assertThat ( Booleans . trueFirst ( ) . compare ( false , true ) ) . isGreaterThan ( 0 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void successors_noSuccessors ( ) { addNode ( N1 ) ; assertThat ( graph . successors ( N1 ) ) . isEmpty ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testConstantSqrt2PrecomputedBits ( ) { assertEquals ( BigIntegerMath . sqrt ( BigInteger . ZERO . setBit ( 2 * BigIntegerMath . SQRT2_PRECOMPUTE_THRESHOLD + 1 ) , FLOOR ) , BigIntegerMath . SQRT2_PRECOMPUTED_BITS ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void put ( Range < Comparable < ? > > range , Object value ) { checkNotNull ( range ) ; throw new IllegalArgumentException ( \"Cannot insert range \" + range + \" into an empty subRangeMap\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testMergeOntoRangeOverlappingUpperBound ( ) { / / { [1 . . 3 ) : 1",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Class < K > keyType ( ) { return keyTypeOrObjectUnderJ2cl ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testLowerKey ( ) { assertThat ( create ( ) . lowerKey ( \"a\" ) ) . isNull ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSubscriber ( ) { assertThat ( getSubscriber ( ) . subscriberEvents ) . contains ( EVENT ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testHashFloatIsStable ( ) { / / Just a spot check . Better than nothing . Hasher hasher = HASH_FN . newHasher ( ) ; hasher . putFloat ( 0x01000101f ) . putFloat ( 0f ) ; assertEquals ( 0x49f9d18ee8ae1b28L , hasher . hash ( ) . asLong ( ) ) ; hasher = HASH_FN . newHasher ( ) ; hasher . putDouble ( 0x0000000001000101d ) ; assertEquals ( 0x388ee898bad75cbfL , hasher . hash ( ) . asLong ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static ClassPath . ClassInfo findClass ( Iterable < ClassPath . ClassInfo > classes , Class < ? > cls ) { for ( ClassPath . ClassInfo classInfo : classes ) { if ( classInfo . getName ( ) . equals ( cls . getName ( ) ) ) { return classInfo ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected void process ( ByteBuffer bb ) { while ( bb . hasRemaining ( ) ) { out . write ( bb . get ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testFirstEntry ( ) { assertThat ( create ( ) . firstEntry ( ) ) . isNull ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSizingDefaults ( ) { LoadingCache < ? , ? > cache = CacheBuilder . newBuilder ( ) . build ( identityLoader ( ) ) ; LocalCache < ? , ? > map = CacheTesting . toLocalCache ( cache ) ; assertThat ( map . segments ) . hasLength ( 4 ) ; / / concurrency level assertThat ( map . segments[0] . table . length ( ) ) . isEqualTo ( 4 ) ; / / capacity / conc level",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testFingerprint2011 ( ) { HashTestUtils . check2BitAvalanche ( Hashing . fingerprint2011 ( ) , 100 , 0 . 4 ) ; HashTestUtils . checkAvalanche ( Hashing . fingerprint2011 ( ) , 100 , 0 . 4 ) ; HashTestUtils . checkNo2BitCharacteristics ( Hashing . fingerprint2011 ( ) ) ; HashTestUtils . checkNoFunnels ( Hashing . fingerprint2011 ( ) ) ; HashTestUtils . assertInvariants ( Hashing . fingerprint2011 ( ) ) ; assertEquals ( \"Hashing . fingerprint2011 ( ) \" , Hashing . fingerprint2011 ( ) . toString ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRow ( ) { table = create ( \"foo\" , 1 , 'a' , \"bar\" , 1 , 'b' , \"foo\" , 3 , 'c' ) ; Map < Integer , @Nullable Character > expected = new HashMap < > ( ) ; expected . put ( 1 , 'a' ) ; expected . put ( 3 , 'c' ) ; expected . put ( 2 , null ) ; assertEquals ( expected , table . row ( \"foo\" ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static long charToThreeUtf8Bytes ( char c ) { return ( ( 0x7L < < 5 ) | ( c > > > 12 ) ) | ( ( 0x80 | ( 0x3F & ( c > > > 6 ) ) ) < < 8 ) | ( ( 0x80 | ( 0x3F & c ) ) < < 16 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static ImmutableSet < Field > httpHeadersFields ( ) { ImmutableSet . Builder < Field > builder = ImmutableSet . builder ( ) ; for ( Field field : HttpHeaders . class . getDeclaredFields ( ) ) { / * * Coverage mode generates synthetic fields . If we ever add private * fields , they will cause similar problems , and we may want to switch * this check to isAccessible ( ) . * / if ( ! field . isSynthetic ( ) & & field . getType ( ) = = String . class ) { builder . add ( field ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { return \"BY_TO_STRING\" ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testGet_array ( ) { assertThat ( ArbitraryInstances . get ( int[] . class ) ) . isEmpty ( ) ; assertThat ( ArbitraryInstances . get ( Object[] . class ) ) . isEmpty ( ) ; assertThat ( ArbitraryInstances . get ( String[] . class ) ) . isEmpty ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public < E extends Comparable < E > > Set < E > create ( Collection < E > contents ) { return synchronizedSet ( new HashSet < E > ( contents ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean isEmpty ( ) { return MapMakerInternalMap . this . isEmpty ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected void beforeExecute ( Thread t , Runnable r ) { submitSuccessful . countDown ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Map < K , V > delegate ( ) { return backingMap ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable Entry < K , V > pollLastEntry ( ) { return Iterables . removeFirstMatching ( unfiltered . descendingMap ( ) . entrySet ( ) , entryPredicate ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected void afterDone ( ) { @RetainedLocalRef ListenableFuture < ? extends V > delegate = delegateRef ; maybePropagateCancellationTo ( delegate ) ; @RetainedLocalRef Future < ? > localTimer = timer ; / / Try to cancel the timer as an optimization . / / timer may be null if this call to run was by the timer task since there is no happens - before / / edge between the assignment to timer and an execution of the timer task . if ( localTimer ! = null ) { localTimer . cancel ( false ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Iterator < EndpointPair < N > > iterator ( ) { return Iterators . transform ( AbstractNetwork . this . edges ( ) . iterator ( ) , edge - > incidentNodes ( edge ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static IntStream stream ( OptionalInt optional ) { return optional . isPresent ( ) ? IntStream . of ( optional . getAsInt ( ) ) : IntStream . empty ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected boolean removeEldestEntry ( Entry < K , Timestamped < V > > ignored ) { boolean removal = ( maximumSize = = UNSET_INT ) ? false : ( size ( ) > maximumSize ) ; if ( ( removalListener ! = null ) & & removal ) { removalListener . onRemoval ( RemovalNotification . create ( ignored . getKey ( ) , ignored . getValue ( ) . getValue ( ) , RemovalCause . SIZE ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public < T > void testWhere_primitiveArrayMapping ( ) { Type t = new TypeCapture < T > ( ) {",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testScale_index_compute_longCollection ( ) { assertThat ( Quantiles . scale ( 10 ) . index ( 1 ) . compute ( SIXTEEN_SQUARES_LONGS ) ) . isWithin ( ALLOWED_ERROR ) . of ( SIXTEEN_SQUARES_DECILE_1 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void equivalent_edgeAddOrdersDiffer ( ) { GraphBuilder < Integer > builder = GraphBuilder . from ( graph ) ; MutableGraph < Integer > g1 = builder . build ( ) ; MutableGraph < Integer > g2 = builder . build ( ) ; / / for g1 , add 1 - > 2 first , then 3 - > 1 g1 . putEdge ( N1 , N2 ) ; g1 . putEdge ( N3 , N1 ) ; / / for g2 , add 3 - > 1 first , then 1 - > 2 g2 . putEdge ( N3 , N1 ) ; g2 . putEdge ( N1 , N2 ) ; assertThat ( g1 ) . isEqualTo ( g2 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSaturatedSubtract ( ) { for ( int a : ALL_INTEGER_CANDIDATES ) { for ( int b : ALL_INTEGER_CANDIDATES ) { assertOperationEquals ( a , b , \"s - \" , saturatedCast ( valueOf ( a ) . subtract ( valueOf ( b ) ) ) , IntMath . saturatedSubtract ( a , b ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSingle_serialization ( ) { SortedSet < String > set = of ( \"e\" ) ; SortedSet < String > copy = SerializableTester . reserializeAndAssert ( set ) ; assertEquals ( set . comparator ( ) , copy . comparator ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSegmentReplace ( ) { LocalCache < Object , Object > map = makeLocalCache ( createCacheBuilder ( ) . concurrencyLevel ( 1 ) . expireAfterAccess ( 99999 , SECONDS ) ) ; Segment < Object , Object > segment = map . segments[0] ; / / TODO ( fry ) : check recency ordering Object key = new Object ( ) ; int hash = map . hash ( key ) ; Object oldValue = new Object ( ) ; Object newValue = new Object ( ) ; AtomicReferenceArray < ReferenceEntry < Object , Object > > table = segment . table ; int index = hash & ( table . length ( ) - 1 ) ; DummyEntry < Object , Object > entry = DummyEntry . create ( key , hash , null ) ; DummyValueReference < Object , Object > oldValueRef = DummyValueReference . create ( oldValue ) ; entry . setValueReference ( oldValueRef ) ; / / no entry assertThat ( segment . replace ( key , hash , newValue ) ) . isNull ( ) ; assertThat ( segment . count ) . isEqualTo ( 0 ) ; / / same key table . set ( index , entry ) ; segment . count + + ; assertThat ( segment . count ) . isEqualTo ( 1 ) ; assertThat ( segment . get ( key , hash ) ) . isSameInstanceAs ( oldValue ) ; assertThat ( segment . replace ( key , hash , newValue ) ) . isSameInstanceAs ( oldValue ) ; assertThat ( segment . count ) . isEqualTo ( 1 ) ; assertThat ( segment . get ( key , hash ) ) . isSameInstanceAs ( newValue ) ; / / cleared entry . setValueReference ( oldValueRef ) ; assertThat ( segment . get ( key , hash ) ) . isSameInstanceAs ( oldValue ) ; oldValueRef . clear ( ) ; assertThat ( segment . replace ( key , hash , newValue ) ) . isNull ( ) ; assertThat ( segment . count ) . isEqualTo ( 0 ) ; assertThat ( segment . get ( key , hash ) ) . isNull ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static byte saturatedCast ( long value ) { if ( value > Byte . MAX_VALUE ) { return Byte . MAX_VALUE ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final FluentFuture < V > withTimeout ( Duration timeout , ScheduledExecutorService scheduledExecutor ) { return withTimeout ( toNanosSaturated ( timeout ) , NANOSECONDS , scheduledExecutor ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ImmutableNetwork . Builder < N , E > addNode ( N node ) { mutableNetwork . addNode ( node ) ; return this ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private void updateLastKnownIndex ( ) { if ( lastKnownIndex = = - 1 | | lastKnownIndex > = size ( ) | | ! Objects . equals ( key , key ( lastKnownIndex ) ) ) { lastKnownIndex = indexOf ( key ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < T > Set < T > intersection ( Set < ? extends T > set1 , Set < ? extends T > set2 ) { Set < T > result = copyToSet ( set1 ) ; result . retainAll ( set2 ) ; return result ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static boolean[] createSafeOctets ( String safeChars ) { int maxChar = - 1 ; char[] safeCharArray = safeChars . toCharArray ( ) ; for ( char c : safeCharArray ) { maxChar = max ( c , maxChar ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static TempFileCreator pickSecureCreator ( ) { try { Class . forName ( \"java . nio . file . Path\" ) ; return new JavaNioCreator ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected SortedSet < String > delegate ( ) { return delegate ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCeilingPowerOfTwoZero ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > BigIntegerMath . ceilingPowerOfTwo ( BigInteger . ZERO ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean isSatisfied ( ) { return satisfied ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testGet ( ) { for ( ImmutableTable < Character , Integer , String > testInstance : getTestInstances ( ) ) { assertEquals ( \"foo\" , testInstance . get ( 'a' , 1 ) ) ; assertEquals ( \"bar\" , testInstance . get ( 'b' , 1 ) ) ; assertEquals ( \"baz\" , testInstance . get ( 'a' , 2 ) ) ; assertThat ( testInstance . get ( 'b' , 2 ) ) . isNull ( ) ; assertThat ( testInstance . get ( 'c' , 3 ) ) . isNull ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static FactoryMethodDoesNotAcceptNull create ( String name ) { return new FactoryMethodDoesNotAcceptNull ( name ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private void resizeMeMaybe ( int newSize ) { int entriesSize = entries . length ; if ( newSize > entriesSize ) { int newCapacity = entriesSize + Math . max ( 1 , entriesSize > > > 1 ) ; if ( newCapacity < 0 ) { newCapacity = Integer . MAX_VALUE ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void test716 ( ) { assertEquals ( \"b\" , simplifyPath ( \" . / b\" ) ) ; assertEquals ( \"b\" , simplifyPath ( \" . / b / . \" ) ) ; assertEquals ( \"b\" , simplifyPath ( \" . / . / b / . / . \" ) ) ; assertEquals ( \"b\" , simplifyPath ( \" . / . / b\" ) ) ; assertEquals ( \"a / b\" , simplifyPath ( \" . / a / b\" ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEntryReflectsElementSetClear ( ) { initThreeCopies ( ) ; assertEquals ( 3 , getMultiset ( ) . count ( e0 ( ) ) ) ; Multiset . Entry < E > entry = getOnlyElement ( getMultiset ( ) . entrySet ( ) ) ; assertEquals ( 3 , entry . getCount ( ) ) ; getMultiset ( ) . elementSet ( ) . clear ( ) ; assertEquals ( 0 , entry . getCount ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Set < String > create ( String[] elements ) { return intersection ( emptySet ( ) , newHashSet ( samples ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E extends Enum < E > > EnumSet < E > complementOf ( Collection < E > collection ) { if ( collection instanceof EnumSet ) { return EnumSet . complementOf ( ( EnumSet < E > ) collection ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testToLong ( ) { for ( long a : UNSIGNED_INTS ) { assertThat ( UnsignedInts . toLong ( ( int ) a ) ) . isEqualTo ( a ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBuilderWithExpectedValuesPerKeyNegative ( ) { ImmutableListMultimap . Builder < String , String > builder = ImmutableListMultimap . builder ( ) ; assertThrows ( IllegalArgumentException . class , ( ) - > builder . expectedValuesPerKey ( - 1 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected int find ( Object o ) { return getList ( ) . indexOf ( o ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int remainingCapacity ( ) { return maxSize - size ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testArrayListMultimap ( ) { assertFreshInstance ( new TypeToken < ArrayListMultimap < String , ? > > ( ) {",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testLeastOfIterator_simple_negativeOne ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > numberOrdering . leastOf ( Iterators . forArray ( 3 , 4 , 5 , - 1 ) , - 1 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public RemovalCause getCause ( ) { return cause ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public K next ( ) { return entryIterator . next ( ) . getKey ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void copyOfImmutableValueGraph_optimized ( ) { ValueGraph < String , Integer > graph1 = ImmutableValueGraph . copyOf ( ValueGraphBuilder . directed ( ) . < String , Integer > build ( ) ) ; ValueGraph < String , Integer > graph2 = ImmutableValueGraph . copyOf ( graph1 ) ; assertThat ( graph2 ) . isSameInstanceAs ( graph1 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRoundToDouble_zero ( ) { new RoundToDoubleTester ( BigInteger . ZERO ) . setExpectation ( 0 . 0 , RoundingMode . values ( ) ) . test ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable K higherKey ( @ParametricNullness K key ) { return forward ( ) . lowerKey ( key ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testContainsEntryWithNullKeyAbsent ( ) { assertFalse ( multimap ( ) . entries ( ) . contains ( mapEntry ( null , v0 ( ) ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCreation_sevenElements ( ) { Multiset < String > multiset = ImmutableMultiset . of ( \"a\" , \"b\" , \"c\" , \"d\" , \"e\" , \"f\" , \"g\" ) ; assertEquals ( HashMultiset . create ( asList ( \"a\" , \"b\" , \"c\" , \"d\" , \"e\" , \"f\" , \"g\" ) ) , multiset ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean isEmpty ( ) { return delegateCollection ( ) . isEmpty ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static Test testsForHashMapNullKeysForbidden ( ) { return wrappedHashMapTests ( new WrappedHashMapGenerator ( ) { @Override Map < String , String > wrap ( HashMap < String , String > map ) { if ( map . containsKey ( null ) ) { throw new NullPointerException ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Map < K , V > makeEitherMap ( ) { try { return makePopulatedMap ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSampleCodeError1 ( ) { Optional < Integer > optionalInt = getSomeOptionalInt ( ) ; / / Number value = optionalInt . or ( 0 . 5 ) ; / / error",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final void replaceAll ( BiFunction < ? super K , ? super V , ? extends V > function ) { throw new UnsupportedOperationException ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable Entry < K , V > floorEntry ( K key ) { return standardFloorEntry ( key ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testWarmUp ( ) { RateLimiter limiter = RateLimiter . create ( 2 . 0 , 4000 , MILLISECONDS , 3 . 0 , stopwatch ) ; for ( int i = 0 ; i < 8 ; i + + ) { limiter . acquire ( ) ; / / #1",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int hashCode ( ) { return parent . hashCode ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testPutAll_unsupportedNonePresent ( ) { assertThrows ( UnsupportedOperationException . class , ( ) - > putAll ( createDisjointCollection ( ) ) ) ; expectUnchanged ( ) ; expectMissing ( e3 ( ) , e4 ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void removeMaxFromReplica ( SortedMap < Integer , AtomicInteger > replica , int maxValue ) { Integer replicatedMaxValue = replica . lastKey ( ) ; assertTrue ( \"maxValue is incorrect\" , replicatedMaxValue = = maxValue ) ; removeFromReplica ( replica , replicatedMaxValue ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testMultisetWrites ( ) { Multiset < String > multiset = ImmutableSortedMultiset . of ( \"a\" , \"b\" , \"a\" ) ; UnmodifiableCollectionTests . assertMultisetIsUnmodifiable ( multiset , \"test\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Integer next ( Integer value ) { return DELEGATE . next ( value ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void assertReverseView ( List < Integer > fromList , List < Integer > toList ) { / * fromList modifications reflected in toList * / fromList . set ( 0 , 5 ) ; assertEquals ( asList ( 4 , 3 , 2 , 5 ) , toList ) ; fromList . add ( 6 ) ; assertEquals ( asList ( 6 , 4 , 3 , 2 , 5 ) , toList ) ; fromList . add ( 2 , 9 ) ; assertEquals ( asList ( 6 , 4 , 3 , 9 , 2 , 5 ) , toList ) ; fromList . remove ( Integer . valueOf ( 2 ) ) ; assertEquals ( asList ( 6 , 4 , 3 , 9 , 5 ) , toList ) ; fromList . remove ( 3 ) ; assertEquals ( asList ( 6 , 3 , 9 , 5 ) , toList ) ; / * toList modifications reflected in fromList * / toList . remove ( 0 ) ; assertEquals ( asList ( 5 , 9 , 3 ) , fromList ) ; toList . add ( 7 ) ; assertEquals ( asList ( 7 , 5 , 9 , 3 ) , fromList ) ; toList . add ( 5 ) ; assertEquals ( asList ( 5 , 7 , 5 , 9 , 3 ) , fromList ) ; toList . remove ( Integer . valueOf ( 5 ) ) ; assertEquals ( asList ( 5 , 7 , 9 , 3 ) , fromList ) ; toList . set ( 1 , 8 ) ; assertEquals ( asList ( 5 , 7 , 8 , 3 ) , fromList ) ; toList . clear ( ) ; assertEquals ( emptyList ( ) , fromList ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String transformEntry ( String key , Integer value ) { * return ( value > = 0 ) ? key : \"no\" + key ; *",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testReplace_supportedPresent ( ) { try { assertEquals ( v0 ( ) , getMap ( ) . replace ( k0 ( ) , v3 ( ) ) ) ; expectReplacement ( entry ( k0 ( ) , v3 ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testContainsAllListIgnoresFrequency ( ) { assertTrue ( getMultiset ( ) . containsAll ( asList ( e0 ( ) , e0 ( ) , e0 ( ) ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable V putIfAbsent ( K key , V value ) { checkNotNull ( key ) ; checkNotNull ( value ) ; int hash = hash ( key ) ; return segmentFor ( hash ) . put ( key , hash , value , true ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public DeadEvent ( Object source , Object event ) { this . source = checkNotNull ( source ) ; this . event = checkNotNull ( event ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static ByteSink asByteSink ( File file , FileWriteMode . . . modes ) { return new FileByteSink ( file , modes ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Converter < A , B > reverse ( ) { return original ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testJoinTimeoutNoInterruptNotExpired ( ) { TimedThread thread = TimedThread . createWithDelay ( 20 ) ; thread . joinSuccessfully ( LONG_DELAY_MS ) ; assertNotInterrupted ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private File newDir ( String name ) { File file = new File ( rootDir , name ) ; file . mkdir ( ) ; return file ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < K extends @Nullable Object , V extends @Nullable Object > Multimap < K , V > synchronizedMultimap ( Multimap < K , V > multimap ) { return Synchronized . multimap ( multimap , null ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static void checkArgument ( boolean expression , String errorMessageTemplate , long p1 , int p2 ) { if ( ! expression ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private EmptyImmutableListMultimap ( ) { super ( ImmutableMap . of ( ) , 0 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public CompactLinkedHashMapFloodingTest ( ) { super ( ImmutableList . of ( Construction . mapFromKeys ( CompactLinkedHashMap::create ) ) , n - > n * log ( n ) , ImmutableList . of ( QueryOp . MAP_GET ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static ContiguousSet < Integer > closedOpen ( int lower , int upper ) { return create ( Range . closedOpen ( lower , upper ) , DiscreteDomain . integers ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable ImmutableSet < V > get ( @Nullable Object key ) { V outerValue = ImmutableMap . this . get ( key ) ; return ( outerValue = = null ) ? null : ImmutableSet . of ( outerValue ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testNulls ( ) { new NullPointerTester ( ) . testAllPublicStaticMethods ( UnsignedLong . class ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ImmutableSet < E > build ( ) { switch ( size ) { case 0: return of ( ) ; case 1: / * * requireNonNull is safe because we ensure that the first `size` elements have been * populated . * / return ( ImmutableSet < E > ) of ( requireNonNull ( contents[0] ) ) ; default: ImmutableSet < E > result ; if ( hashTable ! = null & & chooseTableSize ( size ) = = hashTable . length ) { @Nullable Object[] uniqueElements = shouldTrim ( size , contents . length ) ? Arrays . copyOf ( contents , size ) : contents ; result = new RegularImmutableSet < E > ( uniqueElements , hashCode , hashTable , hashTable . length - 1 , size ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testClear ( ) { Map < K , V > map ; try { map = makePopulatedMap ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { return forwardOrder + \" . reverse ( ) \" ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < E > edges ( ) { return edgeToReferenceNode . unmodifiableKeySet ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBuilderOrderValuesBy ( ) { ImmutableSetMultimap . Builder < String , Integer > builder = ImmutableSetMultimap . builder ( ) ; builder . put ( \"b\" , 3 ) ; builder . put ( \"d\" , 2 ) ; builder . put ( \"a\" , 5 ) ; builder . orderValuesBy ( Collections . reverseOrder ( ) ) ; builder . put ( \"c\" , 4 ) ; builder . put ( \"a\" , 2 ) ; builder . put ( \"b\" , 6 ) ; ImmutableSetMultimap < String , Integer > multimap = builder . build ( ) ; assertThat ( multimap . keySet ( ) ) . containsExactly ( \"b\" , \"d\" , \"a\" , \"c\" ) . inOrder ( ) ; assertThat ( multimap . values ( ) ) . containsExactly ( 6 , 3 , 2 , 5 , 2 , 4 ) . inOrder ( ) ; assertThat ( multimap . get ( \"a\" ) ) . containsExactly ( 5 , 2 ) . inOrder ( ) ; assertThat ( multimap . get ( \"b\" ) ) . containsExactly ( 6 , 3 ) . inOrder ( ) ; assertTrue ( multimap . get ( \"a\" ) instanceof ImmutableSortedSet ) ; assertEquals ( Collections . reverseOrder ( ) , ( ( ImmutableSortedSet < Integer > ) multimap . get ( \"a\" ) ) . comparator ( ) ) ; assertTrue ( multimap . get ( \"x\" ) instanceof ImmutableSortedSet ) ; assertEquals ( Collections . reverseOrder ( ) , ( ( ImmutableSortedSet < Integer > ) multimap . get ( \"x\" ) ) . comparator ( ) ) ; assertTrue ( multimap . asMap ( ) . get ( \"a\" ) instanceof ImmutableSortedSet ) ; assertEquals ( Collections . reverseOrder ( ) , ( ( ImmutableSortedSet < Integer > ) multimap . asMap ( ) . get ( \"a\" ) ) . comparator ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static List < Throwable > runThreadsAndReturnExceptions ( int numThreads , Runnable task ) { List < Thread > threads = new ArrayList < > ( numThreads ) ; List < Throwable > exceptions = new ArrayList < > ( numThreads ) ; for ( int i = 0 ; i < numThreads ; i + + ) { Thread thread = new Thread ( task ) ; thread . setUncaughtExceptionHandler ( new UncaughtExceptionHandler ( ) { @Override public void uncaughtException ( Thread t , Throwable e ) { exceptions . add ( e ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testStaticContext ( ) { assertEquals ( Map . class , mapType ( ) . getRawType ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testContains_no ( ) { assertFalse ( \"containsValue ( notPresent ) should return false\" , getMap ( ) . containsValue ( v3 ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCartesianProduct_binary1x1 ( ) { assertThat ( cartesianProduct ( set ( 1 ) , set ( 2 ) ) ) . contains ( list ( 1 , 2 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void checkMessage ( Exception e ) { assertThat ( e ) . hasMessageThat ( ) . isEqualTo ( \"I ate 5 pies . \" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void shutdown ( ) { throw new UnsupportedOperationException ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean removeAll ( Collection < ? > c ) { return removeAllImpl ( this , c ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testJoin ( ) { assertThat ( Booleans . join ( \" , \" , EMPTY ) ) . isEmpty ( ) ; assertThat ( Booleans . join ( \" , \" , ARRAY_FALSE ) ) . isEqualTo ( \"false\" ) ; assertThat ( Booleans . join ( \" , \" , false , true ) ) . isEqualTo ( \"false , true\" ) ; assertThat ( Booleans . join ( \"\" , false , true , false ) ) . isEqualTo ( \"falsetruefalse\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testLocationEquals ( ) { ClassLoader child = getClass ( ) . getClassLoader ( ) ; ClassLoader parent = child . getParent ( ) ; new EqualsTester ( ) . addEqualityGroup ( new ClassPath . LocationInfo ( new File ( \"foo . jar\" ) , child ) , new ClassPath . LocationInfo ( new File ( \"foo . jar\" ) , child ) ) . addEqualityGroup ( new ClassPath . LocationInfo ( new File ( \"foo . jar\" ) , parent ) ) . addEqualityGroup ( new ClassPath . LocationInfo ( new File ( \"foo\" ) , child ) ) . testEquals ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void test15ByteStringFromSipHashPaper ( ) { byte[] message = new byte[] { 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0a , 0x0b , 0x0c , 0x0d , 0x0e",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void twoMixedArgs ( String s , @Nullable Integer i ) { checkNotNull ( s ) ; i . intValue ( ) ; / / ok to throw NPE?",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Splitter trimResults ( CharMatcher trimmer ) { checkNotNull ( trimmer ) ; return new Splitter ( strategy , omitEmptyStrings , trimmer , limit ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testValidSurrogatePairAt ( ) { assertTrue ( Strings . validSurrogatePairAt ( \"\\uD8AB\\uDCAB\" , 0 ) ) ; assertTrue ( Strings . validSurrogatePairAt ( \"abc\\uD8AB\\uDCAB\" , 3 ) ) ; assertTrue ( Strings . validSurrogatePairAt ( \"abc\\uD8AB\\uDCABxyz\" , 3 ) ) ; assertFalse ( Strings . validSurrogatePairAt ( \"\\uD8AB\\uD8AB\" , 0 ) ) ; assertFalse ( Strings . validSurrogatePairAt ( \"\\uDCAB\\uDCAB\" , 0 ) ) ; assertFalse ( Strings . validSurrogatePairAt ( \"\\uD8AB\\uDCAB\" , - 1 ) ) ; assertFalse ( Strings . validSurrogatePairAt ( \"\\uD8AB\\uDCAB\" , 1 ) ) ; assertFalse ( Strings . validSurrogatePairAt ( \"\\uD8AB\\uDCAB\" , - 2 ) ) ; assertFalse ( Strings . validSurrogatePairAt ( \"\\uD8AB\\uDCAB\" , 2 ) ) ; assertFalse ( Strings . validSurrogatePairAt ( \"x\\uDCAB\" , 0 ) ) ; assertFalse ( Strings . validSurrogatePairAt ( \"\\uD8ABx\" , 0 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public < N1 extends N , E1 extends E > MutableNetwork < N1 , E1 > build ( ) { return new StandardMutableNetwork < > ( this ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testOf5 ( ) { assertThat ( ImmutableLongArray . of ( 0 , 1 , 3 , 6 , 10 ) . asList ( ) ) . containsExactly ( 0L , 1L , 3L , 6L , 10L ) . inOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final void validateGraphState ( ) { validateGraph ( graph ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testIndexOf_consumedDataWithDuplicates ( ) { Iterator < String > iterator = Lists . newArrayList ( \"manny\" , \"mo\" , \"mo\" , \"jack\" ) . iterator ( ) ; assertEquals ( 1 , Iterators . indexOf ( iterator , equalTo ( \"mo\" ) ) ) ; assertEquals ( \"mo\" , iterator . next ( ) ) ; assertEquals ( \"jack\" , iterator . next ( ) ) ; assertFalse ( iterator . hasNext ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final < S extends @Nullable T > Equivalence < Iterable < S > > pairwise ( ) { / / Ideally , the returned equivalence would support Iterable < ? extends T > . However , / / the need for this is so rare that it's not worth making callers deal with the ugly wildcard . return new PairwiseEquivalence < > ( this ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected List < String > create ( String[] elements ) { String[] suffix = { \"f\" , \"g\"",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCartesianProduct_binary1x1 ( ) { assertThat ( cartesianProduct ( list ( 1 ) , list ( 2 ) ) ) . contains ( list ( 1 , 2 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public K[] createKeyArray ( int length ) { return ( ( TestMultimapGenerator < K , V , M > ) multimapGenerator . getInnerGenerator ( ) ) . createKeyArray ( length ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { StringBuilder builder = new StringBuilder ( \"BaseEncoding . \" ) ; builder . append ( alphabet ) ; if ( 8 % alphabet . bitsPerChar ! = 0 ) { if ( paddingChar = = null ) { builder . append ( \" . omitPadding ( ) \" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEviction_maxWeightOneSegment ( ) { IdentityLoader < Integer > loader = identityLoader ( ) ; LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( 1 ) . maximumWeight ( 2 * MAX_SIZE ) . weigher ( constantWeigher ( 2 ) ) . build ( loader ) ; for ( int i = 0 ; i < 2 * MAX_SIZE ; i + + ) { cache . getUnchecked ( i ) ; assertThat ( cache . size ( ) ) . isEqualTo ( min ( i + 1 , MAX_SIZE ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public B next ( ) { return convert ( fromIterator . next ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static < T extends @Nullable Object > ListenableFuture < ? extends T > [] gwtCompatibleToArray ( Iterable < ? extends ListenableFuture < ? extends T > > futures ) { Collection < ListenableFuture < ? extends T > > collection ; if ( futures instanceof Collection ) { collection = ( Collection < ListenableFuture < ? extends T > > ) futures ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testOrNull_absent ( ) { assertThat ( Optional . absent ( ) . orNull ( ) ) . isNull ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final double getRate ( ) { synchronized ( mutex ( ) ) { return doGetRate ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCopyOf_collection_oneElement ( ) { Collection < String > c = MinimalCollection . of ( \"a\" ) ; Multiset < String > multiset = ImmutableMultiset . copyOf ( c ) ; assertEquals ( HashMultiset . create ( asList ( \"a\" ) ) , multiset ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private Base16Encoding ( Alphabet alphabet ) { super ( alphabet , null ) ; checkArgument ( alphabet . chars . length = = 16 ) ; for ( int i = 0 ; i < 256 ; + + i ) { encoding[i] = alphabet . encode ( i > > > 4 ) ; encoding[i | 0x100] = alphabet . encode ( i & 0xF ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static ImmutableLongArray copyOf ( Iterable < Long > values ) { if ( values instanceof Collection ) { return copyOf ( ( Collection < Long > ) values ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRetainAll_duplicatesKept ( ) { E[] array = createSamplesArray ( ) ; array[1] = e0 ( ) ; collection = getSubjectGenerator ( ) . create ( array ) ; assertFalse ( \"containsDuplicates . retainAll ( superset ) should return false\" , collection . retainAll ( MinimalCollection . of ( createSamplesArray ( ) ) ) ) ; expectContents ( array ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Set < V > createCollection ( ) { return factory . get ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static final Converter < String , Long > STR_TO_LONG = new Converter < String , Long > ( ) { @Override protected Long doForward ( String object ) { return Long . valueOf ( object ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static String getNameWithoutExtension ( String file ) { checkNotNull ( file ) ; String fileName = new File ( file ) . getName ( ) ; int dotIndex = fileName . lastIndexOf ( ' . ' ) ; return ( dotIndex = = - 1 ) ? fileName : fileName . substring ( 0 , dotIndex ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static < T extends @Nullable Object > Ordering < T > reverse ( Comparator < T > forward ) { return Ordering . from ( forward ) . reverse ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void assertHashStringEquivalence ( HashFunction hashFunction , Random random ) { / / Test that only data and data - order is important , not the individual operations . new EqualsTester ( ) . addEqualityGroup ( hashFunction . hashUnencodedChars ( \"abc\" ) , hashFunction . newHasher ( ) . putUnencodedChars ( \"abc\" ) . hash ( ) , hashFunction . newHasher ( ) . putUnencodedChars ( \"ab\" ) . putUnencodedChars ( \"c\" ) . hash ( ) , hashFunction . newHasher ( ) . putUnencodedChars ( \"a\" ) . putUnencodedChars ( \"bc\" ) . hash ( ) , hashFunction . newHasher ( ) . putUnencodedChars ( \"a\" ) . putUnencodedChars ( \"b\" ) . putUnencodedChars ( \"c\" ) . hash ( ) , hashFunction . newHasher ( ) . putChar ( 'a' ) . putUnencodedChars ( \"bc\" ) . hash ( ) , hashFunction . newHasher ( ) . putUnencodedChars ( \"ab\" ) . putChar ( 'c' ) . hash ( ) , hashFunction . newHasher ( ) . putChar ( 'a' ) . putChar ( 'b' ) . putChar ( 'c' ) . hash ( ) ) . testEquals ( ) ; int size = random . nextInt ( 2048 ) ; byte[] bytes = new byte[size] ; random . nextBytes ( bytes ) ; String string = new String ( bytes , US_ASCII ) ; assertEquals ( hashFunction . hashUnencodedChars ( string ) , hashFunction . newHasher ( ) . putUnencodedChars ( string ) . hash ( ) ) ; for ( Charset charset : CHARSETS ) { assertEquals ( hashFunction . hashString ( string , charset ) , hashFunction . newHasher ( ) . putString ( string , charset ) . hash ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private ImmutableIntArray ( int[] array ) { this ( array , 0 , array . length ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public K[] createArray ( int length ) { / / TODO: with appropriate refactoring of OneSizeGenerator , we can perhaps / / tidy this up and get rid of the casts here and in / / MapValueCollectionGenerator . return ( ( TestMapGenerator < K , V > ) mapGenerator . getInnerGenerator ( ) ) . createKeyArray ( length ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static < V > ImmutableSet . Builder < V > valuesBuilder ( @Nullable Comparator < ? super V > valueComparator ) { return ( valueComparator = = null ) ? new ImmutableSet . Builder < > ( ) : new ImmutableSortedSet . Builder < > ( valueComparator ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public SortedSet < E > subSet ( E fromElement , E toElement ) { synchronized ( mutex ) { return sortedSet ( delegate ( ) . subSet ( fromElement , toElement ) , mutex ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testOfInstanceSuppliesNull ( ) { Supplier < @Nullable Integer > nullSupplier = Suppliers . ofInstance ( null ) ; assertThat ( nullSupplier . get ( ) ) . isNull ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean processBytes ( byte[] buf , int off , int len ) { assertThat ( newPreFilledByteArray ( 8192 ) ) . isEqualTo ( Arrays . copyOfRange ( buf , off , off + len ) ) ; return false ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void testEncodedLengthFails ( String invalidString , int invalidCodePointIndex ) { try { Utf8 . encodedLength ( invalidString ) ; fail ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Collection < Method > suppressForTreeMapNatural ( ) { return asList ( getPutNullKeyUnsupportedMethod ( ) , getPutAllNullKeyUnsupportedMethod ( ) , getCreateWithNullKeyUnsupportedMethod ( ) , getCreateWithNullUnsupportedMethod ( ) , / / for keySet getContainsEntryWithIncomparableKeyMethod ( ) , getContainsEntryWithIncomparableValueMethod ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void lock ( ) { delegate ( ) . lock ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testFromStringUnparseableNonsense ( ) { / / Some nonsense that causes parse failures . checkFromStringCase ( \"[goo . gl]\" , 1 , null , 99 , false ) ; checkFromStringCase ( \"[goo . gl]:80\" , 1 , null , 99 , false ) ; checkFromStringCase ( \"[\" , 1 , null , 99 , false ) ; checkFromStringCase ( \"[]:\" , 1 , null , 99 , false ) ; checkFromStringCase ( \"[]:80\" , 1 , null , 99 , false ) ; checkFromStringCase ( \"[]bad\" , 1 , null , 99 , false ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testServiceStartupTimes_selfStartingServices ( ) { / / This tests to ensure that: / / 1 . service times are accurate when the service is started by the manager / / 2 . service times are recorded when the service is not started by the manager ( but they may / / not be accurate ) . Service b = new NoOpDelayedService ( 353 ) { @Override protected void doStart ( ) { super . doStart ( ) ; / / This will delay service listener execution at least 150 milliseconds Uninterruptibles . sleepUninterruptibly ( 150 , MILLISECONDS ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < B extends @Nullable Object > MutableClassToInstanceMap < B > create ( Map < Class < ? extends @NonNull B > , B > backingMap ) { return new MutableClassToInstanceMap < > ( backingMap ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public long updateAndGet ( K key , LongUnaryOperator updaterFunction ) { checkNotNull ( updaterFunction ) ; Long result = map . compute ( key , ( K k , @Nullable Long value ) - > updaterFunction . applyAsLong ( value = = null ? 0L : value . longValue ( ) ) ) ; return requireNonNull ( result ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void transpose_directedNetwork ( ) { MutableNetwork < Integer , String > directedGraph = NetworkBuilder . directed ( ) . allowsParallelEdges ( true ) . allowsSelfLoops ( true ) . build ( ) ; directedGraph . addEdge ( N1 , N3 , E13 ) ; directedGraph . addEdge ( N3 , N1 , E31 ) ; directedGraph . addEdge ( N1 , N2 , E12 ) ; directedGraph . addEdge ( N1 , N2 , E12_A ) ; directedGraph . addEdge ( N1 , N1 , E11 ) ; directedGraph . addEdge ( N3 , N4 , E34 ) ; MutableNetwork < Integer , String > expectedTranspose = NetworkBuilder . directed ( ) . allowsParallelEdges ( true ) . allowsSelfLoops ( true ) . build ( ) ; expectedTranspose . addEdge ( N3 , N1 , E13 ) ; expectedTranspose . addEdge ( N1 , N3 , E31 ) ; expectedTranspose . addEdge ( N2 , N1 , E12 ) ; expectedTranspose . addEdge ( N2 , N1 , E12_A ) ; expectedTranspose . addEdge ( N1 , N1 , E11 ) ; expectedTranspose . addEdge ( N4 , N3 , E34 ) ; Network < Integer , String > transpose = transpose ( directedGraph ) ; assertThat ( transpose ) . isEqualTo ( expectedTranspose ) ; assertThat ( transpose ( transpose ) ) . isSameInstanceAs ( directedGraph ) ; AbstractNetworkTest . validateNetwork ( transpose ) ; assertThat ( transpose . edgesConnecting ( N1 , N2 ) ) . isEmpty ( ) ; assertThat ( transpose . edgeConnecting ( N1 , N2 ) ) . isEmpty ( ) ; assertThat ( transpose . edgeConnectingOrNull ( N1 , N2 ) ) . isNull ( ) ; for ( Integer node : directedGraph . nodes ( ) ) { assertThat ( directedGraph . inDegree ( node ) ) . isSameInstanceAs ( transpose . outDegree ( node ) ) ; assertThat ( directedGraph . outDegree ( node ) ) . isSameInstanceAs ( transpose . inDegree ( node ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBuilder_withMutableEntry ( ) { ImmutableSortedMap . Builder < String , Integer > builder = ImmutableSortedMap . naturalOrder ( ) ; StringHolder holder = new StringHolder ( ) ; holder . string = \"one\" ; Entry < String , Integer > entry = new AbstractMapEntry < String , Integer > ( ) { @Override public String getKey ( ) { return holder . string ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testAsEnumerationTypical ( ) { Iterator < Integer > iter = ImmutableList . of ( 1 , 2 , 3 ) . iterator ( ) ; Enumeration < Integer > enumer = Iterators . asEnumeration ( iter ) ; assertTrue ( enumer . hasMoreElements ( ) ) ; assertEquals ( 1 , ( int ) enumer . nextElement ( ) ) ; assertTrue ( enumer . hasMoreElements ( ) ) ; assertEquals ( 2 , ( int ) enumer . nextElement ( ) ) ; assertTrue ( enumer . hasMoreElements ( ) ) ; assertEquals ( 3 , ( int ) enumer . nextElement ( ) ) ; assertFalse ( enumer . hasMoreElements ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSha512 ( ) { HashTestUtils . checkAvalanche ( Hashing . sha512 ( ) , 100 , 0 . 4 ) ; HashTestUtils . checkNo2BitCharacteristics ( Hashing . sha512 ( ) ) ; HashTestUtils . checkNoFunnels ( Hashing . sha512 ( ) ) ; HashTestUtils . assertInvariants ( Hashing . sha512 ( ) ) ; assertEquals ( \"Hashing . sha512 ( ) \" , Hashing . sha512 ( ) . toString ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int getWeight ( ) { return 1 ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static BaseEncoding base16 ( ) { return BASE16 ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEquals ( ) { SetMultimap < Integer , String > map1 = ImmutableSetMultimap . of ( 1 , \"one\" ) ; SetMultimap < Integer , String > map2 = ImmutableSetMultimap . of ( 2 , \"two\" ) ; new EqualsTester ( ) . addEqualityGroup ( map1 , wrap ( map1 ) , wrap ( map1 ) ) . addEqualityGroup ( map2 , wrap ( map2 ) ) . testEquals ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int hashCode ( ) { return alphabet . hashCode ( ) ^ Objects . hashCode ( paddingChar ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testStrong_builder ( ) { int concurrencyLevel = 42 ; Interner < Object > interner = Interners . newBuilder ( ) . strong ( ) . concurrencyLevel ( concurrencyLevel ) . build ( ) ; InternerImpl < Object > internerImpl = ( InternerImpl < Object > ) interner ; assertEquals ( Strength . STRONG , internerImpl . map . keyStrength ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Builder < N > putEdge ( N nodeU , N nodeV ) { mutableGraph . putEdge ( nodeU , nodeV ) ; return this ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSum ( ) { Multiset < String > ms1 = HashMultiset . create ( asList ( \"a\" , \"b\" , \"a\" ) ) ; Multiset < String > ms2 = HashMultiset . create ( asList ( \"b\" , \"c\" ) ) ; assertThat ( sum ( ms1 , ms2 ) ) . containsExactly ( \"a\" , \"a\" , \"b\" , \"b\" , \"c\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { return \"Converter . identity ( ) \" ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testAsListInconsistentComparator ( ) { ImmutableSet < String > set = ImmutableSortedSet . orderedBy ( STRING_LENGTH ) . add ( \"in\" , \"the\" , \"quick\" , \"jumped\" , \"over\" , \"a\" ) . build ( ) ; ImmutableList < String > list = set . asList ( ) ; assertTrue ( list . contains ( \"the\" ) ) ; assertEquals ( 2 , list . indexOf ( \"the\" ) ) ; assertEquals ( 2 , list . lastIndexOf ( \"the\" ) ) ; assertFalse ( list . contains ( \"dog\" ) ) ; assertEquals ( - 1 , list . indexOf ( \"dog\" ) ) ; assertEquals ( - 1 , list . lastIndexOf ( \"dog\" ) ) ; assertFalse ( list . contains ( \"chicken\" ) ) ; assertEquals ( - 1 , list . indexOf ( \"chicken\" ) ) ; assertEquals ( - 1 , list . lastIndexOf ( \"chicken\" ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < Feature < ? super List > > getImpliedFeatures ( ) { return implied ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable V put ( @ParametricNullness R rowKey , @ParametricNullness C columnKey , @ParametricNullness V value ) { synchronized ( mutex ) { return delegate ( ) . put ( rowKey , columnKey , value ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testIntMod ( ) { for ( long x : ALL_LONG_CANDIDATES ) { for ( int m : POSITIVE_INTEGER_CANDIDATES ) { assertEquals ( valueOf ( x ) . mod ( valueOf ( m ) ) . intValue ( ) , LongMath . mod ( x , m ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . toString ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Strength valueStrength ( ) { return Strength . STRONG ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public SameShortInstance ( Short i ) { this . i = checkNotNull ( i ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public < T extends B > @Nullable T putInstance ( Class < T > type , T value ) { throw new UnsupportedOperationException ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected SortedSet < E > standardSubSet ( @ParametricNullness E fromElement , @ParametricNullness E toElement ) { return subSet ( fromElement , true , toElement , false ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static HashFunction adler32 ( ) { return ChecksumType . ADLER_32 . hashFunction ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static CharMatcher singleWidth ( ) { return SingleWidth . INSTANCE ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void oneArgCheckForNullCorrectlyThrowsOtherThanNpe ( @CheckForNull String s ) { throw new FooException ( ) ; / / ok , as long as it's not NullPointerException",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private void trim ( ) { int left = 0 ; int right = 2 * k - 1 ; int minThresholdPosition = 0 ; / / The leftmost position at which the greatest of the k lower elements / / - - the new value of threshold - - might be found . int iterations = 0 ; int maxIterations = IntMath . log2 ( right - left , RoundingMode . CEILING ) * 3 ; while ( left < right ) { int pivotIndex = ( left + right + 1 ) > > > 1 ; int pivotNewIndex = partition ( left , right , pivotIndex ) ; if ( pivotNewIndex > k ) { right = pivotNewIndex - 1 ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Map < K , Collection < V > > asMap ( ) { Map < K , Collection < V > > result = map ; if ( result = = null ) { result = map = Collections . unmodifiableMap ( Maps . transformValues ( delegate . asMap ( ) , Multimaps::unmodifiableValueCollection ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static boolean isProxyOfSameInterfaces ( Object arg , Class < ? > proxyClass ) { return proxyClass . isInstance ( arg ) / / Equal proxy instances should mostly be instance of proxyClass / / Under some edge cases ( such as the proxy of JDK types serialized and then deserialized ) / / the proxy type may not be the same . / / We first check isProxyClass ( ) so that the common case of comparing with non - proxy objects / / is efficient . | | ( Proxy . isProxyClass ( arg . getClass ( ) ) & & Arrays . equals ( arg . getClass ( ) . getInterfaces ( ) , proxyClass . getInterfaces ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBase32Offset ( ) { testEncodesWithOffset ( base32 ( ) , \"foobar\" , 0 , 6 , \"MZXW6YTBOI = = = = = = \" ) ; testEncodesWithOffset ( base32 ( ) , \"foobar\" , 1 , 5 , \"N5XWEYLS\" ) ; testEncodesWithOffset ( base32 ( ) , \"foobar\" , 2 , 3 , \"N5RGC = = = \" ) ; testEncodesWithOffset ( base32 ( ) , \"foobar\" , 3 , 1 , \"MI = = = = = = \" ) ; testEncodesWithOffset ( base32 ( ) , \"foobar\" , 4 , 0 , \"\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public V get ( int index ) { return getValue ( index ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Executor executor ( ) { return executor ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testAddAtIndex_supportedPresent ( ) { getList ( ) . add ( 0 , e0 ( ) ) ; expectAdded ( 0 , e0 ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testStrongImplementations ( ) { for ( Striped < ? > striped : strongImplementations ( ) ) { WeakReference < Object > weakRef = new WeakReference < > ( striped . get ( new Object ( ) ) ) ; WeakReference < Object > garbage = new WeakReference < > ( new Object ( ) ) ; GcFinalization . awaitClear ( garbage ) ; assertThat ( weakRef . get ( ) ) . isNotNull ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static < E > E[] newEArray ( int capacity ) { return ( E[] ) new Object[capacity] ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEmptyMultisetFirst ( ) { assertNull ( sortedMultiset . firstEntry ( ) ) ; assertThrows ( NoSuchElementException . class , ( ) - > sortedMultiset . elementSet ( ) . first ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testFromByteArrayWithTooShortArrayInputThrowsIllegalArgumentException ( ) { byte[] buffer = MANY_VALUES_PAIRED_STATS . toByteArray ( ) ; byte[] tooShortByteArray = ByteBuffer . allocate ( buffer . length - 1 ) . order ( ByteOrder . LITTLE_ENDIAN ) . put ( buffer , 0 , buffer . length - 1 ) . array ( ) ; assertThrows ( IllegalArgumentException . class , ( ) - > PairedStats . fromByteArray ( tooShortByteArray ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testLowerCamelToLowerCamel ( ) { assertThat ( LOWER_CAMEL . to ( LOWER_CAMEL , \"foo\" ) ) . isEqualTo ( \"foo\" ) ; assertThat ( LOWER_CAMEL . to ( LOWER_CAMEL , \"fooBar\" ) ) . isEqualTo ( \"fooBar\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public MapSplitter withKeyValueSeparator ( String separator ) { return withKeyValueSeparator ( on ( separator ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public < N1 extends N > MutableGraph < N1 > build ( ) { return new StandardMutableGraph < > ( this ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBuilderPutAllWithEmptyMap ( ) { ImmutableSortedMap < String , Integer > map = ImmutableSortedMap . < String , Integer > naturalOrder ( ) . putAll ( Collections . < String , Integer > emptyMap ( ) ) . build ( ) ; assertEquals ( Collections . < String , Integer > emptyMap ( ) , map ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private @Nullable Type captureNullable ( @Nullable Type type ) { if ( type = = null ) { return null ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final void putAll ( RangeMap < K , ? extends V > rangeMap ) { throw new UnsupportedOperationException ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public List < E > create ( Object . . . elements ) { return ( List < E > ) SerializableTester . reserialize ( gen . create ( elements ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( ForwardingSortedMultisetTest . class ) ; suite . addTest ( SortedMultisetTestSuiteBuilder . using ( new TestStringMultisetGenerator ( ) { @Override protected Multiset < String > create ( String[] elements ) { return new StandardImplForwardingSortedMultiset < > ( TreeMultiset . create ( asList ( elements ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ListenableFuture < Long > call ( ) { return SettableFuture . create ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public UseList < ? extends List < Enum < ? extends Enum < ? > > > > wildcardBoundUsesImplicitlyRecursiveBoundedWildcard ( UseList < ? extends List < Enum < ? > > > arg ) { return isSubtype ( arg ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testStringSplitOnEmptyStringOmitEmptyString ( ) { assertThat ( Splitter . on ( \" . \" ) . omitEmptyStrings ( ) . split ( \"\" ) ) . isEmpty ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testGet_useFirstPublicConstant ( ) { assertSame ( WithPublicConstants . FIRST , ArbitraryInstances . get ( WithPublicConstants . class ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSetCount_negative_removeSupported ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > setCountNoCheckReturnValue ( e3 ( ) , - 1 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testAddSampleInstances_oneInstance ( ) { FreshValueGenerator generator = new FreshValueGenerator ( ) ; generator . addSampleInstances ( String . class , ImmutableList . of ( \"a\" ) ) ; assertEquals ( \"a\" , generator . generateFresh ( String . class ) ) ; assertEquals ( \"a\" , generator . generateFresh ( String . class ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public < X extends Throwable > ClosingFuture < V > catchingAsync ( Class < X > exceptionType , AsyncClosingFunction < ? super X , ? extends V > fallback , Executor executor ) { return catchingAsyncMoreGeneric ( exceptionType , fallback , executor ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < T extends @Nullable Object > Function < Supplier < T > , T > supplierFunction ( ) { @SuppressWarnings ( \"unchecked\" ) / / implementation is \"fully variant\" SupplierFunction < T > sf = ( SupplierFunction < T > ) SupplierFunctionImpl . INSTANCE ; return sf ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBreadthOrder ( ) { assertThat ( iterationOrder ( ADAPTER . breadthFirstTraversal ( h ) ) ) . isEqualTo ( \"hdegabcf\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static byte max ( byte . . . array ) { checkArgument ( array . length > 0 ) ; int max = toUnsignedInt ( array[0] ) ; for ( int i = 1 ; i < array . length ; i + + ) { int next = toUnsignedInt ( array[i] ) ; if ( next > max ) { max = next ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void putNext ( Waiter waiter , @Nullable Waiter newValue ) { ATOMIC_HELPER . putNext ( waiter , newValue ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testGetUnchecked_executionExceptionUnchecked ( ) { UncheckedExecutionException expected = assertThrows ( UncheckedExecutionException . class , ( ) - > getUnchecked ( FAILED_FUTURE_UNCHECKED_EXCEPTION ) ) ; assertThat ( expected ) . hasCauseThat ( ) . isEqualTo ( UNCHECKED_EXCEPTION ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEquals ( ) { new EqualsTester ( ) . addEqualityGroup ( newDelegatingList ( LIST1 ) ) / / Actually , this violates List#equals contract . / / But whatever , no one is going to proxy List ( hopefully ) . . addEqualityGroup ( newDelegatingList ( LIST1 ) ) . addEqualityGroup ( newDelegatingList ( LIST2 ) ) . addEqualityGroup ( newProxyWithEqualsForInterfaces ( List . class , Runnable . class ) , newProxyWithEqualsForInterfaces ( List . class , Runnable . class ) ) . addEqualityGroup ( newProxyWithEqualsForInterfaces ( Runnable . class , List . class ) ) . addEqualityGroup ( newDelegatingListWithEquals ( LIST1 ) , newDelegatingListWithEquals ( LIST1 ) , SerializableTester . reserialize ( newDelegatingListWithEquals ( LIST1 ) ) ) . addEqualityGroup ( newDelegatingListWithEquals ( LIST2 ) , newProxyWithSubHandler1 ( LIST2 ) , / / Makes sure type of handler doesn't affect equality newProxyWithSubHandler2 ( LIST2 ) ) . addEqualityGroup ( newDelegatingIterableWithEquals ( LIST2 ) ) / / different interface . testEquals ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ImmutableBiMapFloodingTest ( ) { super ( EnumSet . allOf ( ConstructionPathway . class ) . stream ( ) . flatMap ( path - > Stream . < Construction < BiMap < Object , Object > > > of ( keys - > path . create ( transform ( keys , key - > immutableEntry ( key , new Object ( ) ) ) ) , keys - > path . create ( transform ( keys , key - > immutableEntry ( new Object ( ) , key ) ) ) , keys - > path . create ( transform ( keys , key - > immutableEntry ( key , key ) ) ) ) ) . collect ( toImmutableList ( ) ) , n - > n * log ( n ) , ImmutableList . of ( QueryOp . create ( \"BiMap . get\" , ( biMap , key ) - > { Object unused = biMap . get ( key ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testReverseOrder ( ) { SortedSet < String > set = ImmutableSortedSet . < String > reverseOrder ( ) . add ( \"a\" , \"b\" , \"c\" ) . build ( ) ; assertThat ( set ) . containsExactly ( \"c\" , \"b\" , \"a\" ) . inOrder ( ) ; assertTrue ( isInOrder ( asList ( \"c\" , \"b\" , \"a\" ) , set . comparator ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected A doBackward ( C c ) { throw new AssertionError ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void annotatedIn2 ( Object o ) { annotatedIn2Events . add ( o ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void onSuccess ( QueryResult result ) { * storeInCache ( result ) ; *",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < N > nodes ( ) { return nodeConnections . unmodifiableKeySet ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testIndex_nullValue ( ) { List < @Nullable Integer > values = Arrays . asList ( 1 , null ) ; assertThrows ( NullPointerException . class , ( ) - > Multimaps . index ( ( List < Integer > ) values , Functions . identity ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable E ceiling ( @ParametricNullness E e ) { return delegate ( ) . ceiling ( e ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void hasCycle_cyclicMultigraph ( ) { for ( MutableNetwork < Integer , String > network : networksToTest ) { network . addEdge ( 1 , 2 , \"1 - 2a\" ) ; network . addEdge ( 1 , 2 , \"1 - 2b\" ) ; network . addEdge ( 2 , 3 , \"2 - 3\" ) ; network . addEdge ( 3 , 1 , \"3 - 1\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean equals ( @Nullable Object obj ) { return slowItDown ( ) ! = 1 & & super . equals ( obj ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E extends Enum < E > > EnumSet < E > complementOf ( Collection < E > collection , Class < E > type ) { checkNotNull ( collection ) ; return ( collection instanceof EnumSet ) ? EnumSet . complementOf ( ( EnumSet < E > ) collection ) : makeComplementByHand ( collection , type ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private CartesianSet ( ImmutableList < ImmutableSet < E > > axes , CartesianList < E > delegate ) { this . axes = axes ; this . delegate = delegate ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected LoadingCache < String , Boolean > delegate ( ) { return mock ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testPropagatesRemoveThenAddToMultimap ( ) { int oldSize = getNumElements ( ) ; Collection < V > result = multimap ( ) . asMap ( ) . get ( k0 ( ) ) ; assertTrue ( result . remove ( v0 ( ) ) ) ; assertFalse ( multimap ( ) . containsKey ( k0 ( ) ) ) ; assertFalse ( multimap ( ) . containsEntry ( k0 ( ) , v0 ( ) ) ) ; assertEmpty ( result ) ; assertTrue ( result . add ( v1 ( ) ) ) ; assertTrue ( result . add ( v2 ( ) ) ) ; assertContentsAnyOrder ( result , v1 ( ) , v2 ( ) ) ; assertContentsAnyOrder ( multimap ( ) . get ( k0 ( ) ) , v1 ( ) , v2 ( ) ) ; assertTrue ( multimap ( ) . containsKey ( k0 ( ) ) ) ; assertFalse ( multimap ( ) . containsEntry ( k0 ( ) , v0 ( ) ) ) ; assertTrue ( multimap ( ) . containsEntry ( k0 ( ) , v2 ( ) ) ) ; assertEquals ( oldSize + 1 , multimap ( ) . size ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testPutAll_unsupportedSomePresent ( ) { assertThrows ( UnsupportedOperationException . class , ( ) - > putAll ( MinimalCollection . of ( e3 ( ) , e0 ( ) ) ) ) ; expectUnchanged ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void forEachRemaining ( Consumer < ? super OutElementT > action ) { fromSpliterator . forEachRemaining ( fromElement - > action . accept ( function . apply ( fromElement ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Spliterator < V > spliterator ( ) { return Spliterators . spliterator ( this , Spliterator . ORDERED ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int chooseSize ( Random random ) { return random . nextInt ( max - min + 1 ) + min ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCopyOf ( ) { Map < String , Integer > original = new LinkedHashMap < > ( ) ; original . put ( \"one\" , 1 ) ; original . put ( \"two\" , 2 ) ; original . put ( \"three\" , 3 ) ; ImmutableSortedMap < String , Integer > copy = ImmutableSortedMap . copyOf ( original ) ; assertMapEquals ( copy , \"one\" , 1 , \"three\" , 3 , \"two\" , 2 ) ; assertSame ( copy , ImmutableSortedMap . copyOf ( copy ) ) ; assertSame ( Ordering . natural ( ) , copy . comparator ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testComparators ( ) { TreeMultimap < String , Integer > multimap = TreeMultimap . create ( ) ; assertEquals ( Ordering . natural ( ) , multimap . keyComparator ( ) ) ; assertEquals ( Ordering . natural ( ) , multimap . valueComparator ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private void checkConsistentHashCorrectness ( long hashCode ) { int last = 0 ; for ( int shards = 1 ; shards < = 100000 ; shards + + ) { int b = Hashing . consistentHash ( hashCode , shards ) ; if ( b ! = last ) { assertEquals ( shards - 1 , b ) ; last = b ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected void verify ( List < String > elements ) { assertEquals ( new HashSet < > ( elements ) , multimap . keySet ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public long getLongLittleEndian ( byte[] source , int offset ) { return Longs . fromBytes ( source[offset + 7] , source[offset + 6] , source[offset + 5] , source[offset + 4] , source[offset + 3] , source[offset + 2] , source[offset + 1] , source[offset] ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static Escaper nullEscaper ( ) { return NULL_ESCAPER ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean enclosesAll ( RangeSet < C > other ) { return enclosesAll ( other . asRanges ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Test testsForArrayList ( ) { return ListTestSuiteBuilder . using ( new TestStringListGenerator ( ) { @Override public List < String > create ( String[] elements ) { return new ArrayList < > ( MinimalCollection . of ( elements ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static final UnicodeEscaper NOP_ESCAPER = new UnicodeEscaper ( ) { @Override protected char @Nullable [] escape ( int c ) { return null ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEmptyRangeSubMultisetSupportingAdd ( SortedMultiset < E > multiset ) { for ( Entry < E > entry : asList ( a , b , c ) ) { expectAddFailure ( multiset , entry ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCeiling ( ) { resetWithHole ( ) ; assertEquals ( a , navigableMap . ceilingEntry ( a . getKey ( ) ) ) ; assertEquals ( a . getKey ( ) , navigableMap . ceilingKey ( a . getKey ( ) ) ) ; assertEquals ( c , navigableMap . ceilingEntry ( b . getKey ( ) ) ) ; assertEquals ( c . getKey ( ) , navigableMap . ceilingKey ( b . getKey ( ) ) ) ; assertEquals ( c , navigableMap . ceilingEntry ( c . getKey ( ) ) ) ; assertEquals ( c . getKey ( ) , navigableMap . ceilingKey ( c . getKey ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCheckArgument_simple_failure ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > checkArgument ( false ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static long saturatedCast ( BigInteger big ) { if ( big . compareTo ( MAX_LONG ) > 0 ) { return Long . MAX_VALUE ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < T > T checkNotNull ( @Nullable T reference , String errorMessageTemplate , char p1 , @Nullable Object p2 ) { if ( reference = = null ) { throw new NullPointerException ( Platform . lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void trimToSize ( ) { for ( Collection < V > collection : backingMap ( ) . values ( ) ) { ArrayList < V > arrayList = ( ArrayList < V > ) collection ; arrayList . trimToSize ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected NavigableSet < E > delegate ( ) { return ( NavigableSet < E > ) super . delegate ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testIterationOrdering ( ) { List < E > iteratorElements = new ArrayList < > ( ) ; for ( E element : collection ) { / / uses iterator ( ) iteratorElements . add ( element ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void finalizeReferent ( ) { finalizeReferentCalled = true ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSubArray ( ) { ImmutableIntArray iia0 = ImmutableIntArray . of ( ) ; ImmutableIntArray iia1 = ImmutableIntArray . of ( 5 ) ; ImmutableIntArray iia3 = ImmutableIntArray . of ( 5 , 25 , 125 ) ; assertThat ( iia0 . subArray ( 0 , 0 ) ) . isSameInstanceAs ( ImmutableIntArray . of ( ) ) ; assertThat ( iia1 . subArray ( 0 , 0 ) ) . isSameInstanceAs ( ImmutableIntArray . of ( ) ) ; assertThat ( iia1 . subArray ( 1 , 1 ) ) . isSameInstanceAs ( ImmutableIntArray . of ( ) ) ; assertThat ( iia1 . subArray ( 0 , 1 ) . asList ( ) ) . containsExactly ( 5 ) ; assertThat ( iia3 . subArray ( 0 , 2 ) . asList ( ) ) . containsExactly ( 5 , 25 ) . inOrder ( ) ; assertThat ( iia3 . subArray ( 1 , 3 ) . asList ( ) ) . containsExactly ( 25 , 125 ) . inOrder ( ) ; assertThrows ( IndexOutOfBoundsException . class , ( ) - > iia3 . subArray ( - 1 , 1 ) ) ; assertThrows ( IndexOutOfBoundsException . class , ( ) - > iia3 . subArray ( 1 , 4 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Cache < String , Boolean > delegate ( ) { return mock ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected void verify ( List < Integer > elements ) { assertEquals ( elements , new ArrayList < > ( multimap . values ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean equals ( @Nullable Object obj ) { if ( obj instanceof SameObjectInstance ) { SameObjectInstance that = ( SameObjectInstance ) obj ; return s = = that . s ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < T extends @Nullable Object > boolean all ( Iterator < T > iterator , Predicate < ? super T > predicate ) { checkNotNull ( predicate ) ; while ( iterator . hasNext ( ) ) { T element = iterator . next ( ) ; if ( ! predicate . apply ( element ) ) { return false ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int hashCode ( ) { return lowerBound . hashCode ( ) * 31 + upperBound . hashCode ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean remove ( @Nullable Object key ) { int count = 0 ; Collection < V > collection = map ( ) . remove ( key ) ; if ( collection ! = null ) { count = collection . size ( ) ; collection . clear ( ) ; totalSize - = count ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Map < String , Integer > makeEmptyMap ( ) { throw new UnsupportedOperationException ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testJavaOptional ( ) { FreshValueGenerator generator = new FreshValueGenerator ( ) ; assertEquals ( Optional . empty ( ) , generator . generateFresh ( new TypeToken < Optional < String > > ( ) {",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public double addAndGet ( int i , double delta ) { while ( true ) { long current = longs . get ( i ) ; double currentVal = longBitsToDouble ( current ) ; double nextVal = currentVal + delta ; long next = doubleToRawLongBits ( nextVal ) ; if ( longs . compareAndSet ( i , current , next ) ) { return nextVal ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < T extends @Nullable Object > FluentIterable < T > concat ( Iterable < ? extends T > a , Iterable < ? extends T > b ) { return concatNoDefensiveCopy ( a , b ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Iterable < E > order ( List < E > insertionOrder ) { return delegate . order ( insertionOrder ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void removalListener ( ) { int[] stats = new int[4] ; RemovalListener < Integer , Integer > countingListener = new RemovalListener < Integer , Integer > ( ) { @Override public void onRemoval ( RemovalNotification < Integer , Integer > notification ) { switch ( notification . getCause ( ) ) { case EXPIRED: stats[0] + + ; break ; case EXPLICIT: stats[1] + + ; break ; case REPLACED: stats[2] + + ; break ; case SIZE: stats[3] + + ; break ; default: throw new IllegalStateException ( \"No collected exceptions in GWT CacheBuilder . \" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testGetUnchecked_executionExceptionChecked ( ) { UncheckedExecutionException expected = assertThrows ( UncheckedExecutionException . class , ( ) - > getUnchecked ( FAILED_FUTURE_CHECKED_EXCEPTION ) ) ; assertThat ( expected ) . hasCauseThat ( ) . isEqualTo ( CHECKED_EXCEPTION ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEntrySet_remove ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { cache . getUnchecked ( 1 ) ; cache . getUnchecked ( 2 ) ; Set < Entry < Object , Object > > entrySet = cache . asMap ( ) . entrySet ( ) ; / / We don't know whether these are still in the cache , so we can't assert on the return / / values of these removes , but the cache should be empty after the removes , regardless . entrySet . remove ( entryOf ( 1 , 1 ) ) ; entrySet . remove ( entryOf ( 2 , 2 ) ) ; assertThat ( entrySet . remove ( null ) ) . isFalse ( ) ; assertThat ( entrySet . remove ( entryOf ( 1 , 1 ) ) ) . isFalse ( ) ; assertThat ( entrySet . remove ( entryOf ( 6 , 6 ) ) ) . isFalse ( ) ; assertThat ( entrySet . removeAll ( asList ( null , entryOf ( 1 , 1 ) , entryOf ( 15 , 15 ) ) ) ) . isFalse ( ) ; assertThat ( entrySet . retainAll ( asList ( null , entryOf ( 1 , 1 ) , entryOf ( 15 , 15 ) ) ) ) . isFalse ( ) ; checkEmpty ( entrySet ) ; checkEmpty ( cache ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Network < N , EndpointPair < N > > asNetwork ( ) { return new AbstractNetwork < N , EndpointPair < N > > ( ) { @Override public Set < N > nodes ( ) { return AbstractBaseGraph . this . nodes ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testUnexpectedException ( ) { IteratorTester < Integer > tester = new IteratorTester < Integer > ( 1 , MODIFIABLE , newArrayList ( 1 ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { @Override protected Iterator < Integer > newTargetIterator ( ) { return new ThrowingIterator < > ( new IllegalStateException ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean contains ( @Nullable Object o ) { if ( o = = null ) { return false ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static String join ( String separator , double . . . array ) { checkNotNull ( separator ) ; if ( array . length = = 0 ) { return \"\" ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCopyOf_collection_nonempty ( ) { List < Integer > list = Arrays . asList ( 0 , 1 , 3 ) ; ImmutableIntArray iia = ImmutableIntArray . copyOf ( list ) ; list . set ( 2 , 2 ) ; assertThat ( iia . asList ( ) ) . containsExactly ( 0 , 1 , 3 ) . inOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static HashFunction sha1 ( ) { return Sha1Holder . SHA_1 ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void oneNullableArg ( @Nullable String s ) {",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testLowerUnderscoreToLowerHyphen ( ) { assertThat ( LOWER_UNDERSCORE . to ( LOWER_HYPHEN , \"foo\" ) ) . isEqualTo ( \"foo\" ) ; assertThat ( LOWER_UNDERSCORE . to ( LOWER_HYPHEN , \"foo_bar\" ) ) . isEqualTo ( \"foo - bar\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ImmutableSet < ClassInfo > getTopLevelClassesRecursive ( String packageName ) { checkNotNull ( packageName ) ; String packagePrefix = packageName + ' . ' ; ImmutableSet . Builder < ClassInfo > builder = ImmutableSet . builder ( ) ; for ( ClassInfo classInfo : getTopLevelClasses ( ) ) { if ( classInfo . getName ( ) . startsWith ( packagePrefix ) ) { builder . add ( classInfo ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testMedian_compute_doubleCollection ( ) { assertThat ( median ( ) . compute ( SIXTEEN_SQUARES_DOUBLES ) ) . isWithin ( ALLOWED_ERROR ) . of ( SIXTEEN_SQUARES_MEDIAN ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static CharSource asCharSource ( Path path , Charset charset , OpenOption . . . options ) { return asByteSource ( path , options ) . asCharSource ( charset ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testPermutationSetEmpty ( ) { Collection < List < Integer > > permutationSet = Collections2 . permutations ( Collections . < Integer > emptyList ( ) ) ; assertEquals ( 1 , permutationSet . size ( ) ) ; assertTrue ( permutationSet . contains ( Collections . < Integer > emptyList ( ) ) ) ; Iterator < List < Integer > > permutations = permutationSet . iterator ( ) ; assertNextPermutation ( Collections . < Integer > emptyList ( ) , permutations ) ; assertNoMorePermutations ( permutations ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Test testsForSingletonList ( ) { return ListTestSuiteBuilder . using ( new TestStringListGenerator ( ) { @Override public List < String > create ( String[] elements ) { return singletonList ( elements[0] ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRemove ( ) { create ( ) . remove ( null ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean offer ( E o ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . offer ( o ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSingletonMapLast ( ) { assertEquals ( a , navigableMap . lastEntry ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Spliterator < K > spliterator ( ) { return map ( ) . keySet ( ) . spliterator ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testNullIsPassedThrough ( ) { Converter < String , String > nullsArePassed = sillyConverter ( false ) ; assertEquals ( \"forward\" , nullsArePassed . convert ( \"foo\" ) ) ; assertEquals ( \"forward\" , nullsArePassed . convert ( null ) ) ; assertEquals ( \"backward\" , nullsArePassed . reverse ( ) . convert ( \"foo\" ) ) ; assertEquals ( \"backward\" , nullsArePassed . reverse ( ) . convert ( null ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean wasStreamOpened ( ) { return outputStreamOpened ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean isEmpty ( ) { throw new UnsupportedOperationException ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testOrderedEntries ( ) { TreeMultimap < @Nullable String , @Nullable Integer > multimap = createPopulate ( ) ; assertThat ( multimap . entries ( ) ) . containsExactly ( Maps . < @Nullable String , Integer > immutableEntry ( null , 7 ) , Maps . < @Nullable String , Integer > immutableEntry ( null , 3 ) , Maps . < @Nullable String , Integer > immutableEntry ( null , 1 ) , Maps . < String , @Nullable Integer > immutableEntry ( \"tree\" , null ) , immutableEntry ( \"tree\" , 0 ) , immutableEntry ( \"google\" , 6 ) , immutableEntry ( \"google\" , 2 ) ) . inOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public SortedSet < K > tailSet ( @ParametricNullness K fromElement ) { return new SortedKeySet < > ( map ( ) . tailMap ( fromElement ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSqrtZeroAlwaysZero ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { assertEquals ( 0 , IntMath . sqrt ( 0 , mode ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static void checkState ( boolean expression , String errorMessageTemplate , int p1 , char p2 ) { if ( ! expression ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Iterator < String > newTargetIterator ( ) { return Lists . asList ( \"foo\" , \"bar\" , new String[] { \"baz\"",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static BigInteger sqrt ( BigInteger x , RoundingMode mode ) { checkNonNegative ( \"x\" , x ) ; if ( fitsInLong ( x ) ) { return BigInteger . valueOf ( LongMath . sqrt ( x . longValue ( ) , mode ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static int log2 ( int x , RoundingMode mode ) { checkPositive ( \"x\" , x ) ; switch ( mode ) { case UNNECESSARY: checkRoundingUnnecessary ( isPowerOfTwo ( x ) ) ; / / fall through case DOWN: case FLOOR: return ( Integer . SIZE - 1 ) - Integer . numberOfLeadingZeros ( x ) ; case UP: case CEILING: return Integer . SIZE - Integer . numberOfLeadingZeros ( x - 1 ) ; case HALF_DOWN: case HALF_UP: case HALF_EVEN: / / Since sqrt ( 2 ) is irrational , log2 ( x ) - logFloor cannot be exactly 0 . 5 int leadingZeros = Integer . numberOfLeadingZeros ( x ) ; int cmp = MAX_POWER_OF_SQRT2_UNSIGNED > > > leadingZeros ; / / floor ( 2^ ( logFloor + 0 . 5 ) ) int logFloor = ( Integer . SIZE - 1 ) - leadingZeros ; return logFloor + lessThanBranchFree ( cmp , x ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int indexOf ( @Nullable Object o ) { refreshIfEmpty ( ) ; return getListDelegate ( ) . indexOf ( o ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testContainsAll_sameType ( ) { Collection < String > c = of ( \"a\" , \"b\" , \"c\" ) ; assertFalse ( c . containsAll ( of ( \"a\" , \"b\" , \"c\" , \"d\" ) ) ) ; assertFalse ( c . containsAll ( of ( \"a\" , \"d\" ) ) ) ; assertTrue ( c . containsAll ( of ( \"a\" , \"c\" ) ) ) ; assertTrue ( c . containsAll ( of ( \"a\" , \"b\" , \"c\" ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void eat ( Comparable < ? > food ) { compEvents . add ( food ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean apply ( @Nullable Object o ) { return target . equals ( o ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testMod ( ) { for ( int a : TEST_INTS ) { for ( int b : TEST_INTS ) { if ( b ! = 0 ) { UnsignedInteger aUnsigned = UnsignedInteger . fromIntBits ( a ) ; UnsignedInteger bUnsigned = UnsignedInteger . fromIntBits ( b ) ; int expected = aUnsigned . bigIntegerValue ( ) . mod ( bUnsigned . bigIntegerValue ( ) ) . intValue ( ) ; UnsignedInteger unsignedRem = aUnsigned . mod ( bUnsigned ) ; assertThat ( unsignedRem . intValue ( ) ) . isEqualTo ( expected ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E extends @Nullable Object > Collection < E > filter ( Collection < E > unfiltered , Predicate < ? super E > predicate ) { if ( unfiltered instanceof FilteredCollection ) { / / Support clear ( ) , removeAll ( ) , and retainAll ( ) when filtering a filtered / / collection . return ( ( FilteredCollection < E > ) unfiltered ) . createCombined ( predicate ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Iterator < E > descendingIterator ( ) { return descendingSet ( ) . iterator ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testUnmodifiableIterableShortCircuit ( ) { List < String > list = newArrayList ( \"a\" , \"b\" , \"c\" ) ; Iterable < String > iterable = Iterables . unmodifiableIterable ( list ) ; Iterable < String > iterable2 = Iterables . unmodifiableIterable ( iterable ) ; assertSame ( iterable , iterable2 ) ; ImmutableList < String > immutableList = ImmutableList . of ( \"a\" , \"b\" , \"c\" ) ; assertSame ( immutableList , Iterables . unmodifiableIterable ( immutableList ) ) ; assertSame ( immutableList , Iterables . unmodifiableIterable ( ( List < String > ) immutableList ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static < K , V > SortedMap < K , V > newModifiableDelegate ( Comparator < ? super K > comparator ) { return newTreeMap ( nullAccepting ( comparator ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCount_elementPresent ( ) { int COUNT = 12 ; when ( backingMap . get ( KEY ) ) . thenReturn ( new AtomicInteger ( COUNT ) ) ; assertEquals ( COUNT , multiset . count ( KEY ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean equals ( @Nullable Object other ) { if ( other instanceof StandardBaseEncoding ) { StandardBaseEncoding that = ( StandardBaseEncoding ) other ; return this . alphabet . equals ( that . alphabet ) & & Objects . equals ( this . paddingChar , that . paddingChar ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < T > T checkNotNull ( @Nullable T reference , @Nullable Object errorMessage ) { if ( reference = = null ) { throw new NullPointerException ( Platform . stringValueOf ( errorMessage ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { StringBuilder builder = new StringBuilder ( size ( ) * 12 ) ; builder . append ( '[' ) . append ( array[start] ) ; for ( int i = start + 1 ; i < end ; i + + ) { builder . append ( \" , \" ) . append ( array[i] ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testGet_misc ( ) { assertThat ( ArbitraryInstances . get ( CharMatcher . class ) ) . isNotNull ( ) ; assertThat ( ArbitraryInstances . get ( Currency . class ) . getCurrencyCode ( ) ) . isNotNull ( ) ; assertThat ( ArbitraryInstances . get ( Locale . class ) ) . isNotNull ( ) ; assertThat ( ArbitraryInstances . get ( Joiner . class ) . join ( ImmutableList . of ( \"a\" ) ) ) . isNotNull ( ) ; assertThat ( ArbitraryInstances . get ( Splitter . class ) . split ( \"a , b\" ) ) . isNotNull ( ) ; assertThat ( ArbitraryInstances . get ( com . google . common . base . Optional . class ) ) . isAbsent ( ) ; ArbitraryInstances . get ( Stopwatch . class ) . start ( ) ; assertThat ( ArbitraryInstances . get ( Ticker . class ) ) . isNotNull ( ) ; assertFreshInstanceReturned ( Random . class ) ; assertEquals ( ArbitraryInstances . get ( Random . class ) . nextInt ( ) , ArbitraryInstances . get ( Random . class ) . nextInt ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testDrainValueReferenceQueueOnRead ( ) { for ( MapMaker maker : allWeakValueStrengthMakers ( ) ) { MapMakerInternalMap < Object , Object , ? , ? > map = makeMap ( maker . concurrencyLevel ( 1 ) ) ; if ( maker . getValueStrength ( ) = = Strength . WEAK ) { Segment < Object , Object , ? , ? > segment = map . segments[0] ; Object keyOne = new Object ( ) ; int hashOne = map . hash ( keyOne ) ; Object valueOne = new Object ( ) ; Object keyTwo = new Object ( ) ; map . put ( keyOne , valueOne ) ; WeakValueEntry < Object , Object , ? > entry = ( WeakValueEntry < Object , Object , ? > ) segment . getEntry ( keyOne , hashOne ) ; WeakValueReference < Object , Object , ? > valueReference = entry . getValueReference ( ) ; @SuppressWarnings ( \"unchecked\" ) Reference < Object > reference = ( Reference < Object > ) valueReference ; reference . enqueue ( ) ; for ( int i = 0 ; i < SMALL_MAX_SIZE ; i + + ) { Object unused = map . get ( keyTwo ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static @Nullable Object bad ( ) { return null ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static InputStream newTestStream ( int n ) { return new ByteArrayInputStream ( newPreFilledByteArray ( n ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSampleVariance ( ) { assertThrows ( IllegalStateException . class , ( ) - > emptyAccumulator . sampleVariance ( ) ) ; assertThrows ( IllegalStateException . class , ( ) - > emptyAccumulatorByAddAllEmptyIterable . sampleVariance ( ) ) ; assertThrows ( IllegalStateException . class , ( ) - > emptyAccumulatorByAddAllEmptyStats . sampleVariance ( ) ) ; assertThrows ( IllegalStateException . class , ( ) - > oneValueAccumulator . sampleVariance ( ) ) ; assertThrows ( IllegalStateException . class , ( ) - > oneValueAccumulatorByAddAllEmptyStats . sampleVariance ( ) ) ; assertThat ( twoValuesAccumulator . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS ) ; assertThat ( twoValuesAccumulatorByAddAllStats . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS ) ; assertThat ( manyValuesAccumulatorByAddAllIterable . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - 1 ) ) ; assertThat ( manyValuesAccumulatorByAddAllIterator . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - 1 ) ) ; assertThat ( manyValuesAccumulatorByAddAllVarargs . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - 1 ) ) ; assertThat ( manyValuesAccumulatorByRepeatedAdd . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - 1 ) ) ; assertThat ( manyValuesAccumulatorByAddAndAddAll . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - 1 ) ) ; assertThat ( manyValuesAccumulatorByAddAllStats . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - 1 ) ) ; assertThat ( manyValuesAccumulatorByAddAllStatsAccumulator . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - 1 ) ) ; assertThat ( integerManyValuesAccumulatorByAddAllIterable . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS ) . of ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( INTEGER_MANY_VALUES_COUNT - 1 ) ) ; assertThat ( longManyValuesAccumulatorByAddAllIterator . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS ) . of ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( LONG_MANY_VALUES_COUNT - 1 ) ) ; assertThat ( longManyValuesAccumulatorByAddAllVarargs . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS ) . of ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( LONG_MANY_VALUES_COUNT - 1 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void write ( byte[] b , int off , int len ) { try { output . write ( b , off , len ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Set < String > create ( String[] elements ) { return symmetricDifference ( newHashSet ( elements[0] , elements[1] ) , newHashSet ( elements[2] ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E extends Comparable < ? super E > > ImmutableList < E > sortedCopyOf ( Iterable < ? extends E > elements ) { Comparable < ? > [] array = Iterables . toArray ( elements , new Comparable < ? > [0] ) ; checkElementsNotNull ( ( Object[] ) array ) ; Arrays . sort ( array ) ; return asImmutableList ( array ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSegmentPutIfAbsent ( ) { LocalCache < Object , Object > map = makeLocalCache ( createCacheBuilder ( ) . concurrencyLevel ( 1 ) . expireAfterAccess ( 99999 , SECONDS ) ) ; Segment < Object , Object > segment = map . segments[0] ; / / TODO ( fry ) : check recency ordering Object key = new Object ( ) ; int hash = map . hash ( key ) ; Object oldValue = new Object ( ) ; Object newValue = new Object ( ) ; / / no entry assertThat ( segment . count ) . isEqualTo ( 0 ) ; assertThat ( segment . put ( key , hash , oldValue , true ) ) . isNull ( ) ; assertThat ( segment . count ) . isEqualTo ( 1 ) ; / / same key assertThat ( segment . put ( key , hash , newValue , true ) ) . isSameInstanceAs ( oldValue ) ; assertThat ( segment . count ) . isEqualTo ( 1 ) ; assertThat ( segment . get ( key , hash ) ) . isSameInstanceAs ( oldValue ) ; / / cleared ReferenceEntry < Object , Object > entry = segment . getEntry ( key , hash ) ; DummyValueReference < Object , Object > oldValueRef = DummyValueReference . create ( oldValue ) ; entry . setValueReference ( oldValueRef ) ; assertThat ( segment . get ( key , hash ) ) . isSameInstanceAs ( oldValue ) ; oldValueRef . clear ( ) ; assertThat ( segment . put ( key , hash , newValue , true ) ) . isNull ( ) ; assertThat ( segment . count ) . isEqualTo ( 1 ) ; assertThat ( segment . get ( key , hash ) ) . isSameInstanceAs ( newValue ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable ReferenceEntry < Object , Object > getNext ( ) { return null ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSubList_subListAddAtIndexAffectsOriginalLargeList ( ) { List < E > subList = getList ( ) . subList ( 2 , 3 ) ; subList . add ( 0 , e3 ( ) ) ; expectAdded ( 2 , e3 ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected boolean standardRemoveAll ( Collection < ? > collection ) { return Sets . removeAllImpl ( this , checkNotNull ( collection ) ) ; / / for GWT",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBuilderAddAllIterator ( ) { Iterator < String > iterator = asList ( \"a\" , \"b\" , \"a\" , \"c\" ) . iterator ( ) ; ImmutableMultiset < String > multiset = new ImmutableMultiset . Builder < String > ( ) . addAll ( iterator ) . build ( ) ; assertEquals ( HashMultiset . create ( asList ( \"a\" , \"b\" , \"a\" , \"c\" ) ) , multiset ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Spliterator . OfDouble spliterator ( ) { return parent . spliterator ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public MapGenerator ( OneSizeTestContainerGenerator < BiMap < K , V > , Entry < K , V > > oneSizeTestContainerGenerator ) { this . generator = oneSizeTestContainerGenerator ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { return \"Longs . stringConverter ( ) \" ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Collection < Method > suppressForPriorityBlockingQueue ( ) { return emptySet ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ImmutableSortedMultiset < E > build ( ) { dedupAndCoalesceAndDeleteEmpty ( ) ; if ( length = = 0 ) { return emptyMultiset ( comparator ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCreation_sevenElements ( ) { Set < String > set = of ( \"a\" , \"b\" , \"c\" , \"d\" , \"e\" , \"f\" , \"g\" ) ; assertEquals ( newHashSet ( \"a\" , \"b\" , \"c\" , \"d\" , \"e\" , \"f\" , \"g\" ) , set ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public < E extends T > List < E > sortedCopy ( Iterable < E > elements ) { @SuppressWarnings ( \"unchecked\" ) / / does not escape , and contains only E's E[] array = ( E[] ) Iterables . toArray ( elements ) ; sort ( array , this ) ; return new ArrayList < > ( asList ( array ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEmptySerialization ( ) { Multimap < String , Integer > multimap = ImmutableSetMultimap . of ( ) ; assertSame ( multimap , SerializableTester . reserialize ( multimap ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRemove_unsupportedNotPresent ( ) { try { assertFalse ( \"remove ( notPresent ) should return false or throw UnsupportedOperationException\" , collection . remove ( e3 ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testAsListEmpty ( ) { assertThat ( Shorts . asList ( EMPTY ) ) . isSameInstanceAs ( Collections . emptyList ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCanonical ( ) { assertEquals ( Range . closedOpen ( 1 , 5 ) , Range . closed ( 1 , 4 ) . canonical ( integers ( ) ) ) ; assertEquals ( Range . closedOpen ( 1 , 5 ) , Range . open ( 0 , 5 ) . canonical ( integers ( ) ) ) ; assertEquals ( Range . closedOpen ( 1 , 5 ) , Range . closedOpen ( 1 , 5 ) . canonical ( integers ( ) ) ) ; assertEquals ( Range . closedOpen ( 1 , 5 ) , Range . openClosed ( 0 , 4 ) . canonical ( integers ( ) ) ) ; assertEquals ( Range . closedOpen ( Integer . MIN_VALUE , 0 ) , Range . closedOpen ( Integer . MIN_VALUE , 0 ) . canonical ( integers ( ) ) ) ; assertEquals ( Range . closedOpen ( Integer . MIN_VALUE , 0 ) , Range . lessThan ( 0 ) . canonical ( integers ( ) ) ) ; assertEquals ( Range . closedOpen ( Integer . MIN_VALUE , 1 ) , Range . atMost ( 0 ) . canonical ( integers ( ) ) ) ; assertEquals ( Range . atLeast ( 0 ) , Range . atLeast ( 0 ) . canonical ( integers ( ) ) ) ; assertEquals ( Range . atLeast ( 1 ) , Range . greaterThan ( 0 ) . canonical ( integers ( ) ) ) ; assertEquals ( Range . atLeast ( Integer . MIN_VALUE ) , Range . < Integer > all ( ) . canonical ( integers ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testIsWellFormed_4BytesSamples ( ) { / / Valid 4 byte . assertWellFormed ( 0xF0 , 0xA4 , 0xAD , 0xA2 ) ; / / Bad trailing bytes assertNotWellFormed ( 0xF0 , 0xA4 , 0xAD , 0x7F ) ; assertNotWellFormed ( 0xF0 , 0xA4 , 0xAD , 0xC0 ) ; / / Special cases for byte2 assertNotWellFormed ( 0xF0 , 0x8F , 0xAD , 0xA2 ) ; assertNotWellFormed ( 0xF4 , 0x90 , 0xAD , 0xA2 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable V get ( @Nullable Object rowKey , @Nullable Object columnKey ) { synchronized ( mutex ) { return delegate ( ) . get ( rowKey , columnKey ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSkip_pastEndList ( ) { Collection < String > list = Lists . newArrayList ( \"a\" , \"b\" ) ; assertEquals ( emptyList ( ) , Lists . newArrayList ( FluentIterable . from ( list ) . skip ( 20 ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private StrongKeyDummyValueEntry ( K key , int hash ) { super ( key , hash ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCreation_fiveElements ( ) { Multiset < String > multiset = ImmutableMultiset . of ( \"a\" , \"b\" , \"c\" , \"d\" , \"e\" ) ; assertEquals ( HashMultiset . create ( asList ( \"a\" , \"b\" , \"c\" , \"d\" , \"e\" ) ) , multiset ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public MonitorBasedPriorityBlockingQueue ( ) { q = new PriorityQueue < E > ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testGetGenericSuperclass_wildcard_lowerBounded ( ) { assertEquals ( TypeToken . of ( Object . class ) , TypeToken . of ( Types . supertypeOf ( String . class ) ) . getGenericSuperclass ( ) ) ; assertEquals ( new TypeToken < Object > ( ) {",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final boolean compareAndSet ( double expect , double update ) { return value . compareAndSet ( doubleToRawLongBits ( expect ) , doubleToRawLongBits ( update ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Entry < V , K > get ( int index ) { Entry < K , V > entry = entries . get ( index ) ; return immutableEntry ( entry . getValue ( ) , entry . getKey ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public E set ( int index , E element ) { synchronized ( mutex ) { return delegate ( ) . set ( index , element ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean isCancelled ( ) { return false ; / / BAD ! !",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public SafeTreeMap ( Map < ? extends K , ? extends V > map ) { this ( new TreeMap < K , V > ( map ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private AsCharSink ( Charset charset ) { this . charset = checkNotNull ( charset ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int size ( ) { return length ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final boolean isSupertypeOf ( Type type ) { return of ( type ) . isSubtypeOf ( getType ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEnsureCapacity ( ) { assertThat ( Booleans . ensureCapacity ( EMPTY , 0 , 1 ) ) . isSameInstanceAs ( EMPTY ) ; assertThat ( Booleans . ensureCapacity ( ARRAY_FALSE , 0 , 1 ) ) . isSameInstanceAs ( ARRAY_FALSE ) ; assertThat ( Booleans . ensureCapacity ( ARRAY_FALSE , 1 , 1 ) ) . isSameInstanceAs ( ARRAY_FALSE ) ; assertThat ( Booleans . ensureCapacity ( new boolean[] { true",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testLessThanBranchFree ( ) { for ( long x : ALL_LONG_CANDIDATES ) { for ( long y : ALL_LONG_CANDIDATES ) { BigInteger difference = BigInteger . valueOf ( x ) . subtract ( BigInteger . valueOf ( y ) ) ; if ( fitsInLong ( difference ) ) { int expected = ( x < y ) ? 1 : 0 ; int actual = LongMath . lessThanBranchFree ( x , y ) ; assertEquals ( expected , actual ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static void staticOneArgCorrectlyThrowsNpe ( String s ) { checkNotNull ( s ) ; / / expect NPE here on null",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public < T extends @Nullable Object > ComparisonChain compare ( @ParametricNullness T left , @ParametricNullness T right , Comparator < T > comparator ) { return this ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E extends @Nullable Object > MinimalSet < E > from ( Collection < ? extends E > contents ) { return ofClassAndContents ( Object . class , ( E[] ) new Object[0] , contents ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRowNull ( ) { table = create ( \"foo\" , 1 , 'a' , \"bar\" , 1 , 'b' , \"foo\" , 3 , 'c' ) ; assertThrows ( NullPointerException . class , ( ) - > table . row ( null ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSetCount_threeToOne_supported ( ) { initThreeCopies ( ) ; assertSetCount ( e0 ( ) , 1 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void running ( ) { ServiceManagerState state = this . state . get ( ) ; if ( state ! = null ) { state . transitionService ( service , STARTING , RUNNING ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean hasNext ( ) { return next ! = null ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean add ( E e ) { return super . add ( e ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCopyOfDense ( ) { Table < Character , Integer , String > table = TreeBasedTable . create ( ) ; table . put ( 'c' , 3 , \"foo\" ) ; table . put ( 'c' , 2 , \"bar\" ) ; table . put ( 'c' , 1 , \"baz\" ) ; table . put ( 'b' , 3 , \"cat\" ) ; table . put ( 'b' , 1 , \"dog\" ) ; table . put ( 'a' , 3 , \"foo\" ) ; table . put ( 'a' , 2 , \"bar\" ) ; table . put ( 'a' , 1 , \"baz\" ) ; validateTableCopies ( table ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testOf2 ( ) { assertThat ( ImmutableIntArray . of ( 0 , 1 ) . asList ( ) ) . containsExactly ( 0 , 1 ) . inOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Map < Object , Integer > makePopulatedMap ( ) { Colliders colliders = new Colliders ( ) ; return ImmutableMap . of ( colliders . e0 ( ) , 0 , colliders . e1 ( ) , 1 , colliders . e2 ( ) , 2 , colliders . e3 ( ) , 3 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testKeySetRetainAllNullFromEmpty ( ) { Map < K , V > map ; try { map = makeEmptyMap ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ImmutableRangeMap < K , V > build ( ) { sort ( entries , Range . < K > rangeLexOrdering ( ) . onKeys ( ) ) ; ImmutableList . Builder < Range < K > > rangesBuilder = new ImmutableList . Builder < > ( entries . size ( ) ) ; ImmutableList . Builder < V > valuesBuilder = new ImmutableList . Builder < > ( entries . size ( ) ) ; for ( int i = 0 ; i < entries . size ( ) ; i + + ) { Range < K > range = entries . get ( i ) . getKey ( ) ; if ( i > 0 ) { Range < K > prevRange = entries . get ( i - 1 ) . getKey ( ) ; if ( range . isConnected ( prevRange ) & & ! range . intersection ( prevRange ) . isEmpty ( ) ) { throw new IllegalArgumentException ( \"Overlapping ranges: range \" + prevRange + \" overlaps with entry \" + range ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { return \"Ordering . usingToString ( ) \" ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static ImmutableIntArray of ( int e0 ) { return new ImmutableIntArray ( new int[] { e0",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testGetLast_exception ( ) { List < String > list = new ArrayList < > ( ) ; assertThrows ( NoSuchElementException . class , ( ) - > getLast ( list . iterator ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testColumnComparator ( ) { sortedTable = TreeBasedTable . create ( ) ; sortedTable . put ( \"\" , 42 , 'x' ) ; assertSame ( Ordering . natural ( ) , sortedTable . columnComparator ( ) ) ; assertSame ( Ordering . natural ( ) , ( ( SortedMap < Integer , Character > ) sortedTable . rowMap ( ) . values ( ) . iterator ( ) . next ( ) ) . comparator ( ) ) ; sortedTable = TreeBasedTable . create ( Collections . reverseOrder ( ) , Ordering . usingToString ( ) ) ; sortedTable . put ( \"\" , 42 , 'x' ) ; assertSame ( Ordering . usingToString ( ) , sortedTable . columnComparator ( ) ) ; assertSame ( Ordering . usingToString ( ) , ( ( SortedMap < Integer , Character > ) sortedTable . rowMap ( ) . values ( ) . iterator ( ) . next ( ) ) . comparator ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int add ( @ParametricNullness E element , int occurrences ) { checkArgument ( predicate . apply ( element ) , \"Element %s does not match predicate %s\" , element , predicate ) ; return unfiltered . add ( element , occurrences ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Spliterator < E > spliterator ( ) { return delegate . spliterator ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void forTree_breadthFirst_iterableIsLazy ( ) { RequestSavingGraph graph = new RequestSavingGraph ( TREE ) ; Iterable < Character > result = Traverser . forGraph ( graph ) . breadthFirst ( 'h' ) ; assertEqualCharNodes ( Iterables . limit ( result , 2 ) , \"hd\" ) ; assertThat ( graph . requestedNodes ) . containsExactly ( 'h' , 'h' , 'd' ) ; / / Iterate again to see if calculation is done again assertEqualCharNodes ( Iterables . limit ( result , 2 ) , \"hd\" ) ; assertThat ( graph . requestedNodes ) . containsExactly ( 'h' , 'h' , 'h' , 'd' , 'd' ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testReplace ( ) { AtomicLongMap < String > map = AtomicLongMap . create ( ) ; String key = \"key\" ; long newValue = random . nextInt ( MAX_ADDEND ) ; for ( int i = 0 ; i < ITERATIONS ; i + + ) { long before = map . get ( key ) ; assertFalse ( map . replace ( key , before + 1 , newValue + 1 ) ) ; assertFalse ( map . replace ( key , before - 1 , newValue - 1 ) ) ; assertTrue ( map . replace ( key , before , newValue ) ) ; long after = map . get ( key ) ; assertEquals ( newValue , after ) ; newValue + = newValue ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private long getWorstCaseOps ( CallsCounter counter , List < CountsHashCodeAndEquals > haveSameHashes , QueryOp < T > query , Construction < T > pathway ) { T collection = pathway . create ( haveSameHashes ) ; long worstOps = 0 ; for ( Object o : haveSameHashes ) { counter . zero ( ) ; query . apply ( collection , o ) ; worstOps = max ( worstOps , counter . total ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Builder < N > putEdge ( EndpointPair < N > endpoints ) { mutableGraph . putEdge ( endpoints ) ; return this ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCreation_threeElements ( ) { Multiset < String > multiset = ImmutableSortedMultiset . of ( \"a\" , \"b\" , \"c\" ) ; assertEquals ( HashMultiset . create ( asList ( \"a\" , \"b\" , \"c\" ) ) , multiset ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int hashCode ( ) { return delegateList ( ) . hashCode ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public < T extends @Nullable Object > T[] toArray ( T[] a ) { synchronized ( mutex ) { return delegate ( ) . toArray ( a ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int lastIndexOf ( long target ) { for ( int i = end - 1 ; i > = start ; i - - ) { if ( array[i] = = target ) { return i - start ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private TestCloseable ( @Nullable Throwable throwOnClose ) { this . throwOnClose = throwOnClose ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testClear_unsupportedByEmptyCollection ( ) { try { collection . clear ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSeparatorSameAsPadChar ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > base64 ( ) . withSeparator ( \" = \" , 3 ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > base64 ( ) . withPadChar ( '#' ) . withSeparator ( \" ! # ! \" , 3 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean equals ( @Nullable Object obj ) { synchronized ( mutex ) { return delegate ( ) . equals ( obj ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static Inet4Address getCompatIPv4Address ( Inet6Address ip ) { checkArgument ( isCompatIPv4Address ( ip ) , \"Address '%s' is not IPv4 - compatible . \" , toAddrString ( ip ) ) ; return getInet4Address ( Arrays . copyOfRange ( ip . getAddress ( ) , 12 , 16 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < V > get ( @ParametricNullness K key ) { / * * Note that this doesn't return a SortedSet when delegate is a * SortedSetMultiset , unlike ( SortedSet < V > ) super . get ( ) . * / return Collections . unmodifiableSet ( delegate ( ) . get ( key ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEquals ( ) { Table < Integer , Integer , String > table1 = ImmutableTable . of ( 1 , 1 , \"one\" ) ; Table < Integer , Integer , String > table2 = ImmutableTable . of ( 2 , 2 , \"two\" ) ; new EqualsTester ( ) . addEqualityGroup ( table1 , wrap ( table1 ) , wrap ( table1 ) ) . addEqualityGroup ( table2 , wrap ( table2 ) ) . testEquals ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testAllocArraysExpectedSize ( ) { for ( int i = 0 ; i < = CompactHashing . DEFAULT_SIZE ; i + + ) { CompactHashMap < Integer , String > map = CompactHashMap . createWithExpectedSize ( i ) ; assertThat ( map . needsAllocArrays ( ) ) . isTrue ( ) ; assertThat ( map . entries ) . isNull ( ) ; assertThat ( map . keys ) . isNull ( ) ; assertThat ( map . values ) . isNull ( ) ; map . put ( 1 , \"1\" ) ; assertThat ( map . needsAllocArrays ( ) ) . isFalse ( ) ; int expectedSize = max ( 1 , i ) ; assertThat ( map . entries ) . hasLength ( expectedSize ) ; assertThat ( map . keys ) . hasLength ( expectedSize ) ; assertThat ( map . values ) . hasLength ( expectedSize ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testNullPointerExceptions ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicInstanceMethods ( new FakeTicker ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testNewEntry ( ) { for ( CacheBuilder < Object , Object > builder : allEntryTypeMakers ( ) ) { LocalCache < Object , Object > map = makeLocalCache ( builder ) ; Object keyOne = new Object ( ) ; Object valueOne = new Object ( ) ; int hashOne = map . hash ( keyOne ) ; ReferenceEntry < Object , Object > entryOne = map . newEntry ( keyOne , hashOne , null ) ; ValueReference < Object , Object > valueRefOne = map . newValueReference ( entryOne , valueOne , 1 ) ; assertThat ( valueRefOne . get ( ) ) . isSameInstanceAs ( valueOne ) ; entryOne . setValueReference ( valueRefOne ) ; assertThat ( entryOne . getKey ( ) ) . isSameInstanceAs ( keyOne ) ; assertThat ( entryOne . getHash ( ) ) . isEqualTo ( hashOne ) ; assertThat ( entryOne . getNext ( ) ) . isNull ( ) ; assertThat ( entryOne . getValueReference ( ) ) . isSameInstanceAs ( valueRefOne ) ; Object keyTwo = new Object ( ) ; Object valueTwo = new Object ( ) ; int hashTwo = map . hash ( keyTwo ) ; ReferenceEntry < Object , Object > entryTwo = map . newEntry ( keyTwo , hashTwo , entryOne ) ; ValueReference < Object , Object > valueRefTwo = map . newValueReference ( entryTwo , valueTwo , 1 ) ; assertThat ( valueRefTwo . get ( ) ) . isSameInstanceAs ( valueTwo ) ; entryTwo . setValueReference ( valueRefTwo ) ; assertThat ( entryTwo . getKey ( ) ) . isSameInstanceAs ( keyTwo ) ; assertThat ( entryTwo . getHash ( ) ) . isEqualTo ( hashTwo ) ; assertThat ( entryTwo . getNext ( ) ) . isSameInstanceAs ( entryOne ) ; assertThat ( entryTwo . getValueReference ( ) ) . isSameInstanceAs ( valueRefTwo ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final boolean isEmpty ( ) { return ! getDelegate ( ) . iterator ( ) . hasNext ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBuilder_withMutableEntry ( ) { ImmutableMultimap . Builder < String , Integer > builder = new Builder < > ( ) ; StringHolder holder = new StringHolder ( ) ; holder . string = \"one\" ; Entry < String , Integer > entry = new AbstractMapEntry < String , Integer > ( ) { @Override public String getKey ( ) { return holder . string ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testIteratorRemove_unsupported ( ) { Iterator < E > iterator = collection . iterator ( ) ; iterator . next ( ) ; assertThrows ( UnsupportedOperationException . class , iterator::remove ) ; expectUnchanged ( ) ; assertTrue ( collection . contains ( e0 ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void setWriteTime ( long time ) { this . writeTime = time ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void add ( double x , double y ) { / / We extend the recursive expression for the one - variable case at Art of Computer Programming / / vol . 2 , Knuth , 4 . 2 . 2 , ( 16 ) to the two - variable case . We have two value series x_i and y_i . / / We define the arithmetic means X_n = 1 / n \\sum_ { i = 1",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSimplifyRootedDotDots ( ) { assertEquals ( \" / \" , simplifyPath ( \" / . . / . . / . . \" ) ) ; assertEquals ( \" / \" , simplifyPath ( \" / . . / . . / . . / \" ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void clear ( ) { E[] items = this . items ; Monitor monitor = this . monitor ; monitor . enter ( ) ; try { int i = takeIndex ; int k = count ; while ( k - - > 0 ) { items[i] = null ; i = inc ( i ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < Feature < ? super Map > > getImpliedFeatures ( ) { return implied ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Builder addAll ( double[] values ) { ensureRoomFor ( values . length ) ; System . arraycopy ( values , 0 , array , count , values . length ) ; count + = values . length ; return this ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static BigInteger ceilingPowerOfTwo ( BigInteger x ) { return BigInteger . ZERO . setBit ( log2 ( x , CEILING ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean remove ( @Nullable Object obj ) { for ( Entry < C , Map < R , V > > entry : ColumnMap . this . entrySet ( ) ) { if ( entry . getValue ( ) . equals ( obj ) ) { removeColumn ( entry . getKey ( ) ) ; return true ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static Iterable < @Nullable Object > iterable ( @Nullable Object first , @Nullable Object second , @Nullable Object[] rest ) { checkNotNull ( rest ) ; return new AbstractList < @Nullable Object > ( ) { @Override public int size ( ) { return rest . length + 2 ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testFuzzyInfiniteVersusInfiniteWithFiniteTolerance ( ) { for ( double inf : INFINITIES ) { for ( double tolerance : FINITE_TOLERANCE_CANDIDATES ) { assertTrue ( DoubleMath . fuzzyEquals ( inf , inf , tolerance ) ) ; assertFalse ( DoubleMath . fuzzyEquals ( inf , - inf , tolerance ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public SortedSet < E > headSet ( @ParametricNullness E toElement ) { return delegate ( ) . headSet ( toElement ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < K > keySet ( ) { return new KeySet ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean setCount ( @ParametricNullness E element , int oldCount , int newCount ) { synchronized ( mutex ) { return delegate ( ) . setCount ( element , oldCount , newCount ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected MonitorTestCase ( boolean interruptible ) { this . interruptible = interruptible ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testTransformHashCodeSequential ( ) { List < String > list = transform ( SOME_SEQUENTIAL_LIST , SOME_FUNCTION ) ; assertEquals ( SOME_STRING_LIST . hashCode ( ) , list . hashCode ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void writeUTF ( String s ) { try { output . writeUTF ( s ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public BiMap < V , K > inverse ( ) { BiMap < V , K > result = inverse ; return ( result = = null ) ? inverse = new UnmodifiableBiMap < > ( delegate . inverse ( ) , this ) : result ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRemovalListener_setTwice ( ) { RemovalListener < Object , Object > testListener = nullRemovalListener ( ) ; CacheBuilder < Object , Object > builder = CacheBuilder . newBuilder ( ) . removalListener ( testListener ) ; assertThrows ( IllegalStateException . class , ( ) - > builder . removalListener ( testListener ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testAddAllAtIndex_nullSupported ( ) { List < E > containsNull = singletonList ( null ) ; assertTrue ( \"addAll ( n , containsNull ) should return true\" , getList ( ) . addAll ( 0 , containsNull ) ) ; / * * We need ( E ) to force interpretation of null as the single element of a * varargs array , not the array itself * / expectAdded ( 0 , ( E ) null ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testScale_indexes_collection_computeInPlace ( ) { double[] dataset = Doubles . toArray ( SIXTEEN_SQUARES_DOUBLES ) ; assertThat ( Quantiles . scale ( 10 ) . indexes ( ImmutableList . of ( 0 , 10 , 5 , 1 , 8 , 1 ) ) . computeInPlace ( dataset ) ) . comparingValuesUsing ( QUANTILE_CORRESPONDENCE ) . containsExactly ( 0 , SIXTEEN_SQUARES_MIN , 10 , SIXTEEN_SQUARES_MAX , 5 , SIXTEEN_SQUARES_MEDIAN , 1 , SIXTEEN_SQUARES_DECILE_1 , 8 , SIXTEEN_SQUARES_DECILE_8 ) ; assertThat ( dataset ) . usingExactEquality ( ) . containsExactlyElementsIn ( SIXTEEN_SQUARES_DOUBLES ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void copyOf_undirectedGraph ( ) { Graph < Integer > undirectedGraph = buildUndirectedGraph ( ) ; Graph < Integer > copy = copyOf ( undirectedGraph ) ; assertThat ( copy ) . isEqualTo ( undirectedGraph ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCreateCopy ( ) { Table < String , Integer , Character > original = create ( \"foo\" , 1 , 'a' , \"bar\" , 1 , 'b' , \"foo\" , 3 , 'c' ) ; Table < String , Integer , Character > copy = HashBasedTable . create ( original ) ; assertEquals ( original , copy ) ; assertEquals ( ( Character ) 'a' , copy . get ( \"foo\" , 1 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int hashCode ( ) { refreshIfEmpty ( ) ; return delegate . hashCode ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < E > create ( Object . . . elements ) { return ( Set < E > ) super . create ( elements ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected SortedMap < K , V > delegate ( ) { return backingSortedMap ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Multiset < K > create ( Object . . . elements ) { / * * This is nasty and complicated , but it's the only way to make sure keys get mapped to enough * distinct values . * / Entry < ? , ? > [] entries = new Entry < ? , ? > [elements . length] ; Map < K , Iterator < V > > valueIterators = new HashMap < > ( ) ; for ( int i = 0 ; i < elements . length ; i + + ) { @SuppressWarnings ( \"unchecked\" ) / / These come from Entry < K , V > objects somewhere . K key = ( K ) elements[i] ; Iterator < V > valueItr = valueIterators . get ( key ) ; if ( valueItr = = null ) { valueIterators . put ( key , valueItr = sampleValuesIterator ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static < K , V > LocalCache < K , V > makeLocalCache ( CacheBuilder < ? super K , ? super V > builder ) { return new LocalCache < > ( builder , null ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private void insert ( E x ) { items[putIndex] = x ; putIndex = inc ( putIndex ) ; + + count ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public SortedMultiset < E > subMultiset ( E lowerBound , BoundType lowerBoundType , E upperBound , BoundType upperBoundType ) { return delegate ( ) . subMultiset ( lowerBound , lowerBoundType , upperBound , upperBoundType ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static short fromByteArray ( byte[] bytes ) { checkArgument ( bytes . length > = BYTES , \"array too small: %s < %s\" , bytes . length , BYTES ) ; return fromBytes ( bytes[0] , bytes[1] ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testStringConverter_nullConversions ( ) { assertThat ( Ints . stringConverter ( ) . convert ( null ) ) . isNull ( ) ; assertThat ( Ints . stringConverter ( ) . reverse ( ) . convert ( null ) ) . isNull ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int hashCode ( ) { return Objects . hash ( initialCapacity , maximumSize , maximumWeight , concurrencyLevel , keyStrength , valueStrength , recordStats , durationInNanos ( writeExpirationDuration , writeExpirationTimeUnit ) , durationInNanos ( accessExpirationDuration , accessExpirationTimeUnit ) , durationInNanos ( refreshDuration , refreshTimeUnit ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Set < T > delegate ( ) { return backingSet ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected ListExample ( String name , Modifiability modifiability ) { this . name = name ; this . modifiability = modifiability ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable V put ( R rowKey , C columnKey , V value ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . put ( rowKey , columnKey , value ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private SingletonImmutableBiMap ( K key , V value , SingletonImmutableBiMap < V , K > inverse ) { super ( singletonMap ( checkNotNull ( key ) , checkNotNull ( value ) ) ) ; this . singleKey = key ; this . singleValue = value ; this . inverse = inverse ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private < X extends Throwable > AsyncFunction < X , Integer > asyncFunctionReturningOne ( ) { return new AsyncFunction < X , Integer > ( ) { @Override public ListenableFuture < Integer > apply ( X t ) { return immediateFuture ( 1 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testTransformEntrySetContains ( ) { Map < @Nullable String , @Nullable Boolean > underlying = new HashMap < > ( ) ; underlying . put ( \"a\" , null ) ; underlying . put ( \"b\" , true ) ; underlying . put ( null , true ) ; Map < @Nullable String , @Nullable Boolean > map = transformValues ( underlying , new Function < @Nullable Boolean , @Nullable Boolean > ( ) { @Override public @Nullable Boolean apply ( @Nullable Boolean from ) { return ( from = = null ) ? true : null ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCreation_fourElements ( ) { List < String > list = ImmutableList . of ( \"a\" , \"b\" , \"c\" , \"d\" ) ; assertEquals ( Lists . newArrayList ( \"a\" , \"b\" , \"c\" , \"d\" ) , list ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testToTableNullValues ( ) { Collector < Cell < String , String , Integer > , ? , Table < String , String , Integer > > collector = TableCollectors . toTable ( Cell::getRowKey , Cell::getColumnKey , Cell::getValue , ( ) - > { Table < String , String , @Nullable Integer > table = ArrayTable . create ( ImmutableList . of ( \"one\" ) , ImmutableList . of ( \"uno\" ) ) ; return ( Table < String , String , Integer > ) table ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int hashCode ( ) { return hashCode ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSerialization ( ) { assertEquals ( Integer . valueOf ( 5 ) , reserialize ( Suppliers . ofInstance ( 5 ) ) . get ( ) ) ; assertEquals ( Integer . valueOf ( 5 ) , reserialize ( Suppliers . compose ( Functions . identity ( ) , Suppliers . ofInstance ( 5 ) ) ) . get ( ) ) ; assertEquals ( Integer . valueOf ( 5 ) , reserialize ( Suppliers . memoize ( Suppliers . ofInstance ( 5 ) ) ) . get ( ) ) ; assertEquals ( Integer . valueOf ( 5 ) , reserialize ( Suppliers . memoizeWithExpiration ( Suppliers . ofInstance ( 5 ) , 30 , SECONDS ) ) . get ( ) ) ; assertEquals ( Integer . valueOf ( 5 ) , reserialize ( Suppliers . synchronizedSupplier ( Suppliers . ofInstance ( 5 ) ) ) . get ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testPutDuplicateValue ( ) { List < Entry < K , V > > entries = copyToList ( multimap ( ) . entries ( ) ) ; for ( Entry < K , V > entry : entries ) { resetContainer ( ) ; K k = entry . getKey ( ) ; V v = entry . getValue ( ) ; List < V > values = multimap ( ) . get ( k ) ; List < V > expectedValues = copyToList ( values ) ; assertTrue ( multimap ( ) . put ( k , v ) ) ; expectedValues . add ( v ) ; assertGet ( k , expectedValues ) ; assertEquals ( v , values . get ( values . size ( ) - 1 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E extends @Nullable Object > CopyOnWriteArraySet < E > newCopyOnWriteArraySet ( ) { return new CopyOnWriteArraySet < > ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static int factorial ( int n ) { checkNonNegative ( \"n\" , n ) ; return ( n < factorials . length ) ? factorials[n] : Integer . MAX_VALUE ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean test ( Character character ) { return matches ( character ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testTransformWith_poorlyBehavedTransform ( ) { List < String > input = asList ( \"1\" , null , \"3\" ) ; Iterable < Integer > iterable = FluentIterable . from ( input ) . transform ( new IntegerValueOfFunction ( ) ) ; Iterator < Integer > resultIterator = iterable . iterator ( ) ; resultIterator . next ( ) ; assertThrows ( NumberFormatException . class , ( ) - > resultIterator . next ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public E first ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate ( ) . first ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testLastIndexOf ( ) { assertThat ( Chars . lastIndexOf ( EMPTY , ( char ) 1 ) ) . isEqualTo ( - 1 ) ; assertThat ( Chars . lastIndexOf ( ARRAY1 , ( char ) 2 ) ) . isEqualTo ( - 1 ) ; assertThat ( Chars . lastIndexOf ( ARRAY234 , ( char ) 1 ) ) . isEqualTo ( - 1 ) ; assertThat ( Chars . lastIndexOf ( new char[] { ( char ) - 1",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void forTree_depthFirstPostOrder_twoTrees ( ) { Iterable < Character > result = Traverser . forTree ( TWO_TREES ) . depthFirstPostOrder ( 'a' ) ; assertEqualCharNodes ( result , \"ba\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static void checkState ( boolean expression , String errorMessageTemplate , long p1 , int p2 ) { if ( ! expression ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ImmutableMultiset < Object > create ( List < ? > keys ) { ImmutableMultiset . Builder < Object > builder = ImmutableMultiset . builder ( ) ; for ( Object o : keys ) { builder . add ( o ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ElementOrder < N > nodeOrder ( ) { return network . nodeOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Iterator < E > iterator ( ) { return new UnmodifiableIterator < E > ( ) { final ImmutableList < E > elements = inputSet . keySet ( ) . asList ( ) ; int remainingSetBits = mask ; @Override public boolean hasNext ( ) { return remainingSetBits ! = 0 ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void remove ( ) { checkState ( collection ! = null , \"no calls to next ( ) since the last call to remove ( ) \" ) ; delegateIterator . remove ( ) ; totalSize - = collection . size ( ) ; collection . clear ( ) ; collection = null ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testHashCode ( ) { table = ArrayTable . create ( asList ( \"foo\" , \"bar\" ) , asList ( 1 , 3 ) ) ; table . put ( \"foo\" , 1 , 'a' ) ; table . put ( \"bar\" , 1 , 'b' ) ; table . put ( \"foo\" , 3 , 'c' ) ; int expected = Objects . hash ( \"foo\" , 1 , 'a' ) + Objects . hash ( \"bar\" , 1 , 'b' ) + Objects . hash ( \"foo\" , 3 , 'c' ) + Objects . hash ( \"bar\" , 3 , 0 ) ; assertEquals ( expected , table . hashCode ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Chars ( ) { / / elements aren't sorted , to better test SortedSet iteration ordering super ( 'b' , 'a' , 'c' , 'd' , 'e' ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static Joiner on ( String separator ) { return new Joiner ( separator ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCreateWithDuplicates_nullDuplicatesRejected ( ) { E[] array = createArrayWithNullElement ( ) ; array[0] = null ; assertThrows ( IllegalArgumentException . class , ( ) - > collection = getSubjectGenerator ( ) . create ( array ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int hashCode ( ) { return f . hashCode ( ) ^ p . hashCode ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < T extends @Nullable Object > Predicate < T > alwaysFalse ( ) { return ObjectPredicate . ALWAYS_FALSE . withNarrowedType ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public CollectionSize getCollectionSize ( ) { return collectionSize ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public List < Object > apply ( List < Optional < ? > > objs ) { return Lists . transform ( objs , OPTIONAL_TO_NULLABLE ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testPutCoalescingSubmapEmpty ( ) { RangeMap < Integer , Integer > rangeMap = TreeRangeMap . create ( ) ; rangeMap . put ( Range . closedOpen ( 0 , 1 ) , 1 ) ; rangeMap . put ( Range . closedOpen ( 1 , 2 ) , 1 ) ; assertEquals ( ImmutableMap . of ( Range . closedOpen ( 0 , 1 ) , 1 , Range . closedOpen ( 1 , 2 ) , 1 ) , rangeMap . asMapOfRanges ( ) ) ; RangeMap < Integer , Integer > subRangeMap = rangeMap . subRangeMap ( Range . closedOpen ( 0 , 2 ) ) ; subRangeMap . putCoalescing ( Range . closedOpen ( 1 , 1 ) , 1 ) ; / / empty range coalesces connected ranges assertEquals ( ImmutableMap . of ( Range . closedOpen ( 0 , 2 ) , 1 ) , subRangeMap . asMapOfRanges ( ) ) ; assertEquals ( ImmutableMap . of ( Range . closedOpen ( 0 , 2 ) , 1 ) , rangeMap . asMapOfRanges ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSetCountZeroToOneConcurrentWithEntrySetIteration ( ) { Iterator < Entry < E > > iterator = getMultiset ( ) . entrySet ( ) . iterator ( ) ; assertSetCount ( e3 ( ) , 1 ) ; assertThrows ( ConcurrentModificationException . class , iterator::next ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < E > edges ( ) { return delegate ( ) . edges ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected void doStop ( ) { fail ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E extends Comparable < ? > > Builder < E > naturalOrder ( ) { return new Builder < E > ( Ordering . natural ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void nodeOrder_default ( ) { MutableGraph < Integer > graph = GraphBuilder . directed ( ) . build ( ) ; addNodes ( graph ) ; assertThat ( graph . nodeOrder ( ) ) . isEqualTo ( insertion ( ) ) ; assertThat ( graph . nodes ( ) ) . containsExactly ( 3 , 1 , 4 ) . inOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testReplaceEntry_unsupportedAbsentKey ( ) { try { getMap ( ) . replace ( k3 ( ) , v3 ( ) , v4 ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void run ( ) { threadLocalCount . set ( threadLocalCount . get ( ) + 1 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static Scale scale ( int scale ) { return new Scale ( scale ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testConstructor ( ) { for ( double x : VALUES ) { AtomicDouble a = new AtomicDouble ( x ) ; assertBitEquals ( x , a . get ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public double compute ( long . . . dataset ) { return computeInPlace ( longsToDoubles ( dataset ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void run ( ) { CountingRunnable localRunnable = new CountingRunnable ( ) ; while ( ! isInterrupted ( ) ) { executor . execute ( localRunnable ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E extends @Nullable Object > ArrayList < E > newArrayList ( Iterable < ? extends E > elements ) { checkNotNull ( elements ) ; / / for GWT / / Let ArrayList's sizing logic work , if possible return ( elements instanceof Collection ) ? new ArrayList < > ( ( Collection < ? extends E > ) elements ) : newArrayList ( elements . iterator ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testNullPointer ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicConstructors ( MediaType . class ) ; tester . testAllPublicStaticMethods ( MediaType . class ) ; tester . testAllPublicInstanceMethods ( MediaType . parse ( \"text / plain\" ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E > EvictingQueue < E > create ( int maxSize ) { return new EvictingQueue < > ( maxSize ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private . * / public final boolean isPrivate ( ) { return Modifier . isPrivate ( getModifiers ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public long asLong ( ) { return hash ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testDifference_minSize ( ) { assertMinSize ( difference ( emptySet ( ) , emptySet ( ) ) , 0 ) ; assertMinSize ( difference ( setSize ( 2 ) , setSize ( 3 ) ) , 0 ) ; assertMinSize ( difference ( setSize ( 3 ) , setSize ( 2 ) ) , 1 ) ; assertMinSize ( difference ( setSizeRange ( 10 , 20 ) , setSizeRange ( 1 , 2 ) ) , 8 ) ; assertMinSize ( difference ( setSizeRange ( 1 , 2 ) , setSizeRange ( 10 , 20 ) ) , 0 ) ; assertMinSize ( difference ( setSizeRange ( 10 , 20 ) , setSizeRange ( 11 , 12 ) ) , 0 ) ; assertMinSize ( difference ( setSizeRange ( 11 , 12 ) , setSizeRange ( 10 , 20 ) ) , 0 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean equals ( @Nullable Object obj ) { if ( obj instanceof TypeVariableKey ) { TypeVariableKey that = ( TypeVariableKey ) obj ; return equalsTypeVariable ( that . var ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected final void expectReplacement ( Entry < K , V > newEntry ) { List < Entry < K , V > > expected = copyToList ( getSampleElements ( ) ) ; replaceValue ( expected , newEntry ) ; expectContents ( expected ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public SortedMultiset < E > subMultiset ( @ParametricNullness E fromElement , BoundType fromBoundType , @ParametricNullness E toElement , BoundType toBoundType ) { return forwardMultiset ( ) . subMultiset ( toElement , toBoundType , fromElement , fromBoundType ) . descendingMultiset ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRoundNaNToIntAlwaysFails ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { assertThrows ( ArithmeticException . class , ( ) - > DoubleMath . roundToInt ( Double . NaN , mode ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSegmentPut ( ) { LocalCache < Object , Object > map = makeLocalCache ( createCacheBuilder ( ) . concurrencyLevel ( 1 ) . expireAfterAccess ( 99999 , SECONDS ) ) ; Segment < Object , Object > segment = map . segments[0] ; / / TODO ( fry ) : check recency ordering Object key = new Object ( ) ; int hash = map . hash ( key ) ; Object oldValue = new Object ( ) ; Object newValue = new Object ( ) ; / / no entry assertThat ( segment . count ) . isEqualTo ( 0 ) ; assertThat ( segment . put ( key , hash , oldValue , false ) ) . isNull ( ) ; assertThat ( segment . count ) . isEqualTo ( 1 ) ; / / same key assertThat ( segment . put ( key , hash , newValue , false ) ) . isSameInstanceAs ( oldValue ) ; assertThat ( segment . count ) . isEqualTo ( 1 ) ; assertThat ( segment . get ( key , hash ) ) . isSameInstanceAs ( newValue ) ; / / cleared ReferenceEntry < Object , Object > entry = segment . getEntry ( key , hash ) ; DummyValueReference < Object , Object > oldValueRef = DummyValueReference . create ( oldValue ) ; entry . setValueReference ( oldValueRef ) ; assertThat ( segment . get ( key , hash ) ) . isSameInstanceAs ( oldValue ) ; oldValueRef . clear ( ) ; assertThat ( segment . put ( key , hash , newValue , false ) ) . isNull ( ) ; assertThat ( segment . count ) . isEqualTo ( 1 ) ; assertThat ( segment . get ( key , hash ) ) . isSameInstanceAs ( newValue ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public L getAt ( int index ) { return ( L ) array[index] ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected void doStart ( ) { notifyStarted ( ) ; throw exception ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void createUndirected_multigraph ( ) { MutableNetwork < Integer , String > undirectedMultigraph = NetworkBuilder . undirected ( ) . allowsParallelEdges ( true ) . build ( ) ; assertThat ( undirectedMultigraph . addEdge ( N1 , N2 , E12 ) ) . isTrue ( ) ; assertThat ( undirectedMultigraph . addEdge ( N1 , N2 , E12_A ) ) . isTrue ( ) ; assertThat ( undirectedMultigraph . addEdge ( N2 , N1 , E21 ) ) . isTrue ( ) ; assertThat ( undirectedMultigraph . edgesConnecting ( N1 , N2 ) ) . isEqualTo ( ImmutableSet . of ( E12 , E12_A , E21 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Optional < E > edgeConnecting ( EndpointPair < N > endpoints ) { return delegate ( ) . edgeConnecting ( endpoints ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testNewTreeSetEmptyNonGeneric ( ) { TreeSet < LegacyComparable > set = Sets . newTreeSet ( ) ; assertTrue ( set . isEmpty ( ) ) ; set . add ( new LegacyComparable ( \"foo\" ) ) ; set . add ( new LegacyComparable ( \"bar\" ) ) ; assertThat ( set ) . containsExactly ( new LegacyComparable ( \"bar\" ) , new LegacyComparable ( \"foo\" ) ) . inOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int hashCode ( ) { return bounds . hashCode ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testHeadMapInclusive ( ) { assertTrue ( navigableMap . headMap ( a . getKey ( ) , true ) . containsKey ( a . getKey ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean equals ( @Nullable Object object ) { if ( object instanceof Murmur3_128HashFunction ) { Murmur3_128HashFunction other = ( Murmur3_128HashFunction ) object ; return seed = = other . seed ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testLong ( ) { Sink sink = new Sink ( 8 ) ; sink . putLong ( 0x0807060504030201L ) ; HashCode unused = sink . hash ( ) ; sink . assertInvariants ( 8 ) ; sink . assertBytes ( new byte[] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private void checkStackTrace ( ExecutionException e ) { / / Our call site for get ( ) should be in the trace . int index = findStackFrame ( e , getClass ( ) . getName ( ) , \"getExpectingExecutionException\" ) ; assertThat ( index ) . isNotEqualTo ( 0 ) ; / / Above our method should be the call to get ( ) . Don't assert on the class / / because it could be some superclass . assertThat ( e . getStackTrace ( ) [index - 1] . getMethodName ( ) ) . isEqualTo ( \"get\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void assertChecksum ( ImmutableSupplier < Checksum > supplier , String input ) { byte[] bytes = HashTestUtils . ascii ( input ) ; Checksum checksum = supplier . get ( ) ; checksum . update ( bytes , 0 , bytes . length ) ; long value = checksum . getValue ( ) ; String toString = \"name\" ; HashFunction func = new ChecksumHashFunction ( supplier , 32 , toString ) ; assertEquals ( toString , func . toString ( ) ) ; assertEquals ( value , func . hashBytes ( bytes ) . padToLong ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testStringConverter_serialization ( ) { SerializableTester . reserializeAndAssert ( Enums . stringConverter ( TestEnum . class ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int indexIn ( CharSequence sequence , int start ) { int length = sequence . length ( ) ; checkPositionIndex ( start , length ) ; for ( int i = start ; i < length ; i + + ) { if ( matches ( sequence . charAt ( i ) ) ) { return i ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable E lower ( E e ) { return delegate . lower ( checkValid ( e ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public E get ( int index ) { Preconditions . checkElementIndex ( index , 1 ) ; return element ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public V[] createValueArray ( int length ) { return ( ( TestMultimapGenerator < K , V , M > ) multimapGenerator . getInnerGenerator ( ) ) . createValueArray ( length ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testIdentity_notSame ( ) { Function < Long , Long > identity = Functions . identity ( ) ; assertNotSame ( new Long ( 135135L ) , identity . apply ( new Long ( 135135L ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRemove ( ) { Map < String , Collection < Integer > > map ; try { map = makePopulatedMap ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static boolean isBeforeJava19 ( ) { return JAVA_SPECIFICATION_VERSION . value ( ) . equals ( \"1 . 8\" ) | | parseInt ( JAVA_SPECIFICATION_VERSION . value ( ) ) < 19 ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static long negativeToMaxValue ( long value ) { return ( value > = 0 ) ? value : Long . MAX_VALUE ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public List < Byte > subList ( int fromIndex , int toIndex ) { int size = size ( ) ; checkPositionIndexes ( fromIndex , toIndex , size ) ; if ( fromIndex = = toIndex ) { return Collections . emptyList ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void clear ( ) { Iterators . clear ( iterator ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( ForwardingQueueTest . class ) ; suite . addTest ( QueueTestSuiteBuilder . using ( new TestStringQueueGenerator ( ) { @Override protected Queue < String > create ( String[] elements ) { return new StandardImplForwardingQueue < > ( new LinkedList < > ( asList ( elements ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void failFormat ( String template , Object . . . args ) { fail ( String . format ( template , args ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E > Interner < E > newStrongInterner ( ) { return newBuilder ( ) . strong ( ) . build ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( ForwardingCollectionTest . class ) ; suite . addTest ( CollectionTestSuiteBuilder . using ( new TestStringCollectionGenerator ( ) { @Override protected Collection < String > create ( String[] elements ) { return new StandardImplForwardingCollection < > ( new LinkedList < > ( asList ( elements ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testPublicSuffixMultipleUnders ( ) { / / PSL has both * . uk and * . sch . uk ; the latter should win . / / See https: / / github . com / google / guava / issues / 1176 InternetDomainName domain = InternetDomainName . from ( \"www . essex . sch . uk\" ) ; assertTrue ( domain . hasPublicSuffix ( ) ) ; assertEquals ( \"essex . sch . uk\" , domain . publicSuffix ( ) . toString ( ) ) ; assertEquals ( \"www . essex . sch . uk\" , domain . topPrivateDomain ( ) . toString ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Table < String , Integer , Character > create ( @Nullable Object . . . data ) { Supplier < TreeMap < Integer , Character > > factory = new Supplier < TreeMap < Integer , Character > > ( ) { @Override public TreeMap < Integer , Character > get ( ) { return Maps . newTreeMap ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static Test testsForFilterNoNulls ( ) { return CollectionTestSuiteBuilder . using ( new TestStringCollectionGenerator ( ) { @Override public Collection < String > create ( String[] elements ) { List < String > unfiltered = new ArrayList < > ( ) ; unfiltered . add ( \"yyy\" ) ; unfiltered . addAll ( ImmutableList . copyOf ( elements ) ) ; unfiltered . add ( \"zzz\" ) ; return Collections2 . filter ( unfiltered , LENGTH_1 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public long getWriteTime ( ) { return writeTime ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSerialization_multiple ( ) { Collection < String > c = ImmutableList . of ( \"a\" , \"b\" , \"c\" ) ; SerializableTester . reserializeAndAssert ( c ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Entry < K , V > get ( int index ) { return getEntry ( index ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEquals ( ) { * new ClassSanityTester ( ) * . forAllPublicStaticMethods ( FooFactoryForTest . class ) * . thatReturn ( Foo . class ) * . testEquals ( ) ; *",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static Enumeration < Integer > enumerate ( int . . . ints ) { Vector < Integer > vector = new Vector < > ( Ints . asList ( ints ) ) ; return vector . elements ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < K extends Comparable < ? super K > , V > ImmutableSortedMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 , K k6 , V v6 , K k7 , V v7 , K k8 , V v8 , K k9 , V v9 , K k10 , V v10 ) { return fromEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) , entryOf ( k4 , v4 ) , entryOf ( k5 , v5 ) , entryOf ( k6 , v6 ) , entryOf ( k7 , v7 ) , entryOf ( k8 , v8 ) , entryOf ( k9 , v9 ) , entryOf ( k10 , v10 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void successors_checkReturnedSetMutability ( ) { assume ( ) . that ( graphIsMutable ( ) ) . isTrue ( ) ; addNode ( N1 ) ; Set < Integer > successors = graph . successors ( N1 ) ; assertThrows ( UnsupportedOperationException . class , ( ) - > successors . add ( N2 ) ) ; putEdge ( N1 , N2 ) ; assertThat ( graph . successors ( N1 ) ) . containsExactlyElementsIn ( successors ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static int ceilToMultiple ( int a , int b ) { int remainder = a % b ; return remainder = = 0 ? a : a + b - remainder ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Object getSource ( ) { return source ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCopyOf_map_empty ( ) { Map < Class < ? > , Object > in = emptyMap ( ) ; ClassToInstanceMap < Object > map = ImmutableClassToInstanceMap . copyOf ( in ) ; assertTrue ( map . isEmpty ( ) ) ; assertSame ( map , ImmutableClassToInstanceMap . of ( ) ) ; assertSame ( map , ImmutableClassToInstanceMap . copyOf ( map ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCheckPositionIndex_ok ( ) { assertEquals ( 0 , checkPositionIndex ( 0 , 0 ) ) ; assertEquals ( 0 , checkPositionIndex ( 0 , 1 ) ) ; assertEquals ( 1 , checkPositionIndex ( 1 , 1 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected < E extends Comparable < ? super E > > SortedSet < E > copyOf ( Iterator < ? extends E > elements ) { return ImmutableSortedSet . copyOf ( elements ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void transitiveClosure_undirectedPathGraph_addSelfLoopsForCycles ( ) { MutableGraph < Integer > undirectedGraph = GraphBuilder . undirected ( ) . allowsSelfLoops ( false ) . build ( ) ; undirectedGraph . putEdge ( N1 , N2 ) ; undirectedGraph . putEdge ( N2 , N3 ) ; undirectedGraph . putEdge ( N3 , N4 ) ; MutableGraph < Integer > expectedClosure = GraphBuilder . undirected ( ) . allowsSelfLoops ( true ) . build ( ) ; expectedClosure . putEdge ( N1 , N1 ) ; expectedClosure . putEdge ( N1 , N2 ) ; expectedClosure . putEdge ( N1 , N3 ) ; expectedClosure . putEdge ( N1 , N4 ) ; expectedClosure . putEdge ( N2 , N2 ) ; expectedClosure . putEdge ( N2 , N3 ) ; expectedClosure . putEdge ( N2 , N4 ) ; expectedClosure . putEdge ( N3 , N3 ) ; expectedClosure . putEdge ( N3 , N4 ) ; expectedClosure . putEdge ( N4 , N4 ) ; assertThat ( transitiveClosure ( undirectedGraph , ADD_SELF_LOOPS_FOR_CYCLES ) ) . isEqualTo ( expectedClosure ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean remove ( Object element ) { throw new UnsupportedOperationException ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < K extends @Nullable Object , V extends @Nullable Object > Multimap < K , V > filterEntries ( Multimap < K , V > unfiltered , Predicate < ? super Entry < K , V > > entryPredicate ) { checkNotNull ( entryPredicate ) ; if ( unfiltered instanceof SetMultimap ) { return filterEntries ( ( SetMultimap < K , V > ) unfiltered , entryPredicate ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected void visitParameterizedType ( ParameterizedType t ) { * visit ( t . getOwnerType ( ) ) ; * visit ( t . getActualTypeArguments ( ) ) ; *",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Object getKeyNotInPopulatedMap ( ) { return new Colliders ( ) . e4 ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSubRangeSetAdd ( ) { TreeRangeSet < Integer > set = TreeRangeSet . create ( ) ; Range < Integer > range = Range . closedOpen ( 0 , 5 ) ; set . subRangeSet ( range ) . add ( range ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected F doBackward ( T b ) { return doConvert ( convertFromType ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < Cell < R , C , V > > cellSet ( ) { return delegate ( ) . cellSet ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable Entry < E > pollFirstEntry ( ) { Iterator < Entry < E > > entryIterator = entryIterator ( ) ; if ( entryIterator . hasNext ( ) ) { Entry < E > result = entryIterator . next ( ) ; result = Multisets . immutableEntry ( result . getElement ( ) , result . getCount ( ) ) ; entryIterator . remove ( ) ; return result ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBase32AlternatePadding ( ) { BaseEncoding enc = base32 ( ) . withPadChar ( '~' ) ; testEncodingWithCasing ( enc , \"\" , \"\" ) ; testEncodingWithCasing ( enc , \"f\" , \"MY~~~~~~\" ) ; testEncodingWithCasing ( enc , \"fo\" , \"MZXQ~~~~\" ) ; testEncodingWithCasing ( enc , \"foo\" , \"MZXW6~~~\" ) ; testEncodingWithCasing ( enc , \"foob\" , \"MZXW6YQ~\" ) ; testEncodingWithCasing ( enc , \"fooba\" , \"MZXW6YTB\" ) ; testEncodingWithCasing ( enc , \"foobar\" , \"MZXW6YTBOI~~~~~~\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void checkHashCode ( Set < ? > set ) { assertEquals ( new HashSet < > ( set ) . hashCode ( ) , set . hashCode ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable V remove ( @Nullable Object rowKey , @Nullable Object columnKey ) { return delegate ( ) . remove ( rowKey , columnKey ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected final String escapeSlow ( String s , int index ) { int slen = s . length ( ) ; / / Get a destination buffer and setup some loop variables . char[] dest = Platform . charBufferFromThreadLocal ( ) ; int destSize = dest . length ; int destIndex = 0 ; int lastEscape = 0 ; / / Loop through the rest of the string , replacing when needed into the / / destination buffer , which gets grown as needed as well . for ( ; index < slen ; index + + ) { / / Get a replacement for the current character . char[] r = escape ( s . charAt ( index ) ) ; / / If no replacement is needed , just continue . if ( r = = null ) { continue ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void shouldPass ( Object instance , Visibility visibility ) { new NullPointerTester ( ) . testInstanceMethods ( instance , visibility ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ExceptionWithoutThrowableConstructor ( String s ) { super ( s ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean contains ( @Nullable Object o ) { return containsValue ( o ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEmpty ( ) { ImmutableBiMap < String , Integer > bimap = ImmutableBiMap . of ( ) ; assertEquals ( Collections . < String , Integer > emptyMap ( ) , bimap ) ; assertEquals ( Collections . < Integer , String > emptyMap ( ) , bimap . inverse ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static Method getMergeNullValueMethod ( ) { return Helpers . getMethod ( MapMergeTester . class , \"testMergeNullValue\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCreateFromIllegalSizes ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > HashMultimap . create ( - 20 , 15 ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > HashMultimap . create ( 20 , - 15 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < E > edgesConnecting ( EndpointPair < N > endpoints ) { validateEndpoints ( endpoints ) ; return edgesConnecting ( endpoints . nodeU ( ) , endpoints . nodeV ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void forTree_depthFirstPostOrder_iterableIsLazy ( ) { RequestSavingGraph graph = new RequestSavingGraph ( TREE ) ; Iterable < Character > result = Traverser . forGraph ( graph ) . depthFirstPostOrder ( 'h' ) ; assertEqualCharNodes ( Iterables . limit ( result , 2 ) , \"ab\" ) ; assertThat ( graph . requestedNodes ) . containsExactly ( 'h' , 'h' , 'd' , 'a' , 'b' ) ; / / Iterate again to see if calculation is done again assertEqualCharNodes ( Iterables . limit ( result , 2 ) , \"ab\" ) ; assertThat ( graph . requestedNodes ) . containsExactly ( 'h' , 'h' , 'h' , 'd' , 'd' , 'a' , 'a' , 'b' , 'b' ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean processLine ( String line ) { collector . add ( line ) ; return true ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEntrySet_twice ( ) { assertEquals ( \"calling multiset . entrySet ( ) twice returned unequal sets\" , getMultiset ( ) . entrySet ( ) , getMultiset ( ) . entrySet ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testIndexOfImpl_nonNull ( ) { List < Integer > toTest = createList ( Integer . class , 5 , 2 , - 1 , 2 , 1 , 10 , 5 ) ; int[] expected = { 0 , 1 , 2 , 1 , 4 , 5 , 0",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBuilderPutNullKey ( ) { Multimap < @Nullable String , Integer > toPut = LinkedListMultimap . create ( ) ; toPut . put ( null , 1 ) ; ImmutableListMultimap . Builder < String , Integer > builder = ImmutableListMultimap . builder ( ) ; assertThrows ( NullPointerException . class , ( ) - > builder . put ( null , 1 ) ) ; assertThrows ( NullPointerException . class , ( ) - > builder . putAll ( null , Arrays . asList ( 1 , 2 , 3 ) ) ) ; assertThrows ( NullPointerException . class , ( ) - > builder . putAll ( null , 1 , 2 , 3 ) ) ; assertThrows ( NullPointerException . class , ( ) - > builder . putAll ( ( Multimap < String , Integer > ) toPut ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < T extends @Nullable Object > Predicate < T > alwaysTrue ( ) { return ObjectPredicate . ALWAYS_TRUE . withNarrowedType ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable V get ( @Nullable Object key ) { Map < K , V > delegate = delegateOrNull ( ) ; if ( delegate ! = null ) { return delegate . get ( key ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { return wrapped . toString ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCreation_comparator_withContents ( ) { MinMaxPriorityQueue < Integer > queue = MinMaxPriorityQueue . orderedBy ( SOME_COMPARATOR ) . create ( NUMBERS ) ; assertEquals ( 6 , queue . size ( ) ) ; assertEquals ( 11 , queue . capacity ( ) ) ; checkUnbounded ( queue ) ; assertSame ( SOME_COMPARATOR , queue . comparator ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private Splitter ( Strategy strategy , boolean omitEmptyStrings , CharMatcher trimmer , int limit ) { this . strategy = strategy ; this . omitEmptyStrings = omitEmptyStrings ; this . trimmer = trimmer ; this . limit = limit ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCorrectOrdering_regression ( ) { MinMaxPriorityQueue < Integer > q = MinMaxPriorityQueue . create ( ImmutableList . of ( 3 , 5 , 1 , 4 , 7 ) ) ; List < Integer > expected = ImmutableList . of ( 1 , 3 , 4 , 5 , 7 ) ; List < Integer > actual = new ArrayList < > ( 5 ) ; for ( int i = 0 ; i < expected . size ( ) ; i + + ) { actual . add ( q . pollFirst ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int count ( Object element ) { return standardCount ( element ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void wrapAndThrowRuntimeExecutionExceptionOrError ( Throwable cause ) { if ( cause instanceof Error ) { throw new ExecutionError ( ( Error ) cause ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testNewDataInput_readDouble ( ) { byte[] data = { 0x12 , 0x34 , 0x56 , 0x78 , 0x76 , 0x54 , 0x32 , 0x10",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testStop_afterStart ( ) { TestService service = new TestService ( ) ; service . startAsync ( ) . awaitRunning ( ) ; assertEquals ( 1 , service . startUpCalled ) ; assertEquals ( 0 , service . shutDownCalled ) ; service . stopAsync ( ) . awaitTerminated ( ) ; assertEquals ( 1 , service . startUpCalled ) ; assertEquals ( 1 , service . shutDownCalled ) ; assertEquals ( Service . State . TERMINATED , service . state ( ) ) ; assertThat ( service . transitionStates ) . containsExactly ( Service . State . STARTING , Service . State . STOPPING ) . inOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private boolean verifyIndex ( int i ) { if ( ( getLeftChildIndex ( i ) < size ) & & ( compareElements ( i , getLeftChildIndex ( i ) ) > 0 ) ) { return false ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testToString ( ) { SetMultimap < String , Integer > multimap = LinkedHashMultimap . create ( ) ; multimap . put ( \"foo\" , 3 ) ; multimap . put ( \"bar\" , 1 ) ; multimap . putAll ( \"foo\" , asList ( - 1 , 2 , 4 ) ) ; multimap . putAll ( \"bar\" , asList ( 2 , 3 ) ) ; multimap . put ( \"foo\" , 1 ) ; assertEquals ( \" { foo = [3 , - 1 , 2 , 4 , 1] , bar = [1 , 2 , 3]",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Map < C , Map < R , V > > columnMap ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . columnMap ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private E element ( int i ) { return ( E ) requireElements ( ) [i] ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void testReverse ( boolean[] input , int fromIndex , int toIndex , boolean[] expectedOutput ) { input = Arrays . copyOf ( input , input . length ) ; Booleans . reverse ( input , fromIndex , toIndex ) ; assertThat ( input ) . isEqualTo ( expectedOutput ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testIncrementAndGet ( ) { AtomicLongMap < String > map = AtomicLongMap . create ( ) ; String key = \"key\" ; for ( int i = 0 ; i < ITERATIONS ; i + + ) { long before = map . get ( key ) ; long result = map . incrementAndGet ( key ) ; long after = map . get ( key ) ; assertEquals ( before + 1 , after ) ; assertEquals ( after , result ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public < N1 extends Number , N2 extends Number , N11 extends N1 > void testisSupertypeOf_wildcardType_upperBoundMatch ( ) { / / ? extends T assertAssignable ( new TypeToken < List < N11 > > ( ) {",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static MyServer create ( . . . ) { * MyServer myServer = new MyServer ( . . . ) ; * ServerSocket serverSocket = myServer . serverSocket ; * Reference < ? > reference = new FinalizablePhantomReference < MyServer > ( myServer , frq ) { * @Override * public void finalizeReferent ( ) { * references . remove ( this ) : * if ( ! serverSocket . isClosed ( ) ) { * . . . log a message about how nobody called close ( ) . . . * try { * serverSocket . close ( ) ; *",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCompareBooleans ( ) { assertThat ( ComparisonChain . start ( ) . compare ( true , true ) . compare ( true , Boolean . TRUE ) . compare ( Boolean . TRUE , true ) . compare ( Boolean . TRUE , Boolean . TRUE ) . result ( ) ) . isEqualTo ( 0 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCopyOf_stream ( ) { assertThat ( ImmutableIntArray . copyOf ( IntStream . empty ( ) ) ) . isSameInstanceAs ( ImmutableIntArray . of ( ) ) ; assertThat ( ImmutableIntArray . copyOf ( IntStream . of ( 0 , 1 , 3 ) ) . asList ( ) ) . containsExactly ( 0 , 1 , 3 ) . inOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private void doTestGeneral ( CharMatcher matcher , char match , char noMatch ) { doTestOneCharMatch ( matcher , \"\" + match ) ; doTestOneCharNoMatch ( matcher , \"\" + noMatch ) ; doTestMatchThenNoMatch ( matcher , \"\" + match + noMatch ) ; doTestNoMatchThenMatch ( matcher , \"\" + noMatch + match ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static < C extends @Nullable Object , V extends C > void provideValueAndCloser ( ValueAndCloserConsumer < C > consumer , ClosingFuture < V > closingFuture ) { consumer . accept ( new ValueAndCloser < C > ( closingFuture ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static long swapNext ( long entry , int newNext ) { return ( HASH_MASK & entry ) | ( NEXT_MASK & newNext ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { if ( count ( ) > 0 ) { return MoreObjects . toStringHelper ( this ) . add ( \"count\" , count ) . add ( \"mean\" , mean ) . add ( \"populationStandardDeviation\" , populationStandardDeviation ( ) ) . add ( \"min\" , min ) . add ( \"max\" , max ) . toString ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Collection < V > replaceValues ( @ParametricNullness K key , Iterable < ? extends V > values ) { return delegate ( ) . replaceValues ( key , values ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCopyOf ( ) { Map < String , Integer > original = new LinkedHashMap < > ( ) ; original . put ( \"one\" , 1 ) ; original . put ( \"two\" , 2 ) ; original . put ( \"three\" , 3 ) ; ImmutableMap < String , Integer > copy = ImmutableMap . copyOf ( original ) ; assertMapEquals ( copy , \"one\" , 1 , \"two\" , 2 , \"three\" , 3 ) ; assertSame ( copy , ImmutableMap . copyOf ( copy ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public NavigableSet < E > tailSet ( @ParametricNullness E fromElement , boolean inclusive ) { return new NavigableElementSet < > ( multiset ( ) . tailMultiset ( fromElement , BoundType . forBoolean ( inclusive ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable Object poll ( ) { return null ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public SortedSet < V > removeAll ( @Nullable Object key ) { synchronized ( mutex ) { return delegate ( ) . removeAll ( key ) ; / / copy not synchronized",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testGetUnchecked_error ( ) { try { getUnchecked ( ERROR_FUTURE ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean remove ( @Nullable Object key , @Nullable Object value ) { return get ( ( K ) key ) . remove ( value ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCacheBuilderFrom_string ( ) { CacheBuilder < ? , ? > fromString = CacheBuilder . from ( \"initialCapacity = 10 , maximumSize = 20 , concurrencyLevel = 30 , \" + \"weakKeys , weakValues , expireAfterAccess = 10m\" ) ; CacheBuilder < ? , ? > expected = CacheBuilder . newBuilder ( ) . initialCapacity ( 10 ) . maximumSize ( 20 ) . concurrencyLevel ( 30 ) . weakKeys ( ) . weakValues ( ) . expireAfterAccess ( 10L , MINUTES ) ; assertCacheBuilderEquivalence ( expected , fromString ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Hasher putBytes ( byte[] bytes , int off , int len ) { for ( Hasher hasher : hashers ) { hasher . putBytes ( bytes , off , len ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public synchronized void failed ( State from , Throwable failure ) { assertEquals ( from , Iterables . getLast ( stateHistory ) ) ; stateHistory . add ( State . FAILED ) ; assertEquals ( State . FAILED , service . state ( ) ) ; assertEquals ( failure , service . failureCause ( ) ) ; if ( from = = State . STARTING ) { try { service . awaitRunning ( ) ; fail ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testIsFinite ( ) { for ( double value : NUMBERS ) { assertThat ( Doubles . isFinite ( value ) ) . isEqualTo ( Double . isFinite ( value ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private RangeMap < K , V > emptySubRangeMap ( ) { return ( RangeMap < K , V > ) ( RangeMap < ? , ? > ) EMPTY_SUB_RANGE_MAP ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCycleOfTwoWithRemove ( ) { Iterable < String > iterable = Lists . newArrayList ( \"a\" , \"b\" ) ; Iterator < String > cycle = Iterators . cycle ( iterable ) ; assertTrue ( cycle . hasNext ( ) ) ; assertEquals ( \"a\" , cycle . next ( ) ) ; assertTrue ( cycle . hasNext ( ) ) ; assertEquals ( \"b\" , cycle . next ( ) ) ; assertTrue ( cycle . hasNext ( ) ) ; assertEquals ( \"a\" , cycle . next ( ) ) ; cycle . remove ( ) ; assertEquals ( singletonList ( \"b\" ) , iterable ) ; assertTrue ( cycle . hasNext ( ) ) ; assertEquals ( \"b\" , cycle . next ( ) ) ; assertTrue ( cycle . hasNext ( ) ) ; assertEquals ( \"b\" , cycle . next ( ) ) ; cycle . remove ( ) ; assertEquals ( emptyList ( ) , iterable ) ; assertFalse ( cycle . hasNext ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testValidTopPrivateDomain ( ) { InternetDomainName googleDomain = InternetDomainName . from ( \"google . com\" ) ; assertEquals ( googleDomain , googleDomain . topPrivateDomain ( ) ) ; assertEquals ( googleDomain , googleDomain . child ( \"mail\" ) . topPrivateDomain ( ) ) ; assertEquals ( googleDomain , googleDomain . child ( \"foo . bar\" ) . topPrivateDomain ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testContainsRow ( ) { table = create ( \"foo\" , 1 , 'a' , \"bar\" , 1 , 'b' , \"foo\" , 3 , 'c' ) ; assertTrue ( table . containsRow ( \"foo\" ) ) ; assertTrue ( table . containsRow ( \"bar\" ) ) ; assertTrue ( table . containsRow ( \"cat\" ) ) ; assertFalse ( table . containsRow ( \"bad\" ) ) ; assertFalse ( table . containsRow ( null ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected void update ( byte[] bytes , int off , int len ) { checksum . update ( bytes , off , len ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public MapValueCollectionGenerator ( OneSizeTestContainerGenerator < Map < K , V > , Entry < K , V > > mapGenerator ) { this . mapGenerator = mapGenerator ; SampleElements < Entry < K , V > > mapSamples = this . mapGenerator . samples ( ) ; this . samples = new SampleElements < > ( mapSamples . e0 ( ) . getValue ( ) , mapSamples . e1 ( ) . getValue ( ) , mapSamples . e2 ( ) . getValue ( ) , mapSamples . e3 ( ) . getValue ( ) , mapSamples . e4 ( ) . getValue ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testUtf8 ( ) { assertEquals ( Charset . forName ( \"UTF - 8\" ) , Charsets . UTF_8 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testPutNullValue_unsupported ( ) { assertThrows ( NullPointerException . class , ( ) - > multimap ( ) . put ( k1 ( ) , null ) ) ; expectUnchanged ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void cleanUp ( ) { delegate ( ) . cleanUp ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testTransform ( ) { Iterator < String > input = asList ( \"1\" , \"2\" , \"3\" ) . iterator ( ) ; Iterator < Integer > result = Iterators . transform ( input , new Function < String , Integer > ( ) { @Override public Integer apply ( String from ) { return Integer . valueOf ( from ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCompose ( ) { Function < String , String > trim = TrimStringFunction . INSTANCE ; Predicate < String > equalsFoo = Predicates . equalTo ( \"Foo\" ) ; Predicate < String > equalsBar = Predicates . equalTo ( \"Bar\" ) ; Predicate < String > trimEqualsFoo = Predicates . compose ( equalsFoo , trim ) ; Function < String , String > identity = Functions . identity ( ) ; assertTrue ( trimEqualsFoo . apply ( \"Foo\" ) ) ; assertTrue ( trimEqualsFoo . apply ( \" Foo \" ) ) ; assertFalse ( trimEqualsFoo . apply ( \"Foo - b - que\" ) ) ; new EqualsTester ( ) . addEqualityGroup ( trimEqualsFoo , Predicates . compose ( equalsFoo , trim ) ) . addEqualityGroup ( equalsFoo ) . addEqualityGroup ( trim ) . addEqualityGroup ( Predicates . compose ( equalsFoo , identity ) ) . addEqualityGroup ( Predicates . compose ( equalsBar , trim ) ) . testEquals ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void predecessors_selfLoop ( ) { assume ( ) . that ( network . allowsSelfLoops ( ) ) . isTrue ( ) ; addEdge ( N1 , N1 , E11 ) ; assertThat ( network . predecessors ( N1 ) ) . containsExactly ( N1 ) ; addEdge ( N4 , N1 , E41 ) ; assertThat ( network . predecessors ( N1 ) ) . containsExactly ( N1 , N4 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testNullGet ( ) { ImmutableSortedMap < String , Integer > map = ImmutableSortedMap . of ( \"one\" , 1 ) ; assertThat ( map . get ( null ) ) . isNull ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < T > T verifyNotNull ( @Nullable T reference , String errorMessageTemplate , @Nullable Object @Nullable . . . errorMessageArgs ) { if ( reference = = null ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , errorMessageArgs ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Character set ( int index , Character element ) { checkElementIndex ( index , size ( ) ) ; char oldValue = array[start + index] ; / / checkNotNull for GWT ( do not optimize ) array[start + index] = checkNotNull ( element ) ; return oldValue ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ListenableScheduledFuture < ? > schedule ( Runnable command , long delay , TimeUnit unit ) { Preconditions . checkNotNull ( command , \"command must not be null\" ) ; Preconditions . checkNotNull ( unit , \"unit must not be null ! \" ) ; return schedule ( callable ( command ) , delay , unit ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static HashFunction hmacSha1 ( Key key ) { return new MacHashFunction ( \"HmacSHA1\" , key , hmacToString ( \"hmacSha1\" , key ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String apply ( Integer input ) { throw exception ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected List < TestSuite > createDerivedSuites ( FeatureSpecificTestSuiteBuilder < ? , ? extends OneSizeTestContainerGenerator < Collection < E > , E > > parentBuilder ) { List < TestSuite > derivedSuites = new ArrayList < > ( super . createDerivedSuites ( parentBuilder ) ) ; if ( ! parentBuilder . getFeatures ( ) . contains ( SUBSET_VIEW ) ) { / / Other combinations are inherited from SortedSetTestSuiteBuilder . derivedSuites . add ( createSubsetSuite ( parentBuilder , Bound . NO_BOUND , Bound . INCLUSIVE ) ) ; derivedSuites . add ( createSubsetSuite ( parentBuilder , Bound . EXCLUSIVE , Bound . NO_BOUND ) ) ; derivedSuites . add ( createSubsetSuite ( parentBuilder , Bound . EXCLUSIVE , Bound . EXCLUSIVE ) ) ; derivedSuites . add ( createSubsetSuite ( parentBuilder , Bound . EXCLUSIVE , Bound . INCLUSIVE ) ) ; derivedSuites . add ( createSubsetSuite ( parentBuilder , Bound . INCLUSIVE , Bound . INCLUSIVE ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { / / Behaviour analogous to AbstractFuture#toString ( ) . return super . toString ( ) + \"[status = SUCCESS , result = [\" + value + \"]]\" ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private SetMultimap < String , Integer > initializeMultimap5 ( ) { SetMultimap < String , Integer > multimap = LinkedHashMultimap . create ( ) ; multimap . put ( \"foo\" , 5 ) ; multimap . put ( \"bar\" , 4 ) ; multimap . put ( \"foo\" , 3 ) ; multimap . put ( \"cow\" , 2 ) ; multimap . put ( \"bar\" , 1 ) ; return multimap ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testFailOneArgThrowsWrongType ( ) { shouldFail ( new FailOneArgThrowsWrongType ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testIteratorPastEndException ( ) { MinMaxPriorityQueue < Integer > mmHeap = MinMaxPriorityQueue . create ( ) ; mmHeap . addAll ( Lists . newArrayList ( 1 , 2 ) ) ; Iterator < Integer > it = mmHeap . iterator ( ) ; assertTrue ( \"Iterator has reached end prematurely\" , it . hasNext ( ) ) ; it . next ( ) ; it . next ( ) ; assertThrows ( NoSuchElementException . class , ( ) - > it . next ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public NavigableSet < E > headSet ( E toElement , boolean inclusive ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate ( ) . headSet ( toElement , inclusive ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testContainsEntryWithNullKeyAbsent ( ) { assertFalse ( getMap ( ) . entrySet ( ) . contains ( mapEntry ( null , v0 ( ) ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean hasPrevious ( ) { return previous ! = null ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public TypeToken < T > getOwnerType ( ) { return TypeToken . this ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( ImmutableClassToInstanceMapTest . class ) ; suite . addTest ( MapTestSuiteBuilder . using ( new TestClassToInstanceMapGenerator ( ) { / / Other tests will verify what real , warning - free usage looks like / / but here we have to do some serious fudging @Override @SuppressWarnings ( { \"unchecked\" , \"rawtypes\"",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final int hash ( @Nullable T t ) { if ( t = = null ) { return 0 ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testGetSubtype_baseClassWithNoTypeArgs ( ) { class SingleGenericExtendsBase < T > extends Base {",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void add ( int index , @ParametricNullness V element ) { checkPositionIndex ( index , 0 ) ; throw new IllegalArgumentException ( \"Key does not satisfy predicate: \" + key ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < Multiset . Entry < E > > entrySet ( ) { Set < Multiset . Entry < E > > es = entrySet ; return ( es = = null ) / / Safe because the returned set is made unmodifiable and Entry / / itself is readonly ? entrySet = ( Set ) Collections . unmodifiableSet ( delegate . entrySet ( ) ) : es ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCopyOf_plainIterable ( ) { CountingIterable iterable = new CountingIterable ( ) ; Multiset < String > multiset = ImmutableSortedMultiset . copyOf ( iterable ) ; assertEquals ( HashMultiset . create ( asList ( \"a\" , \"b\" , \"a\" ) ) , multiset ) ; assertEquals ( 1 , iterable . count ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < T > T checkNotNull ( @Nullable T reference , String errorMessageTemplate , int p1 , int p2 ) { if ( reference = = null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testOverriddenNotAnnotatedInSubclass ( ) { assertThat ( getSubscriber ( ) . overriddenInSubclassEvents ) . contains ( EVENT ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean hasPort ( ) { return port > = 0 ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static boolean isValid ( String specifier ) { try { HostSpecifier unused = fromValid ( specifier ) ; return true ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void differentlyOverriddenNotAnnotatedInSubclass ( Object o ) { / / the subclass overrides this and does * not * call super . dONAIS ( o ) differentlyOverriddenNotAnnotatedInSubclassBadEvents . add ( o ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void mapMethods ( ) { Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . build ( ) ; ConcurrentMap < Integer , Integer > asMap = cache . asMap ( ) ; cache . put ( 10 , 100 ) ; cache . put ( 2 , 52 ) ; asMap . replace ( 2 , 79 ) ; asMap . replace ( 3 , 60 ) ; assertThat ( cache . getIfPresent ( 3 ) ) . isNull ( ) ; assertThat ( asMap . get ( 3 ) ) . isNull ( ) ; assertThat ( cache . getIfPresent ( 2 ) ) . isEqualTo ( 79 ) ; assertThat ( asMap . get ( 2 ) ) . isEqualTo ( 79 ) ; asMap . replace ( 10 , 100 , 50 ) ; asMap . replace ( 2 , 52 , 99 ) ; assertThat ( cache . getIfPresent ( 10 ) ) . isEqualTo ( 50 ) ; assertThat ( asMap . get ( 10 ) ) . isEqualTo ( 50 ) ; assertThat ( cache . getIfPresent ( 2 ) ) . isEqualTo ( 79 ) ; assertThat ( asMap . get ( 2 ) ) . isEqualTo ( 79 ) ; asMap . remove ( 10 , 100 ) ; asMap . remove ( 2 , 79 ) ; assertThat ( cache . getIfPresent ( 10 ) ) . isEqualTo ( 50 ) ; assertThat ( asMap . get ( 10 ) ) . isEqualTo ( 50 ) ; assertThat ( cache . getIfPresent ( 2 ) ) . isNull ( ) ; assertThat ( asMap . get ( 2 ) ) . isNull ( ) ; asMap . putIfAbsent ( 2 , 20 ) ; asMap . putIfAbsent ( 10 , 20 ) ; assertThat ( cache . getIfPresent ( 2 ) ) . isEqualTo ( 20 ) ; assertThat ( asMap . get ( 2 ) ) . isEqualTo ( 20 ) ; assertThat ( cache . getIfPresent ( 10 ) ) . isEqualTo ( 50 ) ; assertThat ( asMap . get ( 10 ) ) . isEqualTo ( 50 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testPowerSetEquals_independentOfOrder ( ) { ImmutableSet < Integer > elements = ImmutableSet . of ( 1 , 2 , 3 , 4 ) ; Set < Set < Integer > > forward = powerSet ( elements ) ; Set < Set < Integer > > reverse = powerSet ( ImmutableSet . copyOf ( elements . asList ( ) . reverse ( ) ) ) ; new EqualsTester ( ) . addEqualityGroup ( forward , reverse ) . testEquals ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int compareTo ( Foo that ) { * return COMPARATOR . compare ( this , that ) ; *",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCompare ( ) { / / max value assertThat ( UnsignedLongs . compare ( 0 , 0xffffffffffffffffL ) ) . isLessThan ( 0 ) ; assertThat ( UnsignedLongs . compare ( 0xffffffffffffffffL , 0 ) ) . isGreaterThan ( 0 ) ; / / both with high bit set assertThat ( UnsignedLongs . compare ( 0xff1a618b7f65ea12L , 0xffffffffffffffffL ) ) . isLessThan ( 0 ) ; assertThat ( UnsignedLongs . compare ( 0xffffffffffffffffL , 0xff1a618b7f65ea12L ) ) . isGreaterThan ( 0 ) ; / / one with high bit set assertThat ( UnsignedLongs . compare ( 0x5a4316b8c153ac4dL , 0xff1a618b7f65ea12L ) ) . isLessThan ( 0 ) ; assertThat ( UnsignedLongs . compare ( 0xff1a618b7f65ea12L , 0x5a4316b8c153ac4dL ) ) . isGreaterThan ( 0 ) ; / / neither with high bit set assertThat ( UnsignedLongs . compare ( 0x5a4316b8c153ac4dL , 0x6cf78a4b139a4e2aL ) ) . isLessThan ( 0 ) ; assertThat ( UnsignedLongs . compare ( 0x6cf78a4b139a4e2aL , 0x5a4316b8c153ac4dL ) ) . isGreaterThan ( 0 ) ; / / same value assertThat ( UnsignedLongs . compare ( 0xff1a618b7f65ea12L , 0xff1a618b7f65ea12L ) ) . isEqualTo ( 0 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testAssignableWildcardTypeParameterBoundedByIntArrayToArrayClassTypeParameter ( ) { TypeToken < ? > wildcardType = new TypeToken < Iterable < ? extends int[] > > ( ) {",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < V extends @Nullable Object > ListenableFuture < V > immediateCancelledFuture ( ) { ListenableFuture < Object > instance = ImmediateCancelledFuture . INSTANCE ; if ( instance ! = null ) { return ( ListenableFuture < V > ) instance ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCompositeTypeToken ( ) { Foo < String[] , List < int[] > > foo = new Foo < String[] , List < int[] > > ( ) {",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean offer ( Object o ) { return true ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRemove_nonePresent ( ) { when ( backingMap . get ( KEY ) ) . thenReturn ( null ) ; assertEquals ( 0 , multiset . remove ( KEY , 400 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testToAddrStringIPv6 ( ) { assertEquals ( \"1:2:3:4:5:6:7:8\" , InetAddresses . toAddrString ( InetAddresses . forString ( \"1:2:3:4:5:6:7:8\" ) ) ) ; assertEquals ( \"2001:0:0:4::8\" , InetAddresses . toAddrString ( InetAddresses . forString ( \"2001:0:0:4:0:0:0:8\" ) ) ) ; assertEquals ( \"2001::4:5:6:7:8\" , InetAddresses . toAddrString ( InetAddresses . forString ( \"2001:0:0:4:5:6:7:8\" ) ) ) ; assertEquals ( \"2001:0:3:4:5:6:7:8\" , InetAddresses . toAddrString ( InetAddresses . forString ( \"2001:0:3:4:5:6:7:8\" ) ) ) ; assertEquals ( \"0:0:3::ffff\" , InetAddresses . toAddrString ( InetAddresses . forString ( \"0:0:3:0:0:0:0:ffff\" ) ) ) ; assertEquals ( \"::4:0:0:0:ffff\" , InetAddresses . toAddrString ( InetAddresses . forString ( \"0:0:0:4:0:0:0:ffff\" ) ) ) ; assertEquals ( \"::5:0:0:ffff\" , InetAddresses . toAddrString ( InetAddresses . forString ( \"0:0:0:0:5:0:0:ffff\" ) ) ) ; assertEquals ( \"1::4:0:0:7:8\" , InetAddresses . toAddrString ( InetAddresses . forString ( \"1:0:0:4:0:0:7:8\" ) ) ) ; assertEquals ( \"::\" , InetAddresses . toAddrString ( InetAddresses . forString ( \"0:0:0:0:0:0:0:0\" ) ) ) ; assertEquals ( \"::1\" , InetAddresses . toAddrString ( InetAddresses . forString ( \"0:0:0:0:0:0:0:1\" ) ) ) ; assertEquals ( \"2001:658:22a:cafe::\" , InetAddresses . toAddrString ( InetAddresses . forString ( \"2001:0658:022a:cafe::\" ) ) ) ; assertEquals ( \"::102:304\" , InetAddresses . toAddrString ( InetAddresses . forString ( \"::1 . 2 . 3 . 4\" ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testFromIntBitsLongValue ( ) { for ( int value : TEST_INTS ) { long expected = value & 0xffffffffL ; assertWithMessage ( UnsignedInts . toString ( value ) ) . that ( UnsignedInteger . fromIntBits ( value ) . longValue ( ) ) . isEqualTo ( expected ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < K , V > ImmutableBiMap < K , V > copyOf ( Iterable < ? extends Entry < ? extends K , ? extends V > > entries ) { @SuppressWarnings ( \"unchecked\" ) / / we'll only be using getKey and getValue , which are covariant Entry < K , V > [] entryArray = ( Entry < K , V > [] ) Iterables . toArray ( entries , EMPTY_ENTRY_ARRAY ) ; switch ( entryArray . length ) { case 0: return of ( ) ; case 1: Entry < K , V > entry = entryArray[0] ; return of ( entry . getKey ( ) , entry . getValue ( ) ) ; default: / * * The current implementation will end up using entryArray directly , though it will write * over the ( arbitrary , potentially mutable ) Entry objects actually stored in entryArray . * / return RegularImmutableBiMap . fromEntries ( entryArray ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testGet ( ) { assertEquals ( 20 , new Count ( 20 ) . get ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void hasEdgeConnecting_mismatch ( ) { putEdge ( N1 , N2 ) ; assertThat ( graph . hasEdgeConnecting ( EndpointPair . ordered ( N1 , N2 ) ) ) . isFalse ( ) ; assertThat ( graph . hasEdgeConnecting ( EndpointPair . ordered ( N2 , N1 ) ) ) . isFalse ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static < T > T expectArgument ( Class < T > type , Object arg ) { try { return type . cast ( arg ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Invokable < ? , ? > getDeclaringInvokable ( ) { return declaration ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static int frequency ( Iterator < ? > iterator , @Nullable Object element ) { int count = 0 ; while ( contains ( iterator , element ) ) { / / Since it lives in the same class , we know contains gets to the element and then stops , / / though that isn't currently publicly documented . count + + ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public V setValue ( @ParametricNullness V value ) { throw new UnsupportedOperationException ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void clear ( ) { fromCollection . clear ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < K , V > ImmutableMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 , K k6 , V v6 , K k7 , V v7 , K k8 , V v8 , K k9 , V v9 , K k10 , V v10 ) { return new RegularImmutableMap < K , V > ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) , entryOf ( k4 , v4 ) , entryOf ( k5 , v5 ) , entryOf ( k6 , v6 ) , entryOf ( k7 , v7 ) , entryOf ( k8 , v8 ) , entryOf ( k9 , v9 ) , entryOf ( k10 , v10 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean isShutdown ( ) { throw new UnsupportedOperationException ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static boolean validatePart ( String part , boolean isFinalPart ) { / / These tests could be collapsed into one big boolean expression , but / / they have been left as independent tests for clarity . if ( part . length ( ) < 1 | | part . length ( ) > MAX_DOMAIN_PART_LENGTH ) { return false ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Collection < String > createCollection ( Iterable < ? extends String > values ) { return Lists . newArrayList ( values ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private void testIdentityKeyEquality ( MapMakerInternalMap . Strength keyStrength ) { ConcurrentMap < String , AtomicInteger > map = new MapMaker ( ) . setKeyStrength ( keyStrength ) . keyEquivalence ( Equivalence . identity ( ) ) . makeMap ( ) ; ConcurrentHashMultiset < String > multiset = ConcurrentHashMultiset . create ( map ) ; String s1 = new String ( \"a\" ) ; String s2 = new String ( \"a\" ) ; assertEquals ( s1 , s2 ) ; / / Stating the obvious . assertTrue ( s1 ! = s2 ) ; / / Stating the obvious . multiset . add ( s1 ) ; assertTrue ( multiset . contains ( s1 ) ) ; assertFalse ( multiset . contains ( s2 ) ) ; assertEquals ( 1 , multiset . count ( s1 ) ) ; assertEquals ( 0 , multiset . count ( s2 ) ) ; multiset . add ( s1 ) ; multiset . add ( s2 , 3 ) ; assertEquals ( 2 , multiset . count ( s1 ) ) ; assertEquals ( 3 , multiset . count ( s2 ) ) ; multiset . remove ( s1 ) ; assertEquals ( 1 , multiset . count ( s1 ) ) ; assertEquals ( 3 , multiset . count ( s2 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testToStringLenient_oneIntegerField ( ) { String toTest = MoreObjects . toStringHelper ( new TestClass ( ) ) . add ( \"field1\" , Integer . valueOf ( 42 ) ) . toString ( ) ; assertTrue ( toTest , toTest . matches ( \" . * \\\\ { field1\\\\ = 42\\\\",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public < E extends Comparable < E > > Multiset < E > create ( Collection < E > contents ) { return HashMultiset . create ( contents ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final Optional < @NonNull E > firstMatch ( Predicate < ? super E > predicate ) { / / Unsafe , but we can't do much about it now . return Iterables . < @NonNull E > tryFind ( ( Iterable < @NonNull E > ) getDelegate ( ) , predicate ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Map < K , V > entriesInCommon ( ) { return onBoth ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCharacterSplitWithTrailingDelimiter ( ) { String trailing = \"a , b , c , \" ; Iterable < String > letters = COMMA_SPLITTER . split ( trailing ) ; assertThat ( letters ) . containsExactly ( \"a\" , \"b\" , \"c\" , \"\" ) . inOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < T extends @Nullable Object > T getFirst ( Iterable < ? extends T > iterable , @ParametricNullness T defaultValue ) { return Iterators . getNext ( iterable . iterator ( ) , defaultValue ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Collection < V > values ( ) { return original . values ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public < A extends @Nullable Object > void a ( A a ) { fail ( \"Method with parameter < A extends @Nullable Object > should not be called\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable Entry < Range < K > , V > getEntry ( K key ) { Entry < Cut < K > , RangeMapEntry < K , V > > mapEntry = entriesByLowerBound . floorEntry ( Cut . belowValue ( key ) ) ; if ( mapEntry ! = null & & mapEntry . getValue ( ) . contains ( key ) ) { return mapEntry . getValue ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void assertHashBytesEquivalence ( HashFunction hashFunction , Random random ) { int size = random . nextInt ( 2048 ) ; byte[] bytes = new byte[size] ; random . nextBytes ( bytes ) ; assertEquals ( hashFunction . hashBytes ( bytes ) , hashFunction . newHasher ( size ) . putBytes ( bytes ) . hash ( ) ) ; int off = random . nextInt ( size ) ; int len = random . nextInt ( size - off ) ; assertEquals ( hashFunction . hashBytes ( bytes , off , len ) , hashFunction . newHasher ( size ) . putBytes ( bytes , off , len ) . hash ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public SortedSet < E > headSet ( @ParametricNullness E toElement ) { return standardHeadSet ( toElement ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static Method[] getHoleMethods ( ) { return new Method[] { getMethod ( NavigableSetNavigationTester . class , \"testLowerHole\" ) , getMethod ( NavigableSetNavigationTester . class , \"testFloorHole\" ) , getMethod ( NavigableSetNavigationTester . class , \"testCeilingHole\" ) , getMethod ( NavigableSetNavigationTester . class , \"testHigherHole\" ) ,",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ForMapMultimapAsMapImplementsMapTest ( ) { super ( true , true , true ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testAddAtIndex_supportedNotPresent ( ) { getList ( ) . add ( 0 , e3 ( ) ) ; expectAdded ( 0 , e3 ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEquals ( ) { new EqualsTester ( ) . addEqualityGroup ( ImmutableIntArray . of ( ) ) . addEqualityGroup ( ImmutableIntArray . of ( 1 , 2 ) , reserialize ( ImmutableIntArray . of ( 1 , 2 ) ) , ImmutableIntArray . of ( 0 , 1 , 2 , 3 ) . subArray ( 1 , 3 ) ) . addEqualityGroup ( ImmutableIntArray . of ( 1 , 3 ) ) . addEqualityGroup ( ImmutableIntArray . of ( 1 , 2 , 3 ) ) . testEquals ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E > ImmutableList < E > copyOf ( E[] elements ) { return ( elements . length = = 0 ) ? ImmutableList . < E > of ( ) : ImmutableList . < E > construct ( elements . clone ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String getName ( ) { return example = = null ? super . getName ( ) : buildTestName ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static ToStringHelper toStringHelper ( Class < ? > clazz ) { return new ToStringHelper ( clazz . getSimpleName ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean removeAll ( Collection < ? > collection ) { boolean changed = false ; Iterator < E > itr = unfiltered . iterator ( ) ; while ( itr . hasNext ( ) ) { E e = itr . next ( ) ; if ( predicate . apply ( e ) & & collection . contains ( e ) ) { itr . remove ( ) ; changed = true ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean offerFirst ( E e ) { synchronized ( mutex ) { return delegate ( ) . offerFirst ( e ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E > Set < E > newConcurrentHashSet ( ) { return Collections . newSetFromMap ( new ConcurrentHashMap < E , Boolean > ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean removeNode ( N node ) { checkNotNull ( node , \"node\" ) ; NetworkConnections < N , E > connections = nodeConnections . get ( node ) ; if ( connections = = null ) { return false ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < K > elementSet ( ) { return multimap . keySet ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < K , V > Builder < K , V > builder ( ) { return new Builder < K , V > ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testDivNonZero ( ) { for ( BigInteger p : NONZERO_BIGINTEGER_CANDIDATES ) { for ( BigInteger q : NONZERO_BIGINTEGER_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { BigInteger expected = new BigDecimal ( p ) . divide ( new BigDecimal ( q ) , 0 , mode ) . toBigIntegerExact ( ) ; assertEquals ( expected , BigIntegerMath . divide ( p , q , mode ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static CharSinkFactory fileCharSinkFactory ( ) { return new FileCharSinkFactory ( null ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCreation_arrayContainingOnlyNull ( ) { String[] array = new String[] { null",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void addPredecessor ( N node , V unused ) { Object previousValue = adjacentNodeValues . put ( node , PRED ) ; boolean addedPredecessor ; if ( previousValue = = null ) { addedPredecessor = true ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static Method getToArrayIsPlainObjectArrayMethod ( ) { return getMethod ( CollectionToArrayTester . class , \"testToArray_isPlainObjectArray\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void differentlyOverriddenNotAnnotatedInSubclass ( Object o ) { differentlyOverriddenNotAnnotatedInSubclassGoodEvents . add ( o ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testIndexOf_consumedData ( ) { Iterator < String > iterator = Lists . newArrayList ( \"manny\" , \"mo\" , \"jack\" ) . iterator ( ) ; assertEquals ( 1 , Iterators . indexOf ( iterator , equalTo ( \"mo\" ) ) ) ; assertEquals ( \"jack\" , iterator . next ( ) ) ; assertFalse ( iterator . hasNext ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static ImmutableList < URL > getClassLoaderUrls ( ClassLoader classloader ) { if ( classloader instanceof URLClassLoader ) { return ImmutableList . copyOf ( ( ( URLClassLoader ) classloader ) . getURLs ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSetCountOneToZeroConcurrentWithEntrySetIteration ( ) { Iterator < Entry < E > > iterator = getMultiset ( ) . entrySet ( ) . iterator ( ) ; assertSetCount ( e0 ( ) , 0 ) ; assertThrows ( ConcurrentModificationException . class , iterator::next ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public V getValue ( ) { return ArrayMap . this . getValue ( index ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E extends @Nullable Object > Function < @Nullable Object , E > constant ( @ParametricNullness E value ) { return new ConstantFunction < > ( value ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public LongAddable get ( ) { return new PureJavaLongAddable ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testComposition_includeReserializabled ( ) { Map < String , Integer > mJapaneseToInteger = new HashMap < > ( ) ; mJapaneseToInteger . put ( \"Ichi\" , 1 ) ; mJapaneseToInteger . put ( \"Ni\" , 2 ) ; mJapaneseToInteger . put ( \"San\" , 3 ) ; Function < String , Integer > japaneseToInteger = Functions . forMap ( mJapaneseToInteger ) ; Map < Integer , String > mIntegerToSpanish = new HashMap < > ( ) ; mIntegerToSpanish . put ( 1 , \"Uno\" ) ; mIntegerToSpanish . put ( 3 , \"Tres\" ) ; mIntegerToSpanish . put ( 4 , \"Cuatro\" ) ; Function < Integer , String > integerToSpanish = Functions . forMap ( mIntegerToSpanish ) ; Function < String , String > japaneseToSpanish = Functions . compose ( integerToSpanish , japaneseToInteger ) ; new EqualsTester ( ) . addEqualityGroup ( japaneseToSpanish , Functions . compose ( integerToSpanish , japaneseToInteger ) , SerializableTester . reserialize ( japaneseToSpanish ) ) . addEqualityGroup ( japaneseToInteger ) . addEqualityGroup ( integerToSpanish ) . addEqualityGroup ( Functions . compose ( japaneseToInteger , integerToSpanish ) ) . testEquals ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean remove ( @Nullable Object o ) { if ( o instanceof Cell ) { Cell < ? , ? , ? > cell = ( Cell < ? , ? , ? > ) o ; Map < C , V > row = safeGet ( rowMap ( ) , cell . getRowKey ( ) ) ; return row ! = null & & Collections2 . safeRemove ( row . entrySet ( ) , immutableEntry ( cell . getColumnKey ( ) , cell . getValue ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ElementOrder < N > incidentEdgeOrder ( ) { return delegate ( ) . incidentEdgeOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void addEdge_selfLoop_notAllowed ( ) { assume ( ) . that ( graphIsMutable ( ) ) . isTrue ( ) ; assume ( ) . that ( network . allowsSelfLoops ( ) ) . isFalse ( ) ; IllegalArgumentException e = assertThrows ( IllegalArgumentException . class , ( ) - > networkAsMutableNetwork . addEdge ( N1 , N1 , E11 ) ) ; assertThat ( e ) . hasMessageThat ( ) . contains ( ERROR_SELF_LOOP ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < N > boolean hasCycle ( Graph < N > graph ) { int numEdges = graph . edges ( ) . size ( ) ; if ( numEdges = = 0 ) { return false ; / / An edge - free graph is acyclic by definition .",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > of ( E e1 ) { return new RegularImmutableSortedSet < > ( ImmutableList . of ( e1 ) , Ordering . natural ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public BiMap < V , K > inverse ( ) { return inverse ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testAddCallback ( ) { FluentFuture < String > f = FluentFuture . from ( immediateFuture ( \"a\" ) ) ; boolean[] called = new boolean[1] ; f . addCallback ( new FutureCallback < String > ( ) { @Override public void onSuccess ( String result ) { called[0] = true ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCapacityForLargeSizes ( ) { int[] largeExpectedSizes = new int[] { Integer . MAX_VALUE / 2 - 1 , Integer . MAX_VALUE / 2 , Integer . MAX_VALUE / 2 + 1 , Integer . MAX_VALUE - 1 , Integer . MAX_VALUE",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Comparator < Electronics > topLevelClassIsNotSupertypeDueToTypeParameter ( Mall < Indoor > . Retailer < Grocery > shop ) { return notSubtype ( shop ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testOf ( ) { assertEquals ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , Lists . newArrayList ( FluentIterable . of ( 1 , 2 , 3 , 4 ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void stopping ( State from ) { ServiceManagerState state = this . state . get ( ) ; if ( state ! = null ) { state . transitionService ( service , from , STOPPING ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testNewCOWALFromIterable ( ) { CopyOnWriteArrayList < Integer > list = Lists . newCopyOnWriteArrayList ( SOME_ITERABLE ) ; assertEquals ( SOME_COLLECTION , list ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public SortedSet < V > replaceValues ( @ParametricNullness K key , Iterable < ? extends V > values ) { return delegate ( ) . replaceValues ( key , values ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testForMapAsMap ( ) { Map < String , Integer > map = new HashMap < > ( ) ; map . put ( \"foo\" , 1 ) ; map . put ( \"bar\" , 2 ) ; Map < String , Collection < Integer > > asMap = Multimaps . forMap ( map ) . asMap ( ) ; assertEquals ( singleton ( 1 ) , asMap . get ( \"foo\" ) ) ; assertThat ( asMap . get ( \"cow\" ) ) . isNull ( ) ; assertTrue ( asMap . containsKey ( \"foo\" ) ) ; assertFalse ( asMap . containsKey ( \"cow\" ) ) ; Set < Entry < String , Collection < Integer > > > entries = asMap . entrySet ( ) ; assertFalse ( entries . contains ( ( Object ) 4 . 5 ) ) ; assertFalse ( entries . remove ( ( Object ) 4 . 5 ) ) ; assertFalse ( entries . contains ( Maps . immutableEntry ( \"foo\" , singletonList ( 1 ) ) ) ) ; assertFalse ( entries . remove ( Maps . immutableEntry ( \"foo\" , singletonList ( 1 ) ) ) ) ; assertFalse ( entries . contains ( Maps . immutableEntry ( \"foo\" , new LinkedHashSet < > ( asList ( 1 , 2 ) ) ) ) ) ; assertFalse ( entries . remove ( Maps . immutableEntry ( \"foo\" , new LinkedHashSet < > ( asList ( 1 , 2 ) ) ) ) ) ; assertFalse ( entries . contains ( Maps . immutableEntry ( \"foo\" , singleton ( 2 ) ) ) ) ; assertFalse ( entries . remove ( Maps . immutableEntry ( \"foo\" , singleton ( 2 ) ) ) ) ; assertTrue ( map . containsKey ( \"foo\" ) ) ; assertTrue ( entries . contains ( Maps . immutableEntry ( \"foo\" , singleton ( 1 ) ) ) ) ; assertTrue ( entries . remove ( Maps . immutableEntry ( \"foo\" , singleton ( 1 ) ) ) ) ; assertFalse ( map . containsKey ( \"foo\" ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Iterator < Entry < String , String > > iterator ( ) { return new Iterator < Entry < String , String > > ( ) { final Iterator < Entry < String , String > > iterator = map . entrySet ( ) . iterator ( ) ; @Override public void remove ( ) { iterator . remove ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static RuntimeException propagate ( Throwable throwable ) { throwIfUnchecked ( throwable ) ; throw new RuntimeException ( throwable ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEqualsNull ( ) { assertEquals ( control ( NK , 1 ) , entry ( NK , 1 ) ) ; assertEquals ( control ( \"bar\" , NV ) , entry ( \"bar\" , NV ) ) ; assertFalse ( control ( NK , 1 ) . equals ( entry ( NK , 2 ) ) ) ; assertFalse ( entry ( NK , 1 ) . equals ( control ( \"bar\" , 1 ) ) ) ; assertFalse ( entry ( NK , 1 ) . equals ( new Object ( ) ) ) ; assertFalse ( entry ( NK , 1 ) . equals ( null ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int indexOf ( @Nullable Object target ) { / / Overridden to prevent a ton of boxing if ( target instanceof Short ) { int i = Shorts . indexOf ( array , ( Short ) target , start , end ) ; if ( i > = 0 ) { return i - start ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private long times2ToThe32Mod ( long a , long m ) { int remainingPowersOf2 = 32 ; do { int shift = min ( remainingPowersOf2 , Long . numberOfLeadingZeros ( a ) ) ; / / shift is either the number of powers of 2 left to multiply a by , or the biggest shift / / possible while keeping a in an unsigned long . a = UnsignedLongs . remainder ( a < < shift , m ) ; remainingPowersOf2 - = shift ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testIsEqualToNull_serialization ( ) { checkSerialization ( Predicates . equalTo ( null ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static int hashCode ( byte value ) { return value ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCopyOf_iterable_notCollection_nonempty ( ) { List < Double > list = Arrays . asList ( 0 . 0 , 1 . 0 , 3 . 0 ) ; ImmutableDoubleArray iia = ImmutableDoubleArray . copyOf ( iterable ( list ) ) ; list . set ( 2 , 2 . 0 ) ; assertThat ( iia . asList ( ) ) . containsExactly ( 0 . 0 , 1 . 0 , 3 . 0 ) . inOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static float min ( float . . . array ) { checkArgument ( array . length > 0 ) ; float min = array[0] ; for ( int i = 1 ; i < array . length ; i + + ) { min = Math . min ( min , array[i] ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCreate_invalidType ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > MediaType . create ( \"te > < t\" , \"plaintext\" ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testComputeIfPresent_supportedPresent ( ) { assertEquals ( \"computeIfPresent ( present , function ) should return new value\" , v3 ( ) , getMap ( ) . computeIfPresent ( k0 ( ) , ( k , v ) - > { assertEquals ( k0 ( ) , k ) ; assertEquals ( v0 ( ) , v ) ; return v3 ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testStream ( ) { ImmutableIntArray . of ( ) . stream ( ) . forEach ( i - > fail ( ) ) ; ImmutableIntArray . of ( 0 , 1 , 3 ) . subArray ( 1 , 1 ) . stream ( ) . forEach ( i - > fail ( ) ) ; assertThat ( ImmutableIntArray . of ( 0 , 1 , 3 ) . stream ( ) . toArray ( ) ) . isEqualTo ( new int[] { 0 , 1 , 3",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void declaredIn1AnnotatedInClass ( Object o ) { declaredIn1AnnotatedInClassEvents . add ( o ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public < E extends Enum < E > > void testVisitRecursiveTypeBounds ( ) { Type type = new TypeCapture < EnumSet < E > > ( ) {",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRoundToDoubleAgainstBigIntegerUnnecessary ( ) { for ( long candidate : roundToDoubleTestCandidates ) { Double expectedDouble = null ; try { expectedDouble = BigIntegerMath . roundToDouble ( BigInteger . valueOf ( candidate ) , UNNECESSARY ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < V > values ( ) { Set < V > result = valueSet ; return ( result = = null ) ? valueSet = new ValueSet ( ) : result ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testToJavaUtil_static ( ) { assertThat ( Optional . toJavaUtil ( null ) ) . isNull ( ) ; assertEquals ( java . util . Optional . empty ( ) , Optional . toJavaUtil ( Optional . absent ( ) ) ) ; assertEquals ( java . util . Optional . of ( \"abc\" ) , Optional . toJavaUtil ( Optional . of ( \"abc\" ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ImmutableListMultimap < K , V > build ( ) { return ( ImmutableListMultimap < K , V > ) super . build ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testForEachEntry ( ) { List < Entry < E > > expected = new ArrayList < > ( getMultiset ( ) . entrySet ( ) ) ; List < Entry < E > > actual = new ArrayList < > ( ) ; getMultiset ( ) . forEachEntry ( ( element , count ) - > actual . add ( Multisets . immutableEntry ( element , count ) ) ) ; assertEqualIgnoringOrder ( expected , actual ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected String getKeyNotInPopulatedMap ( ) { return \"q\" ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Set < Entry < K , V > > createEntrySet ( ) { return Sets . filter ( unfiltered . entrySet ( ) , predicate ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected String doBackward ( String string ) { return \"backward\" ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected final V v1 ( ) { return e1 ( ) . getValue ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public SafeTreeMap ( ) { this ( new TreeMap < K , V > ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEntrySet_hashCode_size1 ( ) { assertEquals ( \"multiset . entrySet ( ) has incorrect hash code\" , 1 ^ e0 ( ) . hashCode ( ) , getMultiset ( ) . entrySet ( ) . hashCode ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected void triggerShutdown ( ) { exitRun . countDown ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testNewDataInput_normal ( ) { ByteArrayDataInput in = ByteStreams . newDataInput ( bytes ) ; assertEquals ( 0x12345678 , in . readInt ( ) ) ; assertEquals ( 0x76543210 , in . readInt ( ) ) ; assertThrows ( IllegalStateException . class , ( ) - > in . readInt ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRowMapValuesAreSorted ( ) { sortedTable = create ( \"foo\" , 1 , 'a' , \"bar\" , 1 , 'b' , \"foo\" , 3 , 'c' , \"dog\" , 2 , 'd' ) ; assertTrue ( sortedTable . rowMap ( ) . get ( \"foo\" ) instanceof SortedMap ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testHashCode ( ) { int unused = create ( ) . hashCode ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < E > incidentEdges ( N node ) { return nodeInvalidatableSet ( checkedConnections ( node ) . incidentEdges ( ) , node ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final String encode ( byte[] bytes , int off , int len ) { checkPositionIndexes ( off , off + len , bytes . length ) ; StringBuilder result = new StringBuilder ( maxEncodedSize ( len ) ) ; try { encodeTo ( result , bytes , off , len ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private Object readResolve ( ) { return INSTANCE ; / / preserve singleton property",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static InstantiableFactoryMethodChosen create ( NotInstantiable x ) { return new InstantiableFactoryMethodChosen ( x ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable Entry < K , V > higherEntry ( @ParametricNullness K key ) { return delegate ( ) . higherEntry ( key ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void immutableNetworkBuilder_putEdgeFromNodes ( ) { ImmutableNetwork < String , Integer > network = NetworkBuilder . directed ( ) . < String , Integer > immutable ( ) . addEdge ( \"A\" , \"B\" , 10 ) . build ( ) ; assertThat ( network . nodes ( ) ) . containsExactly ( \"A\" , \"B\" ) ; assertThat ( network . edges ( ) ) . containsExactly ( 10 ) ; assertThat ( network . incidentNodes ( 10 ) ) . isEqualTo ( EndpointPair . ordered ( \"A\" , \"B\" ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static void reverse ( int[] array ) { checkNotNull ( array ) ; reverse ( array , 0 , array . length ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testTryAcquireTimeoutSingleInterruptNoExpire ( ) { TimedSemaphore semaphore = TimedSemaphore . createWithDelay ( 50 ) ; requestInterruptIn ( 10 ) ; semaphore . tryAcquireSuccessfully ( LONG_DELAY_MS ) ; assertInterrupted ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < B , S extends B > ImmutableClassToInstanceMap < B > copyOf ( Map < ? extends Class < ? extends S > , ? extends S > map ) { if ( map instanceof ImmutableClassToInstanceMap ) { @SuppressWarnings ( \"rawtypes\" ) / / JDT - based J2KT Java frontend does not permit the direct cast Map rawMap = map ; @SuppressWarnings ( \"unchecked\" ) / / covariant casts safe ( unmodifiable ) ImmutableClassToInstanceMap < B > cast = ( ImmutableClassToInstanceMap < B > ) rawMap ; return cast ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCompound_static ( ) { Comparator < String > comparator = Ordering . compound ( ImmutableList . of ( byCharAt ( 0 ) , byCharAt ( 1 ) , byCharAt ( 2 ) , byCharAt ( 3 ) , byCharAt ( 4 ) , byCharAt ( 5 ) ) ) ; testComparator ( comparator , ImmutableList . of ( \"applesauce\" , \"apricot\" , \"artichoke\" , \"banality\" , \"banana\" , \"banquet\" , \"tangelo\" , \"tangerine\" ) ) ; reserializeAndAssert ( comparator ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCreateWithNull_supported ( ) { E[] array = createArrayWithNullElement ( ) ; collection = getSubjectGenerator ( ) . create ( array ) ; expectContents ( array ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testIgnoresEqual ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( 1 , 6 ) ) ; rangeSet . add ( Range . closed ( 1 , 6 ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . closed ( 1 , 6 ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . lessThan ( 1 ) , Range . greaterThan ( 6 ) ) . inOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Test testsForSingletonSet ( ) { return SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override public Set < String > create ( String[] elements ) { return singleton ( elements[0] ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ImmutableLongArray subArray ( int startIndex , int endIndex ) { Preconditions . checkPositionIndexes ( startIndex , endIndex , length ( ) ) ; return startIndex = = endIndex ? EMPTY : new ImmutableLongArray ( array , start + startIndex , start + endIndex ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Map . @Nullable Entry < K , V > pollLastEntry ( ) { synchronized ( mutex ) { return nullableSynchronizedEntry ( delegate ( ) . pollLastEntry ( ) , mutex ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected < E extends Comparable < ? super E > > Set < E > copyOf ( Iterable < ? extends E > elements ) { return ImmutableSet . copyOf ( elements ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void addEdge_orderMismatch ( ) { assume ( ) . that ( graphIsMutable ( ) ) . isTrue ( ) ; EndpointPair < Integer > endpoints = EndpointPair . unordered ( N1 , N2 ) ; IllegalArgumentException e = assertThrows ( IllegalArgumentException . class , ( ) - > networkAsMutableNetwork . addEdge ( endpoints , E12 ) ) ; assertThat ( e ) . hasMessageThat ( ) . contains ( ENDPOINTS_MISMATCH ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static void rotate ( char[] array , int distance ) { rotate ( array , distance , 0 , array . length ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public < T extends Enum < T > & Serializable > void testGetGenericSuperclass_typeVariable_boundIsFBoundedClass ( ) { assertEquals ( new TypeToken < Enum < T > > ( ) {",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ComputationException ( @Nullable Throwable cause ) { super ( cause ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testTrailingHighSurrogate ( ) { String test = \"abc\" + Character . MIN_HIGH_SURROGATE ; assertThrows ( IllegalArgumentException . class , ( ) - > escapeAsString ( NOP_ESCAPER , test ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > escapeAsString ( SIMPLE_ESCAPER , test ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final boolean isSubtypeOf ( Type supertype ) { checkNotNull ( supertype ) ; if ( supertype instanceof WildcardType ) { / / if 'supertype' is < ? super Foo > , 'this' can be: / / Foo , SubFoo , < ? extends Foo > . / / if 'supertype' is < ? extends Foo > , nothing is a subtype . return any ( ( ( WildcardType ) supertype ) . getLowerBounds ( ) ) . isSupertypeOf ( runtimeType ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected SortedSet < E > standardSubSet ( @ParametricNullness E fromElement , @ParametricNullness E toElement ) { return tailSet ( fromElement ) . headSet ( toElement ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public SortedSet < V > removeAll ( @Nullable Object key ) { return delegate ( ) . removeAll ( key ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testIsInstanceOf_serialization ( ) { checkSerialization ( Predicates . instanceOf ( Integer . class ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private void testSubMultisetEntrySet ( SubMultisetSpec spec ) { List < Entry < E > > entries = copyToList ( sortedMultiset . entrySet ( ) ) ; for ( int i = 0 ; i < entries . size ( ) ; i + + ) { List < Entry < E > > expected = spec . expectedEntries ( i , entries ) ; SortedMultiset < E > subMultiset = spec . subMultiset ( sortedMultiset , entries , i ) ; assertEquals ( expected , copyToList ( subMultiset . entrySet ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { return \"Suppliers . synchronizedSupplier ( \" + delegate + \" ) \" ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void testConcatOverflow ( int arraysDim1 , int arraysDim2 ) { assertThat ( ( long ) arraysDim1 * arraysDim2 ) . isNotEqualTo ( ( long ) ( arraysDim1 * arraysDim2 ) ) ; double[][] arrays = new double[arraysDim1][] ; / / it's shared to avoid using too much memory in tests double[] sharedArray = new double[arraysDim2] ; Arrays . fill ( arrays , sharedArray ) ; try { Doubles . concat ( arrays ) ; fail ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static byte max ( byte . . . array ) { checkArgument ( array . length > 0 ) ; byte max = array[0] ; for ( int i = 1 ; i < array . length ; i + + ) { if ( array[i] > max ) { max = array[i] ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final BiMap < String , String > create ( Object . . . entries ) { @SuppressWarnings ( \"unchecked\" ) Entry < String , String > [] array = ( Entry < String , String > [] ) new Entry < ? , ? > [entries . length] ; int i = 0 ; for ( Object o : entries ) { @SuppressWarnings ( \"unchecked\" ) Entry < String , String > e = ( Entry < String , String > ) o ; array[i + + ] = e ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static FluentIterable < MediaType > getConstants ( ) { return getConstantFields ( ) . transform ( new Function < Field , MediaType > ( ) { @Override public MediaType apply ( Field input ) { try { return ( MediaType ) input . get ( null ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String getSimpleName ( ) { int lastDollarSign = className . lastIndexOf ( '$' ) ; if ( lastDollarSign ! = - 1 ) { String innerClassName = className . substring ( lastDollarSign + 1 ) ; / / local and anonymous classes are prefixed with number ( 1 , 2 , 3 . . . ) , anonymous classes are / / entirely numeric whereas local classes have the user supplied name as a suffix return CharMatcher . inRange ( '0' , '9' ) . trimLeadingFrom ( innerClassName ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void forEach ( BiConsumer < ? super K , ? super V > action ) { checkNotNull ( action ) ; asMap ( ) . forEach ( ( key , valueCollection ) - > valueCollection . forEach ( value - > action . accept ( key , value ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static boolean isEmpty ( Object value ) { / / Put types estimated to be the most frequent first . if ( value instanceof CharSequence ) { return ( ( CharSequence ) value ) . length ( ) = = 0 ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSetExpireAfterAccess ( ) { long duration = 42 ; TimeUnit unit = SECONDS ; LocalCache < Object , Object > map = makeLocalCache ( createCacheBuilder ( ) . expireAfterAccess ( duration , unit ) ) ; assertThat ( map . expireAfterAccessNanos ) . isEqualTo ( unit . toNanos ( duration ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testGetCharset_utf16 ( ) { assertThat ( MediaType . parse ( \"text / plain ; charset = utf - 16\" ) . charset ( ) ) . hasValue ( UTF_16 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean hasNext ( ) { return true ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { return original + \" . negate ( ) \" ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void forTree_depthFirstPreOrder_twoTrees ( ) { Iterable < Character > result = Traverser . forTree ( TWO_TREES ) . depthFirstPreOrder ( 'a' ) ; assertEqualCharNodes ( result , \"ab\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean closed ( ) { return out . closed ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testColumnMissing ( ) { table = create ( \"foo\" , 1 , 'a' , \"bar\" , 1 , 'b' , \"foo\" , 3 , 'c' ) ; Map < String , Character > column = table . column ( 4 ) ; assertTrue ( column . isEmpty ( ) ) ; assertThrows ( UnsupportedOperationException . class , ( ) - > column . put ( \"foo\" , 'd' ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private ListIterationOnlyList ( List < E > realDelegate ) { this . realDelegate = realDelegate ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testExplicit_ordering ( ) { SortedSet < String > set = ImmutableSortedSet . orderedBy ( STRING_LENGTH ) . add ( \"in\" , \"the\" , \"quick\" , \"jumped\" , \"over\" , \"a\" ) . build ( ) ; assertThat ( set ) . containsExactly ( \"a\" , \"in\" , \"the\" , \"over\" , \"quick\" , \"jumped\" ) . inOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static < K extends @Nullable Object , V extends @Nullable Object > BiMap < K , V > filterFiltered ( FilteredEntryBiMap < K , V > map , Predicate < ? super Entry < K , V > > entryPredicate ) { Predicate < Entry < K , V > > predicate = Predicates . and ( map . predicate , entryPredicate ) ; return new FilteredEntryBiMap < > ( map . unfiltered ( ) , predicate ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { return entrySet ( ) . toString ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCompute_presentFunctionThrows ( ) { assertThrows ( SomeUncheckedException . class , ( ) - > getMap ( ) . compute ( k0 ( ) , ( k , v ) - > { assertEquals ( k0 ( ) , k ) ; assertEquals ( v0 ( ) , v ) ; throw new SomeUncheckedException ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Integer set ( int index , Integer element ) { checkElementIndex ( index , size ( ) ) ; int oldValue = array[start + index] ; / / checkNotNull for GWT ( do not optimize ) array[start + index] = checkNotNull ( element ) ; return oldValue ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String removeFrom ( CharSequence sequence ) { checkNotNull ( sequence ) ; return \"\" ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected NavigableMap < String , String > create ( Entry < String , String > [] entries ) { NavigableMap < String , String > map = new SafeTreeMap < > ( ) ; putEntries ( map , entries ) ; map . put ( \"banana\" , \"toast\" ) ; map . put ( \"eggplant\" , \"spam\" ) ; return Maps . filterValues ( map , FILTER_VALUES ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static PairedStats buildManyValuesPairedStats ( ) { PairedStatsAccumulator accumulator = createFilledPairedStatsAccumulator ( MANY_VALUES , OTHER_MANY_VALUES ) ; PairedStats stats = accumulator . snapshot ( ) ; accumulator . add ( 99 . 99 , 9999 . 9999 ) ; / / should do nothing to the snapshot return stats ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testTeredoAddress_nullServer ( ) { InetAddresses . TeredoInfo info = new InetAddresses . TeredoInfo ( null , null , 80 , 1000 ) ; assertEquals ( InetAddresses . forString ( \"0 . 0 . 0 . 0\" ) , info . getServer ( ) ) ; assertEquals ( InetAddresses . forString ( \"0 . 0 . 0 . 0\" ) , info . getClient ( ) ) ; assertEquals ( 80 , info . getPort ( ) ) ; assertEquals ( 1000 , info . getFlags ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Set < Integer > create ( Object . . . elements ) { ImmutableRangeSet . Builder < Integer > builder = ImmutableRangeSet . builder ( ) ; for ( Object o : elements ) { Integer i = ( Integer ) o ; builder . add ( Range . singleton ( i ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private int nextRandomKey ( ) { int a = random . nextInt ( max ) ; / * * For example , if concentration = 2 . 0 , the following takes the square root of * the uniformly - distributed random integer , then truncates any fractional * part , so higher integers would appear ( in this case linearly ) more often * than lower ones . * / return ( int ) Math . pow ( a , 1 . 0 / concentration ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public SortedSet < K > headSet ( @ParametricNullness K toElement ) { return ( SortedSet < K > ) headMap ( toElement ) . keySet ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable V computeIfPresent ( K key , BiFunction < ? super K , ? super @NonNull V , ? extends @Nullable V > remappingFunction ) { synchronized ( mutex ) { return delegate ( ) . computeIfPresent ( key , remappingFunction ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testTimeout ( ) { / / Create a service whose executor will never run its commands Service service = new AbstractExecutionThreadService ( ) { @Override protected void run ( ) throws Exception {",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void clear ( ) { SubRangeMap . this . clear ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Spliterator < E > spliterator ( ) { if ( needsAllocArrays ( ) ) { return Spliterators . spliterator ( new Object[0] , Spliterator . DISTINCT | Spliterator . ORDERED ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private UnmodifiableEntry ( Entry < K , V > delegate ) { this . delegate = checkNotNull ( delegate ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static double sqrt ( double value ) { * if ( value < 0 ) { * throw new IllegalArgumentException ( \"input is negative: \" + value ) ; *",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBase16LowerCase ( ) { BaseEncoding lowerCase = base16 ( ) . lowerCase ( ) ; assertThat ( lowerCase ) . isNotSameInstanceAs ( base16 ( ) ) ; assertThat ( lowerCase ) . isSameInstanceAs ( base16 ( ) . lowerCase ( ) ) ; testEncodingWithCasing ( lowerCase , \"foobar\" , \"666f6f626172\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testPadStart_somePadding ( ) { assertEquals ( \" - \" , Strings . padStart ( \"\" , 1 , ' - ' ) ) ; assertEquals ( \" - - \" , Strings . padStart ( \"\" , 2 , ' - ' ) ) ; assertEquals ( \" - x\" , Strings . padStart ( \"x\" , 2 , ' - ' ) ) ; assertEquals ( \" - - x\" , Strings . padStart ( \"x\" , 3 , ' - ' ) ) ; assertEquals ( \" - xx\" , Strings . padStart ( \"xx\" , 3 , ' - ' ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static void rotate ( byte[] array , int distance , int fromIndex , int toIndex ) { / / See Ints . rotate for more details about possible algorithms here . checkNotNull ( array ) ; checkPositionIndexes ( fromIndex , toIndex , array . length ) ; if ( array . length < = 1 ) { return ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testVerifyGetsCalled ( ) { TesterThatCountsCalls tester = new TesterThatCountsCalls ( ) ; tester . test ( ) ; assertEquals ( \"Should have verified once per stimulus executed\" , tester . numCallsToVerify , tester . numCallsToNewTargetIterator * STEPS ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testMergeSorted_pyramid ( ) { List < Iterable < Integer > > iterables = new LinkedList < > ( ) ; List < Integer > allIntegers = new ArrayList < > ( ) ; / / Creates iterators like: { {",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected String getKeyNotInPopulatedMap ( ) { return \"a\" ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private ListenableFuture < V > fullyFailedFuture ( Throwable t ) { return immediateFailedFuture ( t ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testOrderedValues ( ) { TreeMultimap < String , Integer > multimap = createPopulate ( ) ; assertThat ( multimap . values ( ) ) . containsExactly ( 1 , 3 , 7 , 2 , 6 , 0 , 4 ) . inOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public EqualsTester testEquals ( ) { RelationshipTester < Object > delegate = new RelationshipTester < > ( Equivalence . equals ( ) , \"Object#equals\" , \"Object#hashCode\" , itemReporter ) ; for ( List < Object > group : equalityGroups ) { delegate . addRelatedGroup ( group ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEquals ( Class < ? > cls ) { try { doTestEquals ( cls ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void foo ( HardToCreate ignored , String required ) { checkNotNull ( ignored ) ; checkNotNull ( required ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public List < V2 > removeAll ( @Nullable Object key ) { return transform ( ( K ) key , fromMultimap . removeAll ( key ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final double sum ( ) { return mean * count ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEntryEquals ( ) { Cell < String , Integer , Character > entry = immutableCell ( \"foo\" , 1 , 'a' ) ; new EqualsTester ( ) . addEqualityGroup ( entry , immutableCell ( \"foo\" , 1 , 'a' ) ) . addEqualityGroup ( immutableCell ( \"bar\" , 1 , 'a' ) ) . addEqualityGroup ( immutableCell ( \"foo\" , 2 , 'a' ) ) . addEqualityGroup ( immutableCell ( \"foo\" , 1 , 'b' ) ) . addEqualityGroup ( Tables . < @Nullable Object , @Nullable Object , @Nullable Object > immutableCell ( null , null , null ) ) . testEquals ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static void sortDescending ( char[] array , int fromIndex , int toIndex ) { checkNotNull ( array ) ; checkPositionIndexes ( fromIndex , toIndex , array . length ) ; Arrays . sort ( array , fromIndex , toIndex ) ; reverse ( array , fromIndex , toIndex ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void run ( ) { AbstractFuture < String > future = setFutureFuture . get ( ) ; setFutureSetSuccess . set ( currentFuture . get ( ) . setFuture ( future ) ) ; setFutureCompletionSuccess . set ( future . set ( \"hello - async - world\" ) ) ; awaitUnchecked ( barrier ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Map < String , Collection < Integer > > makeEmptyMap ( ) { return Multimaps . unmodifiableMultimap ( LinkedHashMultimap . < String , Integer > create ( ) ) . asMap ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Hasher newHasher ( ) { return new Crc32cHasher ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testContainsKey ( ) { try { super . testContainsKey ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void checkTryParse ( double expected , String input ) { assertThat ( Doubles . tryParse ( input ) ) . isEqualTo ( Double . valueOf ( expected ) ) ; assertThat ( input ) . matches ( Pattern . compile ( Doubles . FLOATING_POINT_PATTERN . pattern ( ) , Doubles . FLOATING_POINT_PATTERN . flags ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEntrySet ( ) { Map < K , V > map ; try { map = makePopulatedMap ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Builder addAll ( Iterable < Double > values ) { if ( values instanceof Collection ) { return addAll ( ( Collection < Double > ) values ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static long charToTwoUtf8Bytes ( char c ) { / / c has at most 11 bits return ( ( 0x3L < < 6 ) | ( c > > > 6 ) ) | ( ( 0x80 | ( 0x3F & c ) ) < < 8 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testFactorial0 ( ) { assertEquals ( BigInteger . ONE , BigIntegerMath . factorial ( 0 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { return \"Optional . of ( \" + reference + \" ) \" ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSampleCodeFine1 ( ) { Optional < Number > optionalInt = Optional . of ( ( Number ) 1 ) ; Number value = optionalInt . or ( 0 . 5 ) ; / / fine",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testNewParameterizedType_nonStaticLocalClass ( ) { class LocalClass < T > {",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ListenableFuture < Object > reload ( Object key , Object oldValue ) { return immediateFuture ( null ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private PostOrderNode < T > expand ( T t ) { return new PostOrderNode < > ( t , children ( t ) . iterator ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRoundToDouble_minPreciselyRepresentable ( ) { new RoundToDoubleTester ( BigDecimal . valueOf ( - 1L < < 53 ) ) . setExpectation ( - Math . pow ( 2 , 53 ) , RoundingMode . values ( ) ) . test ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final boolean anyMatch ( Predicate < ? super E > predicate ) { return Iterables . any ( getDelegate ( ) , predicate ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testContains ( ) { MinMaxPriorityQueue < Integer > mmHeap = MinMaxPriorityQueue . create ( ) ; mmHeap . addAll ( Lists . newArrayList ( 1 , 1 , 2 ) ) ; assertEquals ( 3 , mmHeap . size ( ) ) ; assertFalse ( \"Heap does not contain null\" , mmHeap . contains ( null ) ) ; assertFalse ( \"Heap does not contain 3\" , mmHeap . contains ( 3 ) ) ; assertFalse ( \"Heap does not contain 3\" , mmHeap . remove ( 3 ) ) ; assertEquals ( 3 , mmHeap . size ( ) ) ; assertTrue ( \"Heap is not intact after remove ( ) \" , mmHeap . isIntact ( ) ) ; assertTrue ( \"Heap contains two 1's\" , mmHeap . contains ( 1 ) ) ; assertTrue ( \"Heap contains two 1's\" , mmHeap . remove ( 1 ) ) ; assertTrue ( \"Heap contains 1\" , mmHeap . contains ( 1 ) ) ; assertTrue ( \"Heap contains 1\" , mmHeap . remove ( 1 ) ) ; assertFalse ( \"Heap does not contain 1\" , mmHeap . contains ( 1 ) ) ; assertTrue ( \"Heap contains 2\" , mmHeap . remove ( 2 ) ) ; assertEquals ( 0 , mmHeap . size ( ) ) ; assertFalse ( \"Heap does not contain anything\" , mmHeap . contains ( 1 ) ) ; assertFalse ( \"Heap does not contain anything\" , mmHeap . remove ( 2 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected SetTestSuiteBuilder < K > createDerivedKeySetSuite ( TestSetGenerator < K > keySetGenerator ) { return keySetGenerator instanceof TestSortedSetGenerator ? SortedSetTestSuiteBuilder . using ( ( TestSortedSetGenerator < K > ) keySetGenerator ) : SetTestSuiteBuilder . using ( keySetGenerator ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSaturatedSubtract ( ) { for ( long a : ALL_LONG_CANDIDATES ) { for ( long b : ALL_LONG_CANDIDATES ) { assertOperationEquals ( a , b , \"s - \" , saturatedCast ( valueOf ( a ) . subtract ( valueOf ( b ) ) ) , LongMath . saturatedSubtract ( a , b ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRemoveComputingValue ( ) { LocalCache < Object , Object > map = makeLocalCache ( createCacheBuilder ( ) . concurrencyLevel ( 1 ) . initialCapacity ( 1 ) . maximumSize ( SMALL_MAX_SIZE ) . expireAfterWrite ( 99999 , SECONDS ) . removalListener ( countingRemovalListener ( ) ) ) ; Segment < Object , Object > segment = map . segments[0] ; AtomicReferenceArray < ReferenceEntry < Object , Object > > table = segment . table ; assertThat ( table . length ( ) ) . isEqualTo ( 1 ) ; Object key = new Object ( ) ; int hash = map . hash ( key ) ; DummyEntry < Object , Object > entry = DummyEntry . create ( key , hash , null ) ; LoadingValueReference < Object , Object > valueRef = new LoadingValueReference < > ( ) ; entry . setValueReference ( valueRef ) ; / / absent assertThat ( segment . removeLoadingValue ( key , hash , valueRef ) ) . isFalse ( ) ; / / live table . set ( 0 , entry ) ; / / don't increment count ; this is used during computation assertThat ( segment . removeLoadingValue ( key , hash , valueRef ) ) . isTrue ( ) ; / / no notification sent with removeLoadingValue assertThat ( map . removalNotificationQueue . isEmpty ( ) ) . isTrue ( ) ; assertThat ( segment . count ) . isEqualTo ( 0 ) ; assertThat ( table . get ( 0 ) ) . isNull ( ) ; / / active Object value = new Object ( ) ; DummyValueReference < Object , Object > previousRef = DummyValueReference . create ( value ) ; valueRef = new LoadingValueReference < > ( previousRef ) ; entry . setValueReference ( valueRef ) ; table . set ( 0 , entry ) ; segment . count = 1 ; assertThat ( segment . removeLoadingValue ( key , hash , valueRef ) ) . isTrue ( ) ; assertThat ( table . get ( 0 ) ) . isSameInstanceAs ( entry ) ; assertThat ( segment . get ( key , hash ) ) . isSameInstanceAs ( value ) ; / / wrong value reference table . set ( 0 , entry ) ; DummyValueReference < Object , Object > otherValueRef = DummyValueReference . create ( value ) ; entry . setValueReference ( otherValueRef ) ; assertThat ( segment . removeLoadingValue ( key , hash , valueRef ) ) . isFalse ( ) ; entry . setValueReference ( valueRef ) ; assertThat ( segment . removeLoadingValue ( key , hash , valueRef ) ) . isTrue ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String collapseFrom ( CharSequence sequence , char replacement ) { return ( sequence . length ( ) = = 0 ) ? \"\" : String . valueOf ( replacement ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int getReloadCount ( ) { return countReload . get ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public AbstractMapsTransformValuesTest ( ) { super ( false , true , false , true , true ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private void reallyTestNoMatches ( CharMatcher matcher , CharSequence s ) { assertFalse ( matcher . matches ( s . charAt ( 0 ) ) ) ; assertEquals ( - 1 , matcher . indexIn ( s ) ) ; assertEquals ( - 1 , matcher . indexIn ( s , 0 ) ) ; assertEquals ( - 1 , matcher . indexIn ( s , 1 ) ) ; assertEquals ( - 1 , matcher . indexIn ( s , s . length ( ) ) ) ; try { matcher . indexIn ( s , s . length ( ) + 1 ) ; fail ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRemoveFromInverseRemovesFromForward ( ) { getMap ( ) . inverse ( ) . remove ( v0 ( ) ) ; expectMissing ( e0 ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testInvalidHashCode ( ) { Object a = new InvalidHashCodeObject ( 1 , 2 ) ; Object b = new InvalidHashCodeObject ( 1 , 2 ) ; equalsTester . addEqualityGroup ( a , b ) ; try { equalsTester . testEquals ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testNewDataOutput_writeChars ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; out . writeChars ( \"r\\u00C9sum\\u00C9\" ) ; / / need to remove byte order mark before comparing byte[] expected = Arrays . copyOfRange ( utf16ExpectedWithBom , 2 , 14 ) ; assertThat ( out . toByteArray ( ) ) . isEqualTo ( expected ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E > ImmutableList < E > copyOf ( Collection < ? extends E > elements ) { if ( elements instanceof ImmutableCollection ) { / * * TODO: When given an ImmutableList that's a sublist , copy the referenced * portion of the array into a new array to save space? * / @SuppressWarnings ( \"unchecked\" ) / / all supported methods are covariant ImmutableCollection < E > list = ( ImmutableCollection < E > ) elements ; return list . asList ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int count ( @Nullable Object element ) { return multiset1 . count ( element ) + multiset2 . count ( element ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Builder < E > add ( E element ) { contents . add ( checkNotNull ( element ) ) ; return this ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Iterator < T > iterator ( ) { return standardIterator ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBuilderPutNullKey ( ) { Builder < String , Integer > builder = ImmutableSortedMap . naturalOrder ( ) ; assertThrows ( NullPointerException . class , ( ) - > builder . put ( null , 1 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private Ordered ( N source , N target ) { super ( source , target ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void remove ( ) { checkRemove ( toRemove > = 0 ) ; if ( counts[toRemove] > 0 ) { distinctElements - - ; size - = counts[toRemove] ; counts[toRemove] = 0 ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testParseLongEmptyString ( ) { assertThrows ( NumberFormatException . class , ( ) - > UnsignedLongs . parseUnsignedLong ( \"\" ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public WeakKeyDummyValueEntry < K > newEntry ( WeakKeyDummyValueSegment < K > segment , K key , int hash , @Nullable WeakKeyDummyValueEntry < K > next ) { return next = = null ? new WeakKeyDummyValueEntry < > ( segment . queueForKeys , key , hash ) : new LinkedWeakKeyDummyValueEntry < > ( segment . queueForKeys , key , hash , next ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBasicDistribution ( ) { StringCatcher catcher = new StringCatcher ( ) ; bus . register ( catcher ) ; / / We post the event , but our Executor will not deliver it until instructed . bus . post ( EVENT ) ; List < String > events = catcher . getEvents ( ) ; assertTrue ( \"No events should be delivered synchronously . \" , events . isEmpty ( ) ) ; / / Now we find the task in our Executor and explicitly activate it . List < Runnable > tasks = executor . getTasks ( ) ; assertEquals ( \"One event dispatch task should be queued . \" , 1 , tasks . size ( ) ) ; tasks . get ( 0 ) . run ( ) ; assertEquals ( \"One event should be delivered . \" , 1 , events . size ( ) ) ; assertEquals ( \"Correct string should be delivered . \" , EVENT , events . get ( 0 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void close ( ) { closed = true ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public V rightValue ( ) { return right ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected List < Long > create ( Long[] elements ) { return makeArray ( elements ) . asList ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable Entry < K , V > lowerEntry ( K key ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate ( ) . lowerEntry ( key ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testOfNullKey ( ) { assertThrows ( NullPointerException . class , ( ) - > ImmutableMap . of ( null , 1 ) ) ; assertThrows ( NullPointerException . class , ( ) - > ImmutableMap . of ( \"one\" , 1 , null , 2 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable E pollFirst ( ) { return delegate ( ) . pollFirst ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBase32LenientPadding ( ) { testDecodes ( base32 ( ) , \"MZXW6\" , \"foo\" ) ; testDecodes ( base32 ( ) , \"MZXW6 = \" , \"foo\" ) ; testDecodes ( base32 ( ) , \"MZXW6 = = \" , \"foo\" ) ; testDecodes ( base32 ( ) , \"MZXW6 = = = \" , \"foo\" ) ; / / proper padding length testDecodes ( base32 ( ) , \"MZXW6 = = = = \" , \"foo\" ) ; testDecodes ( base32 ( ) , \"MZXW6 = = = = = \" , \"foo\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testHashCodeForBooleanOperations ( ) { Predicate < @Nullable Integer > p1 = Predicates . isNull ( ) ; Predicate < @Nullable Integer > p2 = isOdd ( ) ; / / Make sure that hash codes are not computed per - instance . assertEqualHashCode ( Predicates . not ( p1 ) , Predicates . not ( p1 ) ) ; assertEqualHashCode ( Predicates . and ( p1 , p2 ) , Predicates . and ( p1 , p2 ) ) ; assertEqualHashCode ( Predicates . or ( p1 , p2 ) , Predicates . or ( p1 , p2 ) ) ; / / While not a contractual requirement , we'd like the hash codes for ands / / & ors of the same predicates to not collide . assertTrue ( Predicates . and ( p1 , p2 ) . hashCode ( ) ! = Predicates . or ( p1 , p2 ) . hashCode ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable Map < R , V > get ( @Nullable Object key ) { / / requireNonNull is safe because of the containsColumn check . return containsColumn ( key ) ? column ( ( C ) requireNonNull ( key ) ) : null ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEqualsForEqualMap ( ) { Map < K , V > map ; try { map = makePopulatedMap ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void forTree_depthFirstPostOrderIterable_twoTrees ( ) { assertEqualCharNodes ( Traverser . forTree ( TWO_TREES ) . depthFirstPostOrder ( charactersOf ( \"a\" ) ) , \"ba\" ) ; assertEqualCharNodes ( Traverser . forTree ( TWO_TREES ) . depthFirstPostOrder ( charactersOf ( \"ca\" ) ) , \"dcba\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSampleStandardDeviation ( ) { assertThrows ( IllegalStateException . class , ( ) - > EMPTY_STATS_VARARGS . sampleStandardDeviation ( ) ) ; assertThrows ( IllegalStateException . class , ( ) - > EMPTY_STATS_ITERABLE . sampleStandardDeviation ( ) ) ; assertThrows ( IllegalStateException . class , ( ) - > ONE_VALUE_STATS . sampleStandardDeviation ( ) ) ; assertThat ( TWO_VALUES_STATS . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS ) ) ; assertThat ( MANY_VALUES_STATS_VARARGS . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - 1 ) ) ) ; assertThat ( MANY_VALUES_STATS_ITERABLE . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - 1 ) ) ) ; assertThat ( MANY_VALUES_STATS_ITERATOR . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - 1 ) ) ) ; assertThat ( MANY_VALUES_STATS_SNAPSHOT . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - 1 ) ) ) ; assertThat ( INTEGER_MANY_VALUES_STATS_VARARGS . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR * sqrt ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS ) ) . of ( sqrt ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( INTEGER_MANY_VALUES_COUNT - 1 ) ) ) ; assertThat ( INTEGER_MANY_VALUES_STATS_ITERABLE . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR * sqrt ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS ) ) . of ( sqrt ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( INTEGER_MANY_VALUES_COUNT - 1 ) ) ) ; assertThat ( LONG_MANY_VALUES_STATS_ITERATOR . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR * sqrt ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS ) ) . of ( sqrt ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( LONG_MANY_VALUES_COUNT - 1 ) ) ) ; assertThat ( LONG_MANY_VALUES_STATS_SNAPSHOT . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR * sqrt ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS ) ) . of ( sqrt ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( LONG_MANY_VALUES_COUNT - 1 ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testLegacyComparable_copyOf_iterator ( ) { ImmutableSortedSet < LegacyComparable > set = ImmutableSortedSet . copyOf ( LegacyComparable . VALUES_BACKWARD . iterator ( ) ) ; assertTrue ( elementsEqual ( LegacyComparable . VALUES_FORWARD , set ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void clear ( ) { value = null ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testMultimapEquals ( ) { Multimap < String , Integer > multimap = createMultimap ( ) ; Multimap < String , Integer > hashMultimap = HashMultimap . create ( ) ; hashMultimap . putAll ( \"foo\" , Arrays . asList ( 1 , 3 ) ) ; hashMultimap . put ( \"bar\" , 2 ) ; new EqualsTester ( ) . addEqualityGroup ( multimap , createMultimap ( ) , hashMultimap , ImmutableSetMultimap . < String , Integer > builder ( ) . put ( \"bar\" , 2 ) . put ( \"foo\" , 1 ) . put ( \"foo\" , 3 ) . build ( ) , ImmutableSetMultimap . < String , Integer > builder ( ) . put ( \"bar\" , 2 ) . put ( \"foo\" , 3 ) . put ( \"foo\" , 1 ) . build ( ) ) . addEqualityGroup ( ImmutableSetMultimap . < String , Integer > builder ( ) . put ( \"foo\" , 2 ) . put ( \"foo\" , 3 ) . put ( \"foo\" , 1 ) . build ( ) ) . addEqualityGroup ( ImmutableSetMultimap . < String , Integer > builder ( ) . put ( \"bar\" , 2 ) . put ( \"foo\" , 3 ) . build ( ) ) . testEquals ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSetCount_zeroToZero_removeSupported ( ) { assertZeroToZero ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean offerFirst ( @ParametricNullness E e ) { return delegate ( ) . offerFirst ( e ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void complete ( Error e ) { if ( ! super . setException ( new WrapperException ( checkNotNull ( e ) ) ) ) { throw new IllegalStateException ( \"Future was already complete: \" + this ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testGetOrDefault_presentMappedToNull ( ) { initMapWithNullValue ( ) ; assertNull ( \"getOrDefault ( mappedToNull , default ) should return null\" , getMap ( ) . getOrDefault ( getKeyForNullValue ( ) , v3 ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static < T > ImmutableList < Invokable < ? , ? extends T > > getFactories ( TypeToken < T > type ) { List < Invokable < ? , ? extends T > > factories = new ArrayList < > ( ) ; for ( Method method : type . getRawType ( ) . getDeclaredMethods ( ) ) { Invokable < ? , ? > invokable = type . method ( method ) ; if ( ! invokable . isPrivate ( ) & & ! invokable . isSynthetic ( ) & & invokable . isStatic ( ) & & type . isSupertypeOf ( invokable . getReturnType ( ) ) ) { @SuppressWarnings ( \"unchecked\" ) / / guarded by isAssignableFrom ( ) Invokable < ? , ? extends T > factory = ( Invokable < ? , ? extends T > ) invokable ; factories . add ( factory ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testToStringOmitNullValues_manyFieldsLastNull ( ) { String toTest = MoreObjects . toStringHelper ( new TestClass ( ) ) . omitNullValues ( ) . add ( \"field1\" , \"Hello\" ) . add ( \"field2\" , \"Googley\" ) . add ( \"field3\" , null ) . toString ( ) ; assertEquals ( \"TestClass { field1 = Hello , field2 = Googley",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testOpen_invalid ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Range . open ( 4 , 3 ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > Range . open ( 3 , 3 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testWriteBytesToUndersizedArrayLongMaxLength ( ) { byte[] dest = new byte[3] ; assertThrows ( IndexOutOfBoundsException . class , ( ) - > HASH_ABCD . writeBytesTo ( dest , 0 , 5 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBuildKeepingLast_collisions ( ) { Map < ClassWithTerribleHashCode , Integer > expected = new LinkedHashMap < > ( ) ; Builder < ClassWithTerribleHashCode , Integer > builder = new Builder < > ( ) ; int size = 18 ; for ( int i = 0 ; i < size ; i + + ) { ClassWithTerribleHashCode key = new ClassWithTerribleHashCode ( i ) ; builder . put ( key , i ) ; builder . put ( key , - i ) ; expected . put ( key , - i ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void overriddenInSubclassNowhereAnnotated ( Object o ) { super . overriddenInSubclassNowhereAnnotated ( o ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean isEmpty ( ) { return fromMultimap . isEmpty ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void terminated ( State from ) { service . stopAsync ( ) . awaitTerminated ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final ImmutableSortedMap < K , V > buildKeepingLast ( ) { / / TODO ( emcmanus ) : implement throw new UnsupportedOperationException ( \"ImmutableSortedMap . Builder does not yet implement buildKeepingLast ( ) \" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testKeySetIteration ( ) { new IteratorTester < String > ( 6 , MODIFIABLE , new LinkedHashSet < > ( asList ( \"foo\" , \"bar\" , \"baz\" , \"dog\" , \"cat\" ) ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { private @Nullable SetMultimap < String , Integer > multimap ; @Override protected Iterator < String > newTargetIterator ( ) { multimap = LinkedHashMultimap . create ( ) ; multimap . putAll ( \"foo\" , asList ( 2 , 3 ) ) ; multimap . putAll ( \"bar\" , asList ( 4 , 5 ) ) ; multimap . putAll ( \"foo\" , asList ( 6 ) ) ; multimap . putAll ( \"baz\" , asList ( 7 , 8 ) ) ; multimap . putAll ( \"dog\" , asList ( 9 ) ) ; multimap . putAll ( \"bar\" , asList ( 10 , 11 ) ) ; multimap . putAll ( \"cat\" , asList ( 12 , 13 , 14 ) ) ; return multimap . keySet ( ) . iterator ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Collection < Method > suppressForLinkedBlockingDeque ( ) { return emptySet ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testInterfaceStaticMethod ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicStaticMethods ( InterfaceStaticMethodChecksNull . class ) ; try { tester . testAllPublicStaticMethods ( InterfaceStaticMethodFailsToCheckNull . class ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void assertCastFails ( long value ) { try { SignedBytes . checkedCast ( value ) ; fail ( \"Cast to byte should have failed: \" + value ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < E extends @Nullable Object > CompactLinkedHashSet < E > create ( Collection < ? extends E > collection ) { CompactLinkedHashSet < E > set = createWithExpectedSize ( collection . size ( ) ) ; set . addAll ( collection ) ; return set ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testSize ( ) { for ( ImmutableTable < Character , Integer , String > testInstance : getTestInstances ( ) ) { assertEquals ( 3 , testInstance . size ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testVerifyNotNull_complexMessage_success ( ) { String result = verifyNotNull ( NON_NULL_STRING , \"%s\" , IGNORE_ME ) ; assertSame ( NON_NULL_STRING , result ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testFirstMatch ( ) { FluentIterable < String > iterable = FluentIterable . from ( Lists . newArrayList ( \"cool\" , \"pants\" ) ) ; assertThat ( iterable . firstMatch ( equalTo ( \"cool\" ) ) ) . hasValue ( \"cool\" ) ; assertThat ( iterable . firstMatch ( equalTo ( \"pants\" ) ) ) . hasValue ( \"pants\" ) ; assertThat ( iterable . firstMatch ( Predicates . alwaysFalse ( ) ) ) . isAbsent ( ) ; assertThat ( iterable . firstMatch ( Predicates . alwaysTrue ( ) ) ) . hasValue ( \"cool\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Hasher putString ( CharSequence chars , Charset charset ) { for ( Hasher hasher : hashers ) { hasher . putString ( chars , charset ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public List < Character > create ( Object . . . elements ) { Character[] array = new Character[elements . length] ; int i = 0 ; for ( Object e : elements ) { array[i + + ] = ( Character ) e ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testPatternSplitOnOnlyDelimiter ( ) { Iterable < String > blankblank = Splitter . on ( literalDotPattern ( ) ) . split ( \" . \" ) ; assertThat ( blankblank ) . containsExactly ( \"\" , \"\" ) . inOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void clear ( ) { remove ( Range . all ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEquals ( ) { Multimap < Integer , String > map1 = ImmutableMultimap . of ( 1 , \"one\" ) ; Multimap < Integer , String > map2 = ImmutableMultimap . of ( 2 , \"two\" ) ; new EqualsTester ( ) . addEqualityGroup ( map1 , wrap ( map1 ) , wrap ( map1 ) ) . addEqualityGroup ( map2 , wrap ( map2 ) ) . testEquals ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean containsEntry ( @Nullable Object key , @Nullable Object value ) { return map . entrySet ( ) . contains ( Maps . immutableEntry ( key , value ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static boolean tryAcquireUninterruptibly ( Semaphore semaphore , long timeout , TimeUnit unit ) { return tryAcquireUninterruptibly ( semaphore , 1 , timeout , unit ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < T extends @Nullable Object > T getOnlyElement ( Iterator < T > iterator ) { T first = iterator . next ( ) ; if ( ! iterator . hasNext ( ) ) { return first ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testForMapWithDefault_null ( ) { ImmutableMap < String , Integer > map = ImmutableMap . of ( \"One\" , 1 ) ; Function < String , @Nullable Integer > function = Functions . forMap ( map , null ) ; assertEquals ( ( Integer ) 1 , function . apply ( \"One\" ) ) ; assertThat ( function . apply ( \"Two\" ) ) . isNull ( ) ; / / check basic sanity of equals and hashCode new EqualsTester ( ) . addEqualityGroup ( function ) . addEqualityGroup ( Functions . forMap ( map , 1 ) ) . testEquals ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected SortedSet < E > delegate ( ) { return unmodifiableDelegate ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testGetLast_withDefault_empty_null ( ) { Iterator < String > iterator = emptyIterator ( ) ; assertThat ( Iterators . < @Nullable String > getLast ( iterator , null ) ) . isNull ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testGenerics_gwtCompatible ( ) { ListMultimap < String , Integer > unusedA = MultimapBuilder . hashKeys ( ) . arrayListValues ( ) . < String , Integer > build ( ) ; SortedSetMultimap < String , Integer > unusedB = rawtypeToWildcard ( MultimapBuilder . linkedHashKeys ( ) . treeSetValues ( ) ) . < String , Integer > build ( ) ; SetMultimap < String , Integer > unusedC = MultimapBuilder . treeKeys ( String . CASE_INSENSITIVE_ORDER ) . hashSetValues ( ) . < String , Integer > build ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public NavigableSet < K > descendingKeySet ( ) { synchronized ( mutex ) { if ( descendingKeySet = = null ) { return descendingKeySet = Synchronized . navigableSet ( delegate ( ) . descendingKeySet ( ) , mutex ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { return MoreObjects . toStringHelper ( this ) . addValue ( toParsableString ( ) ) . toString ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static int divide ( int dividend , int divisor ) { return ( int ) ( toLong ( dividend ) / toLong ( divisor ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public E getLast ( ) { synchronized ( mutex ) { return delegate ( ) . getLast ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int hashCode ( ) { return s . hashCode ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBuilderSetCountZero ( ) { ImmutableSortedMultiset < String > multiset = ImmutableSortedMultiset . < String > naturalOrder ( ) . add ( \"a\" ) . setCount ( \"a\" , 2 ) . setCount ( \"b\" , 3 ) . setCount ( \"a\" , 0 ) . build ( ) ; assertEquals ( HashMultiset . create ( asList ( \"b\" , \"b\" , \"b\" ) ) , multiset ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static void lockStateChanged ( CycleDetectingLock lock ) { if ( ! lock . isAcquiredByCurrentThread ( ) ) { / / requireNonNull accommodates Android's @RecentlyNullable annotation on ThreadLocal . get List < LockGraphNode > acquiredLockList = requireNonNull ( acquiredLocks . get ( ) ) ; LockGraphNode node = lock . getLockGraphNode ( ) ; / / Iterate in reverse because locks are usually locked / unlocked in a / / LIFO order . for ( int i = acquiredLockList . size ( ) - 1 ; i > = 0 ; i - - ) { if ( acquiredLockList . get ( i ) = = node ) { acquiredLockList . remove ( i ) ; break ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static double ensureInUnitRange ( double value ) { return Doubles . constrainToRange ( value , - 1 . 0 , 1 . 0 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Mall < Outdoor > . Shop < Electronics > ownerTypeDoesNotMatch_subtypeWithWildcard ( Mall < ? extends Outdoor > . Shop < Electronics > shop ) { return notSubtype ( shop ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public < N1 extends N > ValueGraphBuilder < N1 , V > incidentEdgeOrder ( ElementOrder < N1 > incidentEdgeOrder ) { checkArgument ( incidentEdgeOrder . type ( ) = = ElementOrder . Type . UNORDERED | | incidentEdgeOrder . type ( ) = = ElementOrder . Type . STABLE , \"The given elementOrder ( %s ) is unsupported . incidentEdgeOrder ( ) only supports\" + \" ElementOrder . unordered ( ) and ElementOrder . stable ( ) . \" , incidentEdgeOrder ) ; ValueGraphBuilder < N1 , V > newBuilder = cast ( ) ; newBuilder . incidentEdgeOrder = checkNotNull ( incidentEdgeOrder ) ; return newBuilder ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static < K , V > ImmutableListMultimap < K , V > of ( K k1 , V v1 , K k2 , V v2 ) { ImmutableListMultimap . Builder < K , V > builder = ImmutableListMultimap . builder ( ) ; builder . put ( k1 , v1 ) ; builder . put ( k2 , v2 ) ; return builder . build ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testPutAll_nullKeySupported ( ) { putAll ( containsNullKey ) ; expectAdded ( containsNullKey . get ( 0 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public MonitorBasedArrayBlockingQueue ( int capacity ) { this ( capacity , false ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Type[] getActualTypeArguments ( ) { return new Type[] { new TypeCapture < P > ( ) {",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void test ( ) { * SomeClass . foo ( ) ; * LogRecord firstRecord = handler . getStoredLogRecords ( ) . get ( 0 ) ; * assertEquals ( \"some message\" , firstRecord . getMessage ( ) ) ; *",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testPutIfAbsent_unsupportedAbsent ( ) { assertThrows ( UnsupportedOperationException . class , ( ) - > getMap ( ) . putIfAbsent ( k3 ( ) , v3 ( ) ) ) ; expectUnchanged ( ) ; expectMissing ( e3 ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testZeroDivIsAlwaysZero ( ) { for ( int q : NONZERO_INTEGER_CANDIDATES ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { assertEquals ( 0 , IntMath . divide ( 0 , q , mode ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public long getDelay ( TimeUnit unit ) { throw new UnsupportedOperationException ( \"test should not care about this\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Map < Range < Comparable < ? > > , Object > asDescendingMapOfRanges ( ) { return emptyMap ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static Stats of ( Iterable < ? extends Number > values ) { StatsAccumulator accumulator = new StatsAccumulator ( ) ; accumulator . addAll ( values ) ; return accumulator . snapshot ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testFromByteArray ( ) { assertThat ( Shorts . fromByteArray ( new byte[] { 0x23 , 0x45",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testWriteLock_threeLockDeadLock ( ) { / / Establish an ordering from writeLockA - > writeLockB . writeLockA . lock ( ) ; writeLockB . lock ( ) ; writeLockB . unlock ( ) ; writeLockA . unlock ( ) ; / / Establish an ordering from writeLockB - > writeLockC . writeLockB . lock ( ) ; writeLockC . lock ( ) ; writeLockB . unlock ( ) ; / / writeLockC - > writeLockA should fail . PotentialDeadlockException expected = assertThrows ( PotentialDeadlockException . class , ( ) - > writeLockA . lock ( ) ) ; checkMessage ( expected , \"ReadWriteC - > ReadWriteA\" , \"ReadWriteB - > ReadWriteC\" , \"ReadWriteA - > ReadWriteB\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static HostAndPort fromHost ( String host ) { HostAndPort parsedHost = fromString ( host ) ; checkArgument ( ! parsedHost . hasPort ( ) , \"Host has a port: %s\" , host ) ; return parsedHost ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testLoadCheckedException ( ) { Exception e = new Exception ( ) ; CacheLoader < Object , Object > loader = exceptionLoader ( e ) ; LoadingCache < Object , Object > cache = CacheBuilder . newBuilder ( ) . recordStats ( ) . build ( loader ) ; CacheStats stats = cache . stats ( ) ; assertThat ( stats . missCount ( ) ) . isEqualTo ( 0 ) ; assertThat ( stats . loadSuccessCount ( ) ) . isEqualTo ( 0 ) ; assertThat ( stats . loadExceptionCount ( ) ) . isEqualTo ( 0 ) ; assertThat ( stats . hitCount ( ) ) . isEqualTo ( 0 ) ; Exception expected = assertThrows ( ExecutionException . class , ( ) - > cache . get ( new Object ( ) ) ) ; assertThat ( expected ) . hasCauseThat ( ) . isSameInstanceAs ( e ) ; stats = cache . stats ( ) ; assertThat ( stats . missCount ( ) ) . isEqualTo ( 1 ) ; assertThat ( stats . loadSuccessCount ( ) ) . isEqualTo ( 0 ) ; assertThat ( stats . loadExceptionCount ( ) ) . isEqualTo ( 1 ) ; assertThat ( stats . hitCount ( ) ) . isEqualTo ( 0 ) ; expected = assertThrows ( UncheckedExecutionException . class , ( ) - > cache . getUnchecked ( new Object ( ) ) ) ; assertThat ( expected ) . hasCauseThat ( ) . isSameInstanceAs ( e ) ; stats = cache . stats ( ) ; assertThat ( stats . missCount ( ) ) . isEqualTo ( 2 ) ; assertThat ( stats . loadSuccessCount ( ) ) . isEqualTo ( 0 ) ; assertThat ( stats . loadExceptionCount ( ) ) . isEqualTo ( 2 ) ; assertThat ( stats . hitCount ( ) ) . isEqualTo ( 0 ) ; cache . refresh ( new Object ( ) ) ; checkLoggedCause ( e ) ; stats = cache . stats ( ) ; assertThat ( stats . missCount ( ) ) . isEqualTo ( 2 ) ; assertThat ( stats . loadSuccessCount ( ) ) . isEqualTo ( 0 ) ; assertThat ( stats . loadExceptionCount ( ) ) . isEqualTo ( 3 ) ; assertThat ( stats . hitCount ( ) ) . isEqualTo ( 0 ) ; Exception callableException = new Exception ( ) ; expected = assertThrows ( ExecutionException . class , ( ) - > cache . get ( new Object ( ) , throwing ( callableException ) ) ) ; assertThat ( expected ) . hasCauseThat ( ) . isSameInstanceAs ( callableException ) ; stats = cache . stats ( ) ; assertThat ( stats . missCount ( ) ) . isEqualTo ( 3 ) ; assertThat ( stats . loadSuccessCount ( ) ) . isEqualTo ( 0 ) ; assertThat ( stats . loadExceptionCount ( ) ) . isEqualTo ( 4 ) ; assertThat ( stats . hitCount ( ) ) . isEqualTo ( 0 ) ; expected = assertThrows ( ExecutionException . class , ( ) - > cache . getAll ( asList ( new Object ( ) ) ) ) ; assertThat ( expected ) . hasCauseThat ( ) . isSameInstanceAs ( e ) ; stats = cache . stats ( ) ; assertThat ( stats . missCount ( ) ) . isEqualTo ( 4 ) ; assertThat ( stats . loadSuccessCount ( ) ) . isEqualTo ( 0 ) ; assertThat ( stats . loadExceptionCount ( ) ) . isEqualTo ( 5 ) ; assertThat ( stats . hitCount ( ) ) . isEqualTo ( 0 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testPut_unsupportedPresentDifferentValue ( ) { assertThrows ( UnsupportedOperationException . class , ( ) - > getMap ( ) . put ( k0 ( ) , v3 ( ) ) ) ; expectUnchanged ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRetainAll_nullSingletonPreviouslyEmpty ( ) { expectReturnsFalse ( nullSingleton ) ; expectUnchanged ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public M create ( Object . . . elements ) { Multimap < String , String > multimap = ArrayListMultimap . create ( ) ; for ( Object o : elements ) { @SuppressWarnings ( \"unchecked\" ) Entry < String , String > entry = ( Entry < String , String > ) o ; multimap . put ( entry . getKey ( ) , Ascii . toUpperCase ( entry . getValue ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void merge ( Range < K > range , @Nullable V value , BiFunction < ? super V , ? super @Nullable V , ? extends @Nullable V > remappingFunction ) { checkNotNull ( range ) ; checkNotNull ( remappingFunction ) ; if ( range . isEmpty ( ) ) { return ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testAddOccurrencesZero ( ) { int originalCount = getMultiset ( ) . count ( e0 ( ) ) ; assertEquals ( \"old count\" , originalCount , getMultiset ( ) . add ( e0 ( ) , 0 ) ) ; expectUnchanged ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public @Nullable Void call ( ) { if ( currentFuture . get ( ) . setFuture ( future ) ) { numSuccessfulSetCalls . incrementAndGet ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testReserializeWholeSubList ( ) { SerializableTester . reserializeAndAssert ( getList ( ) . subList ( 0 , getNumElements ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ContiguousSet < C > tailSet ( C fromElement ) { return tailSetImpl ( checkNotNull ( fromElement ) , true ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testMapWithIndex_intStream_closeIsPropagated_unsized ( ) { checkMapWithIndexIntStreamCloseIsPropagated ( IntStream . of ( 0 ) . flatMap ( unused - > IntStream . of ( 1 , 2 , 3 ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ListenableScheduledFuture < ? > schedule ( Runnable command , long delay , TimeUnit unit ) { return NeverScheduledFuture . create ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static int log2 ( BigInteger x , RoundingMode mode ) { checkPositive ( \"x\" , checkNotNull ( x ) ) ; int logFloor = x . bitLength ( ) - 1 ; switch ( mode ) { case UNNECESSARY: checkRoundingUnnecessary ( isPowerOfTwo ( x ) ) ; / / fall through case DOWN: case FLOOR: return logFloor ; case UP: case CEILING: return isPowerOfTwo ( x ) ? logFloor : logFloor + 1 ; case HALF_DOWN: case HALF_UP: case HALF_EVEN: if ( logFloor < SQRT2_PRECOMPUTE_THRESHOLD ) { BigInteger halfPower = SQRT2_PRECOMPUTED_BITS . shiftRight ( SQRT2_PRECOMPUTE_THRESHOLD - logFloor ) ; if ( x . compareTo ( halfPower ) < = 0 ) { return logFloor ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static HashFunction farmHashFingerprint64 ( ) { return FarmHashFingerprint64 . FARMHASH_FINGERPRINT_64 ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public CharMatcher and ( CharMatcher other ) { return other . matches ( match ) ? super . and ( other ) : other ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testMergeSorted_stable_allEqual ( ) { ImmutableList < Integer > first = ImmutableList . of ( 0 , 2 , 4 , 6 , 8 ) ; ImmutableList < Integer > second = ImmutableList . of ( 1 , 3 , 5 , 7 , 9 ) ; Comparator < Object > comparator = Ordering . allEqual ( ) ; Iterable < Integer > merged = Iterables . mergeSorted ( ImmutableList . of ( first , second ) , comparator ) ; assertThat ( merged ) . containsExactly ( 0 , 2 , 4 , 6 , 8 , 1 , 3 , 5 , 7 , 9 ) . inOrder ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testPutAllOnPresentNullKey ( ) { assertTrue ( multimap ( ) . putAll ( null , newArrayList ( v3 ( ) , v4 ( ) ) ) ) ; assertGet ( null , v3 ( ) , v4 ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ComparisonChain compare ( double left , double right ) { return classify ( Double . compare ( left , right ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String get ( ) { throw new RuntimeException ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Queue < String > create ( Object . . . elements ) { String[] array = new String[elements . length] ; int i = 0 ; for ( Object e : elements ) { array[i + + ] = ( String ) e ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void putAll ( Map < ? extends TypeToken < ? extends @NonNull B > , ? extends B > map ) { throw new UnsupportedOperationException ( \"Please use putInstance ( ) instead . \" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testDivByZeroAlwaysFails ( ) { for ( BigInteger p : ALL_BIGINTEGER_CANDIDATES ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { assertThrows ( ArithmeticException . class , ( ) - > BigIntegerMath . divide ( p , ZERO , mode ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public Long set ( int index , Long element ) { checkElementIndex ( index , size ( ) ) ; long oldValue = array[start + index] ; / / checkNotNull for GWT ( do not optimize ) array[start + index] = checkNotNull ( element ) ; return oldValue ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( MapTestSuiteBuilder . using ( new TestStringMapGenerator ( ) { @Override protected Map < String , String > create ( Entry < String , String > [] entries ) { Map < String , String > map = CompactLinkedHashMap . create ( ) ; for ( Entry < String , String > entry : entries ) { map . put ( entry . getKey ( ) , entry . getValue ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testForEach_nullKeys ( ) { initMapWithNullKey ( ) ; List < Entry < K , V > > expectedEntries = asList ( createArrayWithNullKey ( ) ) ; List < Entry < K , V > > entries = new ArrayList < > ( ) ; getMap ( ) . forEach ( ( k , v ) - > entries . add ( entry ( k , v ) ) ) ; assertEqualIgnoringOrder ( expectedEntries , entries ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private static Thread acquireFor ( Lock lock , long duration , TimeUnit unit ) { CountDownLatch latch = new CountDownLatch ( 1 ) ; Thread thread = new Thread ( ) { @Override public void run ( ) { lock . lock ( ) ; try { latch . countDown ( ) ; Thread . sleep ( unit . toMillis ( duration ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testReplaceValuesHandlesDuplicates ( ) { List < V > values = asList ( v0 ( ) , v1 ( ) , v0 ( ) ) ; for ( K k : sampleKeys ( ) ) { resetContainer ( ) ; multimap ( ) . replaceValues ( k , values ) ; assertGet ( k , v0 ( ) , v1 ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { return \"Ordering . allEqual ( ) \" ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testTreeMultimapDerived ( ) { TreeMultimap < DerivedComparable , DerivedComparable > multimap = TreeMultimap . create ( ) ; assertEquals ( ImmutableMultimap . of ( ) , multimap ) ; multimap . put ( new DerivedComparable ( \"foo\" ) , new DerivedComparable ( \"f\" ) ) ; multimap . put ( new DerivedComparable ( \"foo\" ) , new DerivedComparable ( \"o\" ) ) ; multimap . put ( new DerivedComparable ( \"foo\" ) , new DerivedComparable ( \"o\" ) ) ; multimap . put ( new DerivedComparable ( \"bar\" ) , new DerivedComparable ( \"b\" ) ) ; multimap . put ( new DerivedComparable ( \"bar\" ) , new DerivedComparable ( \"a\" ) ) ; multimap . put ( new DerivedComparable ( \"bar\" ) , new DerivedComparable ( \"r\" ) ) ; assertThat ( multimap . keySet ( ) ) . containsExactly ( new DerivedComparable ( \"bar\" ) , new DerivedComparable ( \"foo\" ) ) . inOrder ( ) ; assertThat ( multimap . values ( ) ) . containsExactly ( new DerivedComparable ( \"a\" ) , new DerivedComparable ( \"b\" ) , new DerivedComparable ( \"r\" ) , new DerivedComparable ( \"f\" ) , new DerivedComparable ( \"o\" ) ) . inOrder ( ) ; assertEquals ( Ordering . natural ( ) , multimap . keyComparator ( ) ) ; assertEquals ( Ordering . natural ( ) , multimap . valueComparator ( ) ) ; SerializableTester . reserializeAndAssert ( multimap ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testClearInverseClears ( ) { BiMap < V , K > inv = getMap ( ) . inverse ( ) ; inv . clear ( ) ; assertTrue ( getMap ( ) . isEmpty ( ) ) ; assertTrue ( inv . isEmpty ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testRetainAll_collection ( ) { List < String > list = newArrayList ( \"a\" , \"b\" , \"c\" , \"d\" , \"e\" ) ; assertTrue ( Iterables . retainAll ( list , newArrayList ( \"b\" , \"d\" , \"f\" ) ) ) ; assertEquals ( newArrayList ( \"b\" , \"d\" ) , list ) ; assertFalse ( Iterables . retainAll ( list , newArrayList ( \"b\" , \"e\" , \"d\" ) ) ) ; assertEquals ( newArrayList ( \"b\" , \"d\" ) , list ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void oneArgNullableThrowsNpe ( @Nullable String s ) { checkNotNull ( s ) ; / / doesn't check if you said you'd accept null , but you don't",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int size ( ) { return 0 ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public String toString ( ) { return type + \" arg\" + position ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testToImmutableBiMap_exceptionOnDuplicateKey_java7_combine ( ) { ImmutableBiMap . Builder < String , Integer > zis = ImmutableBiMap . < String , Integer > builder ( ) . put ( \"one\" , 1 ) . put ( \"two\" , 2 ) ; ImmutableBiMap . Builder < String , Integer > zat = ImmutableBiMap . < String , Integer > builder ( ) . put ( \"two\" , 22 ) . put ( \"three\" , 3 ) ; assertThrows ( IllegalArgumentException . class , ( ) - > zis . combine ( zat ) . build ( ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testForEach ( ) { ImmutableIntArray . of ( ) . forEach ( i - > fail ( ) ) ; ImmutableIntArray . of ( 0 , 1 , 3 ) . subArray ( 1 , 1 ) . forEach ( i - > fail ( ) ) ; AtomicInteger count = new AtomicInteger ( 0 ) ; ImmutableIntArray . of ( 0 , 1 , 2 , 3 ) . forEach ( i - > assertThat ( i ) . isEqualTo ( count . getAndIncrement ( ) ) ) ; assertThat ( count . get ( ) ) . isEqualTo ( 4 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testBuilder_orderEntriesByValueFails ( ) { ImmutableSortedMap . Builder < String , Integer > builder = ImmutableSortedMap . naturalOrder ( ) ; assertThrows ( UnsupportedOperationException . class , ( ) - > builder . orderEntriesByValue ( Ordering . natural ( ) ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean hasNext ( ) { checkConcurrentModification ( ) ; return index < elements . size ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private long link ( int i ) { return requireLinks ( ) [i] ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public static Inet4Address getCoercedIPv4Address ( InetAddress ip ) { if ( ip instanceof Inet4Address ) { return ( Inet4Address ) ip ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public int add ( @ParametricNullness E e , int n ) { synchronized ( mutex ) { return delegate ( ) . add ( e , n ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void forGraph_breadthFirst_javadocExample_canBeIteratedMultipleTimes ( ) { Iterable < Character > result = Traverser . forGraph ( JAVADOC_GRAPH ) . breadthFirst ( 'a' ) ; assertEqualCharNodes ( result , \"abcdef\" ) ; assertEqualCharNodes ( result , \"abcdef\" ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final double populationVariance ( ) { checkState ( count ! = 0 ) ; if ( isNaN ( sumOfSquaresOfDeltas ) ) { return NaN ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testForStringBogusInput ( ) { ImmutableSet < String > bogusInputs = ImmutableSet . of ( \"\" , \"016 . 016 . 016 . 016\" , \"016 . 016 . 016\" , \"016 . 016\" , \"016\" , \"000 . 000 . 000 . 000\" , \"000\" , \"0x0a . 0x0a . 0x0a . 0x0a\" , \"0x0a . 0x0a . 0x0a\" , \"0x0a . 0x0a\" , \"0x0a\" , \"42 . 42 . 42 . 42 . 42\" , \"42 . 42 . 42\" , \"42 . 42\" , \"42\" , \"42 . . 42 . 42\" , \"42 . . 42 . 42 . 42\" , \"42 . 42 . 42 . 42 . \" , \"42 . 42 . 42 . 42 . . . \" , \" . 42 . 42 . 42 . 42\" , \" . 42 . 42 . 42\" , \" . . . 42 . 42 . 42 . 42\" , \"42 . 42 . 42 . - 0\" , \"42 . 42 . 42 . + 0\" , \" . \" , \" . . . \" , \"bogus\" , \"bogus . com\" , \"192 . 168 . 0 . 1 . com\" , \"12345 . 67899 . - 54321 . - 98765\" , \"257 . 0 . 0 . 0\" , \"42 . 42 . 42 . - 42\" , \"42 . 42 . 42 . ab\" , \"3ffe::1 . net\" , \"3ffe::1::1\" , \"1::2::3::4:5\" , \"::7:6:5:4:3:2:\" , / / should end with \":0\" \":6:5:4:3:2:1::\" , / / should begin with \"0:\" \"2001::db:::1\" , \"FEDC:9878\" , \" + 1 . + 2 . + 3 . 4\" , \"1 . 2 . 3 . 4e0\" , \"6:5:4:3:2:1:0\" , / / too few parts \"::7:6:5:4:3:2:1:0\" , / / too many parts \"7:6:5:4:3:2:1:0::\" , / / too many parts \"9:8:7:6:5:4:3::2:1\" , / / too many parts \"0:1:2:3::4:5:6:7\" , / / :: must remove at least one 0 . \"3ffe:0:0:0:0:0:0:0:1\" , / / too many parts ( 9 instead of 8 ) \"3ffe::10000\" , / / hextet exceeds 16 bits \"3ffe::goog\" , \"3ffe:: - 0\" , \"3ffe:: + 0\" , \"3ffe:: - 1\" , \":\" , \":::\" , \"::1 . 2 . 3\" , \"::1 . 2 . 3 . 4 . 5\" , \"::1 . 2 . 3 . 4:\" , \"1 . 2 . 3 . 4::\" , \"2001:db8::1:\" , \":2001:db8::1\" , \":1:2:3:4:5:6:7\" , \"1:2:3:4:5:6:7:\" , \":1:2:3:4:5:6:\" ) ; for ( String bogusInput : bogusInputs ) { assertThrows ( \"IllegalArgumentException expected for '\" + bogusInput + \"'\" , IllegalArgumentException . class , ( ) - > InetAddresses . forString ( bogusInput ) ) ; assertFalse ( InetAddresses . isInetAddress ( bogusInput ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected String doBackward ( Long value ) { return value . toString ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testFactorialNegative ( ) { for ( int n : NEGATIVE_INTEGER_CANDIDATES ) { assertThrows ( IllegalArgumentException . class , ( ) - > DoubleMath . factorial ( n ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public boolean containsAll ( Collection < ? > targets ) { return Collections2 . containsAllImpl ( this , targets ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void handleString ( String string ) { dispatchedSubscribers . add ( this ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Map < String , Integer > makePopulatedMap ( ) { return ImmutableMap . of ( \"one\" , 1 ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public ImmutableBiMap < K , V > build ( ) { return buildOrThrow ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testEnsureCapacity_fail ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Floats . ensureCapacity ( ARRAY1 , - 1 , 1 ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > Floats . ensureCapacity ( ARRAY1 , 1 , - 1 ) ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void writeBoolean ( boolean v ) { try { output . writeBoolean ( v ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public SortedSet < K > keySet ( ) { SortedSet < K > result = sortedKeySet ; return ( result = = null ) ? sortedKeySet = createKeySet ( ) : result ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testNullValuesInCopyOfEntries ( ) { for ( int i = 1 ; i < = 10 ; i + + ) { for ( int j = 0 ; j < i ; j + + ) { Map < Integer , @Nullable Integer > source = new TreeMap < > ( ) ; for ( int k = 0 ; k < i ; k + + ) { source . put ( k , k ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void edgeOrder_sorted ( ) { MutableNetwork < Integer , String > network = NetworkBuilder . directed ( ) . edgeOrder ( ElementOrder . sorted ( Ordering . < String > natural ( ) . reverse ( ) ) ) . build ( ) ; addEdges ( network ) ; assertThat ( network . edgeOrder ( ) ) . isEqualTo ( ElementOrder . sorted ( Ordering . < String > natural ( ) . reverse ( ) ) ) ; assertThat ( network . edges ( ) ) . containsExactly ( \"p\" , \"i\" , \"e\" ) . inOrder ( ) ; assertThat ( network . nodeOrder ( ) ) . isEqualTo ( ElementOrder . insertion ( ) ) ; / / default",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public void testCheckState_simpleMessage_failure ( ) { IllegalStateException expected = assertThrows ( IllegalStateException . class , ( ) - > checkState ( false , new Message ( ) ) ) ; verifySimpleMessage ( expected ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "protected Map < String , Map < Integer , Character > > makePopulatedMap ( ) { Table < Integer , String , Character > table = HashBasedTable . create ( ) ; table . put ( 1 , \"foo\" , 'a' ) ; table . put ( 1 , \"bar\" , 'b' ) ; table . put ( 3 , \"foo\" , 'c' ) ; return unmodifiableTable ( table ) . columnMap ( ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "private Iterable < List < Object > > buildCartesianProduct ( Set < ? > . . . sets ) { List < Set < Optional < ? > > > optionalSets = Lists . newArrayListWithExpectedSize ( sets . length ) ; for ( Set < ? > set : sets ) { Set < Optional < ? > > optionalSet = Sets . newLinkedHashSet ( Iterables . transform ( set , NULLABLE_TO_OPTIONAL ) ) ; optionalSets . add ( optionalSet ) ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  },
  {
    "context": "public final Map < AnEnum , String > create ( Object . . . entries ) { @SuppressWarnings ( \"unchecked\" ) Entry < AnEnum , String > [] array = ( Entry < AnEnum , String > [] ) new Entry < ? , ? > [entries . length] ; int i = 0 ; for ( Object o : entries ) { @SuppressWarnings ( \"unchecked\" ) Entry < AnEnum , String > e = ( Entry < AnEnum , String > ) o ; array[i + + ] = e ;",
    "true_next": "}",
    "predicted_next": "getNonGoldenRandomKey",
    "probability": 3.296956908773202e-05
  }
]