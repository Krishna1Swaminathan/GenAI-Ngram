protected boolean standardRetainAll ( Collection < ? > collection ) { return Iterators . retainAll ( iterator ( ) , collection ) ; }
public CacheBuilder < K , V > maximumWeight ( long maximumWeight ) { checkState ( this . maximumWeight = = UNSET_INT , "maximum weight was already set to %s" , this . maximumWeight ) ; checkState ( this . maximumSize = = UNSET_INT , "maximum size was already set to %s" , this . maximumSize ) ; checkArgument ( maximumWeight > = 0 , "maximum weight must not be negative" ) ; this . maximumWeight = maximumWeight ; return this ; }
public Iterator < E > iterator ( ) { return iteratorImpl ( this ) ; }
public List < Character > subList ( int fromIndex , int toIndex ) { int size = size ( ) ; checkPositionIndexes ( fromIndex , toIndex , size ) ; if ( fromIndex = = toIndex ) { return Collections . emptyList ( ) ; }
public static < T extends @Nullable Object > T get ( Iterable < T > iterable , int position ) { checkNotNull ( iterable ) ; return ( iterable instanceof List ) ? ( ( List < T > ) iterable ) . get ( position ) : Iterators . get ( iterable . iterator ( ) , position ) ; }
private static Character[] concat ( Character[] left , Character[] right ) { Character[] result = new Character[left . length + right . length] ; System . arraycopy ( left , 0 , result , 0 , left . length ) ; System . arraycopy ( right , 0 , result , left . length , right . length ) ; return result ; }
public long loadCount ( ) { return saturatedAdd ( loadSuccessCount , loadExceptionCount ) ; }
public boolean putAll ( Multimap < ? extends K , ? extends V > multimap ) { boolean changed = false ; for ( Entry < ? extends K , ? extends V > entry : multimap . entries ( ) ) { changed | = put ( entry . getKey ( ) , entry . getValue ( ) ) ; }
public void testGetStackTraceAsString ( ) { class StackTraceException extends Exception { StackTraceException ( String message ) { super ( message ) ; }
public < A extends B , B extends @Nullable Object > void b ( A a ) { fail ( "Method with parameter < A extends B > where < B extends @Nullable Object > should not be" + " called" ) ; }
public Iterator < Entry < K , V > > iterator ( ) { return asMapEntryIterator ( backingSet ( ) , function ) ; }
private static final Ordering < Invokable < ? , ? > > BY_METHOD_NAME = new Ordering < Invokable < ? , ? > > ( ) { @Override public int compare ( Invokable < ? , ? > left , Invokable < ? , ? > right ) { return left . getName ( ) . compareTo ( right . getName ( ) ) ; }
public void testTryParseInfinity ( ) { checkTryParse ( Float . POSITIVE_INFINITY , "Infinity" ) ; checkTryParse ( Float . POSITIVE_INFINITY , " + Infinity" ) ; checkTryParse ( Float . NEGATIVE_INFINITY , " - Infinity" ) ; }
public ListenableFuture < Object > reload ( Object key , Object oldValue ) { return immediateFailedFuture ( e ) ; }
public static BaseEncoding base64 ( ) { return BASE64 ; }
public void testEviction_overflow ( ) { CountingRemovalListener < Object , Object > removalListener = countingRemovalListener ( ) ; IdentityLoader < Object > loader = identityLoader ( ) ; LoadingCache < Object , Object > cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( 1 ) . maximumWeight ( 1L < < 31 ) . weigher ( constantWeigher ( Integer . MAX_VALUE ) ) . removalListener ( removalListener ) . build ( loader ) ; cache . getUnchecked ( objectWithHash ( 0 ) ) ; cache . getUnchecked ( objectWithHash ( 0 ) ) ; CacheTesting . processPendingNotifications ( cache ) ; assertThat ( removalListener . getCount ( ) ) . isEqualTo ( 1 ) ; }
public int indexOf ( Object element ) { return standardIndexOf ( element ) ; }
public static BaseEncoding base64Url ( ) { return BASE64_URL ; }
public void testNewDataOutput_writeLong ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; out . writeLong ( 0x1234567876543210L ) ; assertThat ( out . toByteArray ( ) ) . isEqualTo ( bytes ) ; }
public void testToImmutableSortedSet_duplicates ( ) { class TypeWithDuplicates implements Comparable < TypeWithDuplicates > { final int a ; final int b ; TypeWithDuplicates ( int a , int b ) { this . a = a ; this . b = b ; }
public void testGet_absent ( ) { Optional < String > optional = Optional . absent ( ) ; assertThrows ( IllegalStateException . class , optional::get ) ; }
public int hashCode ( ) { return super . hashCode ( ) ; }
public static < K extends @Nullable Object , V extends @Nullable Object > SetMultimap < K , V > forMap ( Map < K , V > map ) { return new MapMultimap < > ( map ) ; }
private ConcatenatedHashFunction ( HashFunction . . . functions ) { super ( functions ) ; for ( HashFunction function : functions ) { checkArgument ( function . bits ( ) % 8 = = 0 , "the number of bits ( %s ) in hashFunction ( %s ) must be divisible by 8" , function . bits ( ) , function ) ; }
protected SortedSet < T > delegate ( ) { return backingSortedSet ; }
public void remove ( ) { checkForConcurrentModification ( ) ; CollectPreconditions . checkRemove ( toRemove ! = - 1 ) ; size - = backingMap . removeEntry ( toRemove ) ; entryIndex = backingMap . nextIndexAfterRemove ( entryIndex , toRemove ) ; toRemove = - 1 ; expectedModCount = backingMap . modCount ; }
public void testLowerHole ( ) { resetWithHole ( ) ; assertEquals ( null , navigableSet . lower ( a ) ) ; assertEquals ( a , navigableSet . lower ( b ) ) ; assertEquals ( a , navigableSet . lower ( c ) ) ; }
public static HashFunction hmacSha512 ( Key key ) { return new MacHashFunction ( "HmacSHA512" , key , hmacToString ( "hmacSha512" , key ) ) ; }
private static void checkArrayEquals ( Object[] expected , Object[] actual ) { assertTrue ( "expected ( " + expected . getClass ( ) + " ) : " + Arrays . toString ( expected ) + " actual ( " + actual . getClass ( ) + " ) : " + Arrays . toString ( actual ) , arrayEquals ( expected , actual ) ) ; }
public ThreadFactoryBuilder setUncaughtExceptionHandler ( UncaughtExceptionHandler uncaughtExceptionHandler ) { this . uncaughtExceptionHandler = checkNotNull ( uncaughtExceptionHandler ) ; return this ; }
private static < E extends @Nullable Object > List < E > list ( List < E > list , @Nullable Object mutex ) { return ( list instanceof RandomAccess ) ? new SynchronizedRandomAccessList < E > ( list , mutex ) : new SynchronizedList < E > ( list , mutex ) ; }
public void removeEdge_existingSelfLoopEdge ( ) { assume ( ) . that ( graphIsMutable ( ) ) . isTrue ( ) ; assume ( ) . that ( network . allowsSelfLoops ( ) ) . isTrue ( ) ; addEdge ( N1 , N1 , E11 ) ; assertThat ( networkAsMutableNetwork . removeEdge ( E11 ) ) . isTrue ( ) ; assertThat ( network . edges ( ) ) . doesNotContain ( E11 ) ; assertThat ( network . edgesConnecting ( N1 , N1 ) ) . isEmpty ( ) ; }
public void testNulls ( ) { new NullPointerTester ( ) . testAllPublicStaticMethods ( Invokable . class ) ; new NullPointerTester ( ) . testAllPublicInstanceMethods ( Prepender . method ( "staticMethod" ) ) ; }
public void testCompare ( ) { for ( short x : VALUES ) { for ( short y : VALUES ) { / / Only compare the sign of the result of compare ( ) . int expected = Short . compare ( x , y ) ; int actual = Shorts . compare ( x , y ) ; if ( expected = = 0 ) { assertWithMessage ( "%s , %s" , x , y ) . that ( actual ) . isEqualTo ( expected ) ; }
protected Set < String > create ( String[] elements ) { return difference ( newHashSet ( samples ( ) . e3 ( ) , samples ( ) . e4 ( ) ) , newHashSet ( samples ( ) ) ) ; }
private static < V > AsyncCallable < V > tagged ( String toString , AsyncCallable < V > callable ) { return new AsyncCallable < V > ( ) { @Override public ListenableFuture < V > call ( ) throws Exception { return callable . call ( ) ; }
public StrongKeyWeakValueEntry < K , V > getNext ( ) { return next ; }
public void testBuilderMethod ( ) { assertThrows ( UnsupportedOperationException . class , ( ) - > ImmutableSortedSet . builder ( ) ) ; }
public void testEnclosing ( RangeSet < Integer > rangeSet ) { assertTrue ( rangeSet . enclosesAll ( ImmutableList . < Range < Integer > > of ( ) ) ) ; for ( Range < Integer > query : QUERY_RANGES ) { boolean expectEnclose = false ; for ( Range < Integer > expectedRange : rangeSet . asRanges ( ) ) { if ( expectedRange . encloses ( query ) ) { expectEnclose = true ; break ; }
private UndirectedGraphConnections ( Map < N , V > adjacentNodeValues ) { this . adjacentNodeValues = checkNotNull ( adjacentNodeValues ) ; }
public Thread newThread ( Runnable r ) { Thread thread = new Thread ( r ) ; thread . setName ( THREAD_NAME ) ; thread . setPriority ( THREAD_PRIORITY ) ; thread . setDaemon ( THREAD_DAEMON ) ; thread . setUncaughtExceptionHandler ( UNCAUGHT_EXCEPTION_HANDLER ) ; return thread ; }
public void testCopyOf_iterator_oneElementRepeated ( ) { Iterator < String > iterator = Iterators . forArray ( "a" , "a" , "a" ) ; Set < String > set = copyOf ( iterator ) ; assertEquals ( singleton ( "a" ) , set ) ; }
public void testToStringOmitNullValues_manyValuesLastNull ( ) { String toTest = MoreObjects . toStringHelper ( new TestClass ( ) ) . omitNullValues ( ) . addValue ( "Hello" ) . addValue ( "Googley" ) . addValue ( null ) . toString ( ) ; assertEquals ( "TestClass { Hello , Googley }
public static IntStream concat ( IntStream . . . streams ) { boolean isParallel = false ; int characteristics = Spliterator . ORDERED | Spliterator . SIZED | Spliterator . NONNULL ; long estimatedSize = 0L ; ImmutableList . Builder < Spliterator . OfInt > splitrsBuilder = new ImmutableList . Builder < > ( streams . length ) ; for ( IntStream stream : streams ) { isParallel | = stream . isParallel ( ) ; Spliterator . OfInt splitr = stream . spliterator ( ) ; splitrsBuilder . add ( splitr ) ; characteristics & = splitr . characteristics ( ) ; estimatedSize = LongMath . saturatedAdd ( estimatedSize , splitr . estimateSize ( ) ) ; }
public Object load ( Object from ) { count . incrementAndGet ( ) ; return new Object ( ) ; }
public void addListener ( Listener listener , Executor executor ) { state . addListener ( listener , executor ) ; }
public static LongStream concat ( LongStream . . . streams ) { boolean isParallel = false ; int characteristics = Spliterator . ORDERED | Spliterator . SIZED | Spliterator . NONNULL ; long estimatedSize = 0L ; ImmutableList . Builder < Spliterator . OfLong > splitrsBuilder = new ImmutableList . Builder < > ( streams . length ) ; for ( LongStream stream : streams ) { isParallel | = stream . isParallel ( ) ; Spliterator . OfLong splitr = stream . spliterator ( ) ; splitrsBuilder . add ( splitr ) ; characteristics & = splitr . characteristics ( ) ; estimatedSize = LongMath . saturatedAdd ( estimatedSize , splitr . estimateSize ( ) ) ; }
public ElementOrder < N > incidentEdgeOrder ( ) { return ElementOrder . stable ( ) ; }
public void testToString_oneIntegerField ( ) { String toTest = MoreObjects . toStringHelper ( new TestClass ( ) ) . add ( "field1" , Integer . valueOf ( 42 ) ) . toString ( ) ; assertEquals ( "TestClass { field1 = 42 }
public void testSubSubRangeMap ( ) { RangeMap < Integer , Integer > rangeMap = TreeRangeMap . create ( ) ; rangeMap . put ( Range . open ( 3 , 7 ) , 1 ) ; rangeMap . put ( Range . closed ( 9 , 10 ) , 2 ) ; rangeMap . put ( Range . closed ( 12 , 16 ) , 3 ) ; RangeMap < Integer , Integer > sub1 = rangeMap . subRangeMap ( Range . closed ( 5 , 11 ) ) ; assertEquals ( ImmutableMap . of ( Range . closedOpen ( 5 , 7 ) , 1 , Range . closed ( 9 , 10 ) , 2 ) , sub1 . asMapOfRanges ( ) ) ; RangeMap < Integer , Integer > sub2 = sub1 . subRangeMap ( Range . open ( 6 , 15 ) ) ; assertEquals ( ImmutableMap . of ( Range . open ( 6 , 7 ) , 1 , Range . closed ( 9 , 10 ) , 2 ) , sub2 . asMapOfRanges ( ) ) ; }
private EndpointPair ( N nodeU , N nodeV ) { this . nodeU = checkNotNull ( nodeU ) ; this . nodeV = checkNotNull ( nodeV ) ; }
public static void reverse ( long[] array , int fromIndex , int toIndex ) { checkNotNull ( array ) ; checkPositionIndexes ( fromIndex , toIndex , array . length ) ; for ( int i = fromIndex , j = toIndex - 1 ; i < j ; i + + , j - - ) { long tmp = array[i] ; array[i] = array[j] ; array[j] = tmp ; }
public static ByteSinkFactory pathByteSinkFactory ( ) { return new PathByteSinkFactory ( null ) ; }
public boolean equals ( @Nullable Object obj ) { if ( obj instanceof SubtypeOfPredicate ) { SubtypeOfPredicate that = ( SubtypeOfPredicate ) obj ; return clazz = = that . clazz ; }
public int compareTo ( NonComparableSuperClass other ) { return value . compareTo ( other . value ) ; }
public void testEntrySet ( ) { / / Bug 3168290 Map < Currency , String > map = ImmutableMap . of ( Currency . DOLLAR , "dollar" , Currency . PESO , "peso" , Currency . FRANC , "franc" ) ; EnumHashBiMap < Currency , String > bimap = EnumHashBiMap . create ( map ) ; Set < Object > uniqueEntries = Sets . newIdentityHashSet ( ) ; uniqueEntries . addAll ( bimap . entrySet ( ) ) ; assertEquals ( 3 , uniqueEntries . size ( ) ) ; }
private ImmutableIntArray ( int[] array , int start , int end ) { this . array = array ; this . start = start ; this . end = end ; }
public NavigableSet < K > subSet ( @ParametricNullness K fromElement , boolean fromInclusive , @ParametricNullness K toElement , boolean toInclusive ) { return map ( ) . subMap ( fromElement , fromInclusive , toElement , toInclusive ) . navigableKeySet ( ) ; }
public void hasCycle_deepPathGraph ( ) { for ( MutableGraph < Integer > graph : graphsToTest ) { for ( int i = 0 ; i < 100000 ; i + + ) { graph . putEdge ( i , i + 1 ) ; }
public static < K , V > ImmutableListMultimap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 ) { ImmutableListMultimap . Builder < K , V > builder = ImmutableListMultimap . builder ( ) ; builder . put ( k1 , v1 ) ; builder . put ( k2 , v2 ) ; builder . put ( k3 , v3 ) ; builder . put ( k4 , v4 ) ; return builder . build ( ) ; }
public List < Entry < String , Integer > > create ( Object . . . elements ) { ImmutableSortedMap . Builder < String , Integer > builder = ImmutableSortedMap . naturalOrder ( ) ; for ( Object o : elements ) { @SuppressWarnings ( "unchecked" ) Entry < String , Integer > entry = ( Entry < String , Integer > ) checkNotNull ( o ) ; builder . put ( entry ) ; }
public K last ( ) { return lastKey ( ) ; }
public void validateClass ( Class < ? extends Exception > exceptionClass ) { checkArgument ( isCheckedException ( exceptionClass ) , "Futures . getChecked exception type ( %s ) must not be a RuntimeException" , exceptionClass ) ; }
public final Iterable < N > depthFirstPostOrder ( N startNode ) { return depthFirstPostOrder ( ImmutableSet . of ( startNode ) ) ; }
public Map . @Nullable Entry < K , V > lastEntry ( ) { synchronized ( mutex ) { return nullableSynchronizedEntry ( delegate ( ) . lastEntry ( ) , mutex ) ; }
public void testEquals_largerSet ( ) { Collection < E > moreElements = getSampleElements ( getNumElements ( ) + 1 ) ; assertFalse ( "Sets of different sizes should not be equal . " , getSet ( ) . equals ( MinimalSet . from ( moreElements ) ) ) ; }
public final double pearsonsCorrelationCoefficient ( ) { checkState ( count ( ) > 1 ) ; if ( isNaN ( sumOfProductsOfDeltas ) ) { return NaN ; }
private static Type genericReturnType ( Class < ? > cls , String methodName ) { try { return cls . getMethod ( methodName ) . getGenericReturnType ( ) ; }
public @Nullable K floorKey ( @ParametricNullness K key ) { return forward ( ) . ceilingKey ( key ) ; }
public void testStringAssertions ( ) { String original = "hello world" ; String copy = SerializableTester . reserializeAndAssert ( original ) ; assertEquals ( original , copy ) ; assertNotSame ( original , copy ) ; }
public void testSerialization_empty ( ) { validateReserialization ( ImmutableTable . of ( ) ) ; }
public Map < R , Map < C , V > > rowMap ( ) { Map < R , Map < C , V > > result = rowMap ; return ( result = = null ) ? rowMap = createRowMap ( ) : result ; }
public void testNotifyFailedWhenTerminated ( ) { NoOpService service = new NoOpService ( ) ; service . startAsync ( ) . awaitRunning ( ) ; service . stopAsync ( ) . awaitTerminated ( ) ; assertThrows ( IllegalStateException . class , ( ) - > service . notifyFailed ( new Exception ( ) ) ) ; }
public void testInvalidateAll ( ) { List < Object > invalidated = new ArrayList < > ( ) ; Cache < Integer , Integer > cache = new AbstractCache < Integer , Integer > ( ) { @Override public Integer getIfPresent ( Object key ) { throw new UnsupportedOperationException ( ) ; }
public void testIteratorConcurrentModification ( ) { MinMaxPriorityQueue < Integer > mmHeap = MinMaxPriorityQueue . create ( ) ; mmHeap . addAll ( Lists . newArrayList ( 1 , 2 , 3 , 4 ) ) ; Iterator < Integer > it = mmHeap . iterator ( ) ; assertTrue ( "Iterator has reached end prematurely" , it . hasNext ( ) ) ; it . next ( ) ; it . next ( ) ; mmHeap . remove ( 4 ) ; assertThrows ( ConcurrentModificationException . class , ( ) - > it . next ( ) ) ; }
public ElementOrder < E > edgeOrder ( ) { return delegate ( ) . edgeOrder ( ) ; }
public String toString ( ) { return "Suppliers . supplierFunction ( ) " ; }
public void testUnequalObjectsInEqualityGroup ( ) { EqualsTester tester = new EqualsTester ( ) . addEqualityGroup ( named ( "foo" ) , named ( "bar" ) ) ; try { tester . testEquals ( ) ; }
public void testDelegateRejection ( ) { AtomicInteger numCalls = new AtomicInteger ( ) ; AtomicBoolean reject = new AtomicBoolean ( true ) ; SequentialExecutor executor = new SequentialExecutor ( new Executor ( ) { @Override public void execute ( Runnable r ) { if ( reject . get ( ) ) { throw new RejectedExecutionException ( ) ; }
public ImmutableTypeToInstanceMap < B > build ( ) { return new ImmutableTypeToInstanceMap < > ( mapBuilder . buildOrThrow ( ) ) ; }
public void testValuesRemove ( ) { Map < K , V > map ; try { map = makePopulatedMap ( ) ; }
public void testSubtypeOf_apply ( ) { Predicate < Class < ? > > isInteger = Predicates . subtypeOf ( Integer . class ) ; assertTrue ( isInteger . apply ( Integer . class ) ) ; assertFalse ( isInteger . apply ( Float . class ) ) ; assertThrows ( NullPointerException . class , ( ) - > isInteger . apply ( null ) ) ; }
public void testRegression_dataCorruption ( ) { int size = 8 ; List < Integer > expected = createOrderedList ( size ) ; MinMaxPriorityQueue < Integer > q = MinMaxPriorityQueue . create ( expected ) ; List < Integer > contents = new ArrayList < > ( expected ) ; List < Integer > elements = Lists . newArrayListWithCapacity ( size ) ; while ( ! q . isEmpty ( ) ) { assertThat ( q ) . containsExactlyElementsIn ( contents ) ; Integer next = q . pollFirst ( ) ; contents . remove ( next ) ; assertThat ( q ) . containsExactlyElementsIn ( contents ) ; for ( int i = 0 ; i < = size ; i + + ) { q . add ( i ) ; contents . add ( i ) ; assertThat ( q ) . containsExactlyElementsIn ( contents ) ; q . add ( next ) ; contents . add ( next ) ; assertThat ( q ) . containsExactlyElementsIn ( contents ) ; q . remove ( i ) ; assertTrue ( contents . remove ( Integer . valueOf ( i ) ) ) ; assertThat ( q ) . containsExactlyElementsIn ( contents ) ; assertEquals ( next , q . poll ( ) ) ; contents . remove ( next ) ; assertThat ( q ) . containsExactlyElementsIn ( contents ) ; }
public Mall < Outdoor > . Shop < Electronics > ownerTypeDoesNotMatch ( Mall < Indoor > . Shop < Electronics > shop ) { return notSubtype ( shop ) ; }
public void testDuplicateValues ( ) { ImmutableMap < String , Integer > map = new ImmutableMap . Builder < String , Integer > ( ) . put ( "one" , 1 ) . put ( "two" , 2 ) . put ( "uno" , 1 ) . put ( "dos" , 2 ) . buildOrThrow ( ) ; IllegalArgumentException expected = assertThrows ( IllegalArgumentException . class , ( ) - > ImmutableBiMap . copyOf ( map ) ) ; assertThat ( expected ) . hasMessageThat ( ) . containsMatch ( "1 | 2" ) ; }
public @Nullable Entry < K , V > ceilingEntry ( @ParametricNullness K key ) { return forward ( ) . floorEntry ( key ) ; }
public Hasher newHasher ( int expectedInputSize ) { checkArgument ( expectedInputSize > = 0 , "expectedInputSize must be > = 0 but was %s" , expectedInputSize ) ; return newHasher ( ) ; }
public void testScale_indexes_varargs_compute_doubleVarargs_empty ( ) { Quantiles . ScaleAndIndexes intermediate = Quantiles . scale ( 10 ) . indexes ( 1 , 3 , 5 ) ; assertThrows ( IllegalArgumentException . class , ( ) - > intermediate . compute ( new double[] { }
public Builder < E > setCount ( E element , int count ) { super . setCount ( element , count ) ; return this ; }
public void testReplaceEntry_supportedAbsentKey ( ) { assertFalse ( getMap ( ) . replace ( k3 ( ) , v3 ( ) , v4 ( ) ) ) ; expectUnchanged ( ) ; }
public void testRoundLog2Ceiling ( ) { for ( double d : POSITIVE_FINITE_DOUBLE_CANDIDATES ) { int log2 = DoubleMath . log2 ( d , CEILING ) ; assertTrue ( StrictMath . pow ( 2 . 0 , log2 ) > = d ) ; double z = StrictMath . pow ( 2 . 0 , log2 - 1 ) ; assertTrue ( z < d ) ; }
public boolean hasNext ( ) { return ! queue . isEmpty ( ) ; }
public Float[] createArray ( int length ) { return new Float[length] ; }
public static void staticOneArgThrowsOtherThanNpe ( String s ) { throw new FooException ( ) ; / / should catch as failure }
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( TreeRangeMapTest . class ) ; suite . addTest ( MapTestSuiteBuilder . using ( new TestMapGenerator < Range < Integer > , String > ( ) { @Override public SampleElements < Entry < Range < Integer > , String > > samples ( ) { return new SampleElements < > ( mapEntry ( Range . singleton ( 0 ) , "banana" ) , mapEntry ( Range . closedOpen ( 3 , 5 ) , "frisbee" ) , mapEntry ( Range . atMost ( - 1 ) , "fruitcake" ) , mapEntry ( Range . open ( 10 , 15 ) , "elephant" ) , mapEntry ( Range . closed ( 20 , 22 ) , "umbrella" ) ) ; }
public void testPutNotPresentKeyPropagatesToEntries ( ) { Collection < Entry < K , V > > entries = multimap ( ) . entries ( ) ; assertFalse ( entries . contains ( mapEntry ( k3 ( ) , v3 ( ) ) ) ) ; multimap ( ) . put ( k3 ( ) , v3 ( ) ) ; assertContains ( entries , mapEntry ( k3 ( ) , v3 ( ) ) ) ; }
public String getMessage ( ) { / / requireNonNull is safe because ExampleStackTrace sets a non - null message . StringBuilder message = new StringBuilder ( requireNonNull ( super . getMessage ( ) ) ) ; for ( Throwable t = conflictingStackTrace ; t ! = null ; t = t . getCause ( ) ) { message . append ( " , " ) . append ( t . getMessage ( ) ) ; }
public void testOrderedPermutationSetEmpty ( ) { List < Integer > list = new ArrayList < > ( ) ; Collection < List < Integer > > permutationSet = Collections2 . orderedPermutations ( list ) ; assertEquals ( 1 , permutationSet . size ( ) ) ; assertThat ( permutationSet ) . contains ( list ) ; Iterator < List < Integer > > permutations = permutationSet . iterator ( ) ; assertNextPermutation ( new ArrayList < > ( ) , permutations ) ; assertNoMorePermutations ( permutations ) ; }
public static < T extends Enum < T > > Optional < T > getIfPresent ( Class < T > enumClass , String value ) { checkNotNull ( enumClass ) ; checkNotNull ( value ) ; return Platform . getEnumIfPresent ( enumClass , value ) ; }
public DummyScheduledThreadPoolExecutor ( ) { super ( 1 ) ; }
private static < K extends @Nullable Object , V extends @Nullable Object > NavigableMap < K , V > filterFiltered ( FilteredEntryNavigableMap < K , V > map , Predicate < ? super Entry < K , V > > entryPredicate ) { Predicate < Entry < K , V > > predicate = Predicates . and ( map . entryPredicate , entryPredicate ) ; return new FilteredEntryNavigableMap < > ( map . unfiltered , predicate ) ; }
public List < String > create ( String[] elements ) { ImmutableMap . Builder < Integer , String > builder = ImmutableMap . builder ( ) ; for ( int i = 0 ; i < elements . length ; i + + ) { builder . put ( i , elements[i] ) ; }
public void testAll ( ) { List < String > list = new ArrayList < > ( ) ; Predicate < String > predicate = equalTo ( "cool" ) ; assertTrue ( all ( list . iterator ( ) , predicate ) ) ; list . add ( "cool" ) ; assertTrue ( all ( list . iterator ( ) , predicate ) ) ; list . add ( "pants" ) ; assertFalse ( all ( list . iterator ( ) , predicate ) ) ; }
public void forGraph_depthFirstPostOrder_javadocExample_canBeIteratedMultipleTimes ( ) { Iterable < Character > result = Traverser . forGraph ( JAVADOC_GRAPH ) . depthFirstPostOrder ( 'a' ) ; assertEqualCharNodes ( result , "fcebda" ) ; assertEqualCharNodes ( result , "fcebda" ) ; }
public long elapsedNanos ( ) { return stopwatch . elapsed ( NANOSECONDS ) ; }
public boolean offerLast ( @ParametricNullness E e ) { return delegate ( ) . offerLast ( e ) ; }
public void testPutNewValue ( ) { assertThat ( mapCache . put ( "key" , "value" ) ) . isNull ( ) ; assertThat ( mapCache . get ( "key" ) ) . isEqualTo ( "value" ) ; / / ensure key / value is cached assertThat ( mapCache . put ( "key" , "new value" ) ) . isEqualTo ( "value" ) ; assertThat ( mapCache . get ( "key" ) ) . isEqualTo ( "new value" ) ; }
public void replaceAll ( BiFunction < ? super K , ? super V , ? extends V > function ) { unfiltered ( ) . replaceAll ( ( key , value ) - > predicate . apply ( Maps . < K , V > immutableEntry ( key , value ) ) ? function . apply ( key , value ) : value ) ; }
private PathCharSinkFactory ( @Nullable String initialString ) { this . initialString = initialString ; }
public void testExplicit_serialization ( ) { SortedSet < String > set = ImmutableSortedSet . orderedBy ( STRING_LENGTH ) . add ( "in" , "the" , "quick" , "jumped" , "over" , "a" ) . build ( ) ; SortedSet < String > copy = SerializableTester . reserializeAndAssert ( set ) ; assertTrue ( elementsEqual ( set , copy ) ) ; assertSame ( set . comparator ( ) , copy . comparator ( ) ) ; }
public boolean remove ( @Nullable Object o ) { if ( ! contains ( o ) ) { return false ; }
public String toString ( ) { return "Resources . asByteSource ( " + url + " ) " ; }
private static void joinUninterruptibly ( Thread thread , long timeout , TimeUnit unit ) { boolean interrupted = false ; try { long remainingNanos = unit . toNanos ( timeout ) ; long end = System . nanoTime ( ) + remainingNanos ; while ( true ) { try { / / TimeUnit . timedJoin ( ) treats negative timeouts just like zero . NANOSECONDS . timedJoin ( thread , remainingNanos ) ; return ; }
public void testCreation_comparator ( ) { MinMaxPriorityQueue < Integer > queue = MinMaxPriorityQueue . orderedBy ( SOME_COMPARATOR ) . create ( ) ; assertEquals ( 11 , queue . capacity ( ) ) ; checkUnbounded ( queue ) ; assertSame ( SOME_COMPARATOR , queue . comparator ( ) ) ; }
public TestSuite createTestSuite ( ) { withFeatures ( KNOWN_ORDER ) ; TestSuite suite = super . createTestSuite ( ) ; for ( TestSuite subSuite : createDerivedSuites ( this ) ) { suite . addTest ( subSuite ) ; }
public void testWrap ( ) { new EqualsTester ( ) . addEqualityGroup ( LENGTH_EQUIVALENCE . wrap ( "hello" ) , LENGTH_EQUIVALENCE . wrap ( "hello" ) , LENGTH_EQUIVALENCE . wrap ( "world" ) ) . addEqualityGroup ( LENGTH_EQUIVALENCE . wrap ( "hi" ) , LENGTH_EQUIVALENCE . wrap ( "yo" ) ) . addEqualityGroup ( LENGTH_EQUIVALENCE . < @Nullable String > wrap ( null ) , LENGTH_EQUIVALENCE . < @Nullable String > wrap ( null ) ) . addEqualityGroup ( Equivalence . equals ( ) . wrap ( "hello" ) ) . addEqualityGroup ( Equivalence . equals ( ) . < @Nullable Object > wrap ( null ) ) . testEquals ( ) ; }
public void clear ( ) { keySet ( ) . clear ( ) ; }
private static Type newArrayClassOrGenericArrayType ( Type componentType ) { return Types . JavaVersion . JAVA7 . newArrayType ( componentType ) ; }
public String toString ( ) { throw new UnsupportedOperationException ( ) ; }
public void testLog2Floor ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { for ( RoundingMode mode : asList ( FLOOR , DOWN ) ) { int result = BigIntegerMath . log2 ( x , mode ) ; assertThat ( ZERO . setBit ( result ) ) . isAtMost ( x ) ; assertThat ( ZERO . setBit ( result + 1 ) ) . isGreaterThan ( x ) ; }
public boolean putAll ( @ParametricNullness K key , Iterable < ? extends V > values ) { throw new UnsupportedOperationException ( ) ; }
public void testPassTwoNullableArgsNeitherThrowsAnything ( ) { shouldPass ( new PassTwoNullableArgsNeitherThrowsAnything ( ) ) ; }
private final @Nullable V edgeValueOrDefaultInternal ( N nodeU , N nodeV , @Nullable V defaultValue ) { GraphConnections < N , V > connectionsU = nodeConnections . get ( nodeU ) ; V value = ( connectionsU = = null ) ? null : connectionsU . value ( nodeV ) ; / / TODO ( b / 192579700 ) : Use a ternary once it no longer confuses our nullness checker . if ( value = = null ) { return defaultValue ; }
public Range < C > gap ( Range < C > otherRange ) { / * * For an explanation of the basic principle behind this check , see * https: / / stackoverflow . com / a / 35754308 / 28465 * * In that explanation's notation , our `overlap` check would be `x1 < y2 & & y1 < x2` . We've * flipped one part of the check so that we're using "less than" in both cases ( rather than a * mix of "less than" and "greater than" ) . We've also switched to "strictly less than" rather * than "less than or equal to" because of * handwave * the difference between "endpoints of * inclusive ranges" and "Cuts . " * / if ( lowerBound . compareTo ( otherRange . upperBound ) < 0 & & otherRange . lowerBound . compareTo ( upperBound ) < 0 ) { throw new IllegalArgumentException ( "Ranges have a nonempty intersection: " + this + " , " + otherRange ) ; }
public final ImmutableList < TypeToken < ? extends Throwable > > getExceptionTypes ( ) { ImmutableList . Builder < TypeToken < ? extends Throwable > > builder = ImmutableList . builder ( ) ; for ( Type type : getGenericExceptionTypes ( ) ) { / / getGenericExceptionTypes ( ) will never return a type that's not exception @SuppressWarnings ( "unchecked" ) TypeToken < ? extends Throwable > exceptionType = ( TypeToken < ? extends Throwable > ) TypeToken . of ( type ) ; builder . add ( exceptionType ) ; }
public void testIterator_knownOrderRemoveSupported ( ) { runIteratorTest ( MODIFIABLE , IteratorTester . KnownOrder . KNOWN_ORDER , getOrderedElements ( ) ) ; }
public void edgesConnecting_checkReturnedSetMutability ( ) { addNode ( N1 ) ; addNode ( N2 ) ; Set < String > edgesConnecting = network . edgesConnecting ( N1 , N2 ) ; assertThrows ( UnsupportedOperationException . class , ( ) - > edgesConnecting . add ( E23 ) ) ; addEdge ( N1 , N2 , E12 ) ; assertThat ( network . edgesConnecting ( N1 , N2 ) ) . containsExactlyElementsIn ( edgesConnecting ) ; }
public < T extends Base & Iterable < T > > void testGetGenericInterfaces_typeVariable_boundsAreClassWithFBoundedInterface ( ) { makeUnmodifiable ( TypeToken . of ( new TypeCapture < T > ( ) { }
public void testParse_maximumWeight ( ) { CacheBuilderSpec spec = parse ( "maximumWeight = 9000" ) ; assertThat ( spec . initialCapacity ) . isNull ( ) ; assertThat ( spec . maximumWeight ) . isEqualTo ( 9000L ) ; assertThat ( spec . concurrencyLevel ) . isNull ( ) ; assertThat ( spec . keyStrength ) . isNull ( ) ; assertThat ( spec . valueStrength ) . isNull ( ) ; assertThat ( spec . writeExpirationTimeUnit ) . isNull ( ) ; assertThat ( spec . accessExpirationTimeUnit ) . isNull ( ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . maximumWeight ( 9000 ) , CacheBuilder . from ( spec ) ) ; }
public void testFromByteArrayFails ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Shorts . fromByteArray ( new byte[] { 0x01 }
public String toString ( ) { return map . entrySet ( ) . toString ( ) ; }
public static < K extends Comparable , V extends Comparable > TreeMultimap < K , V > create ( ) { return new TreeMultimap < > ( Ordering . natural ( ) , Ordering . natural ( ) ) ; }
public @Nullable V remove ( @Nullable Object rowKey , @Nullable Object columnKey ) { return original . remove ( columnKey , rowKey ) ; }
public void testToArray_rightSizedArrayOfObject_ordered ( ) { Object[] array = new Object[getNumElements ( ) ] ; assertSame ( "toArray ( sameSizeObject[] ) should return the given array" , array , collection . toArray ( array ) ) ; expectArrayContentsInOrder ( getOrderedElements ( ) , array ) ; }
public @Nullable K firstKey ( ) { return sortedDelegate . firstKey ( ) ; }
private static boolean isSuccessor ( @Nullable Object value ) { return ( value ! = PRED ) & & ( value ! = null ) ; }
public void forTree_breadthFirst_emptyGraph ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Traverser . forTree ( createDirectedGraph ( ) ) . breadthFirst ( 'a' ) ) ; }
public ElementOrder < N > nodeOrder ( ) { return nodeOrder ; }
private static TestStringMultisetGenerator unionGenerator ( ) { return new TestStringMultisetGenerator ( ) { @Override protected Multiset < String > create ( String[] elements ) { Multiset < String > multiset1 = LinkedHashMultiset . create ( ) ; Multiset < String > multiset2 = LinkedHashMultiset . create ( ) ; for ( int i = 0 ; i < elements . length ; i + + ) { String element = elements[i] ; if ( multiset1 . contains ( element ) | | multiset2 . contains ( element ) ) { / / add to both ; the one already containing it will have more multiset1 . add ( element ) ; multiset2 . add ( element ) ; }
public void testUnregister_notRegistered ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > registry . unregister ( new StringSubscriber ( ) ) ) ; StringSubscriber s1 = new StringSubscriber ( ) ; registry . register ( s1 ) ; assertThrows ( IllegalArgumentException . class , ( ) - > registry . unregister ( new StringSubscriber ( ) ) ) ; registry . unregister ( s1 ) ; assertThrows ( IllegalArgumentException . class , ( ) - > registry . unregister ( s1 ) ) ; }
public Map < R , Map < C , V > > rowMap ( ) { return delegate ( ) . rowMap ( ) ; }
private static int expandedCapacity ( int oldCapacity , int minCapacity ) { if ( minCapacity < 0 ) { throw new AssertionError ( "cannot store more than MAX_VALUE elements" ) ; }
private static final Function < String , String > DECODE_FUNCTION = new Function < String , String > ( ) { @Override public String apply ( String input ) { return new String ( BaseEncoding . base64 ( ) . decode ( input ) , UTF_8 ) ; }
public void testAllPublicInstanceMethods ( Object instance ) { testInstanceMethods ( instance , Visibility . PUBLIC ) ; }
public int hashCode ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . hashCode ( ) ; }
public void testFlatMap_nullStream ( ) { SpliteratorTester . of ( ( ) - > CollectSpliterators . flatMap ( Arrays . spliterator ( new String[] { "abc" , "" , "de" , "f" , "g" , "" }
private static boolean hasConstructorUsableByGetChecked ( Class < ? extends Exception > exceptionClass ) { try { Exception unused = newWithCause ( exceptionClass , new Exception ( ) ) ; return true ; }
public < E extends T > E min ( @ParametricNullness E a , @ParametricNullness E b , @ParametricNullness E c , E . . . rest ) { return forwardOrder . max ( a , b , c , rest ) ; }
public static long min ( long . . . array ) { checkArgument ( array . length > 0 ) ; long min = flip ( array[0] ) ; for ( int i = 1 ; i < array . length ; i + + ) { long next = flip ( array[i] ) ; if ( next < min ) { min = next ; }
public void testOr_applyNoArgs ( ) { assertEvalsToFalse ( Predicates . or ( ) ) ; }
public HostAndPort requireBracketsForIPv6 ( ) { checkArgument ( ! hasBracketlessColons , "Possible bracketless IPv6 literal: %s" , host ) ; return this ; }
public static < N , E > ImmutableNetwork < N , E > copyOf ( Network < N , E > network ) { return ( network instanceof ImmutableNetwork ) ? ( ImmutableNetwork < N , E > ) network : new ImmutableNetwork < N , E > ( network ) ; }
public Set < K > keySet ( ) { Set < K > result = keySet ; return ( result = = null ) ? keySet = createKeySet ( ) : result ; }
public void testNewDataOutput_writeBoolean ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; out . writeBoolean ( true ) ; out . writeBoolean ( false ) ; byte[] expected = { ( byte ) 1 , ( byte ) 0 }
public double populationStandardDeviation ( ) { return Math . sqrt ( populationVariance ( ) ) ; }
public @Nullable Object waitForValue ( ) { return null ; }
public @Nullable V remove ( @Nullable Object key ) { return containsKey ( key ) ? unfiltered . remove ( key ) : null ; }
public void testAsList_isAView ( ) { byte[] array = { ( byte ) 0 , ( byte ) 1 }
protected boolean standardContains ( @Nullable Object object ) { return Iterators . contains ( iterator ( ) , object ) ; }
public ListenableFuture < Integer > apply ( Throwable t ) { return secondary ; }
public @Nullable Entry < K , V > lowerEntry ( @ParametricNullness K key ) { return headMap ( key , false ) . lastEntry ( ) ; }
public void testUpdateRecency_onInvalidate ( ) { IdentityLoader < Integer > loader = identityLoader ( ) ; LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . maximumSize ( MAX_SIZE ) . concurrencyLevel ( 1 ) . build ( loader ) ; CacheTesting . checkRecency ( cache , MAX_SIZE , new Receiver < ReferenceEntry < Integer , Integer > > ( ) { @Override public void accept ( ReferenceEntry < Integer , Integer > entry ) { Integer key = entry . getKey ( ) ; cache . invalidate ( key ) ; }
public Test testsForUnmodifiableNavigableMap ( ) { return MapTestSuiteBuilder . using ( new TestStringSortedMapGenerator ( ) { @Override protected NavigableMap < String , String > create ( Entry < String , String > [] entries ) { return Collections . unmodifiableNavigableMap ( populate ( new TreeMap < > ( ) , entries ) ) ; }
public void testSaturatedAdd ( ) { for ( long a : ALL_LONG_CANDIDATES ) { for ( long b : ALL_LONG_CANDIDATES ) { assertOperationEquals ( a , b , "s + " , saturatedCast ( valueOf ( a ) . add ( valueOf ( b ) ) ) , LongMath . saturatedAdd ( a , b ) ) ; }
public void testFailOneArgDoesntThrowNpe ( ) { shouldFail ( new FailOneArgDoesntThrowNpe ( ) ) ; }
public void testSubRangeMapPutCoalescing ( ) { RangeMap < Integer , Integer > rangeMap = TreeRangeMap . create ( ) ; rangeMap . put ( Range . open ( 3 , 7 ) , 1 ) ; rangeMap . put ( Range . closed ( 9 , 10 ) , 2 ) ; rangeMap . put ( Range . closed ( 12 , 16 ) , 3 ) ; RangeMap < Integer , Integer > sub = rangeMap . subRangeMap ( Range . closed ( 5 , 11 ) ) ; assertEquals ( ImmutableMap . of ( Range . closedOpen ( 5 , 7 ) , 1 , Range . closed ( 9 , 10 ) , 2 ) , sub . asMapOfRanges ( ) ) ; sub . putCoalescing ( Range . closed ( 7 , 9 ) , 2 ) ; assertEquals ( ImmutableMap . of ( Range . closedOpen ( 5 , 7 ) , 1 , Range . closed ( 7 , 10 ) , 2 ) , sub . asMapOfRanges ( ) ) ; assertEquals ( ImmutableMap . of ( Range . open ( 3 , 7 ) , 1 , Range . closed ( 7 , 10 ) , 2 , Range . closed ( 12 , 16 ) , 3 ) , rangeMap . asMapOfRanges ( ) ) ; sub . putCoalescing ( Range . singleton ( 7 ) , 1 ) ; assertEquals ( ImmutableMap . of ( Range . closed ( 5 , 7 ) , 1 , Range . openClosed ( 7 , 10 ) , 2 ) , sub . asMapOfRanges ( ) ) ; assertEquals ( ImmutableMap . of ( Range . open ( 3 , 5 ) , 1 , Range . closed ( 5 , 7 ) , 1 , Range . openClosed ( 7 , 10 ) , 2 , Range . closed ( 12 , 16 ) , 3 ) , rangeMap . asMapOfRanges ( ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > sub . putCoalescing ( Range . open ( 9 , 12 ) , 5 ) ) ; }
public void testCancel ( ) { SettableFuture < String > f = SettableFuture . create ( ) ; FutureCallback < String > callback = new FutureCallback < String > ( ) { private final Object monitor = new Object ( ) ; private boolean called = false ; @Override public void onSuccess ( String result ) { fail ( "Was not expecting onSuccess ( ) to be called . " ) ; }
public static Funnel < byte[] > byteArrayFunnel ( ) { return ByteArrayFunnel . INSTANCE ; }
public Mall < Outdoor > . Shop < Electronics > bothOwnerTypeAndInnerTypeAreSubtypes ( Outlet < Outdoor > . Retailer < Electronics > retailer ) { return isSubtype ( retailer ) ; }
public UnsignedLong dividedBy ( UnsignedLong val ) { return fromLongBits ( UnsignedLongs . divide ( value , checkNotNull ( val ) . value ) ) ; }
public final E set ( int index , E element ) { throw new UnsupportedOperationException ( ) ; }
private static void populateForValues ( Table < Integer , Character , String > table , String[] elements ) { for ( int i = 0 ; i < elements . length ; i + + ) { table . put ( i , 'a' , elements[i] ) ; }
public void testTransposeTransposed ( ) { Table < Integer , String , Character > original = HashBasedTable . create ( ) ; assertSame ( original , transpose ( transpose ( original ) ) ) ; }
public void testSerialization_empty ( ) { Collection < String > c = ImmutableList . of ( ) ; assertSame ( c , SerializableTester . reserialize ( c ) ) ; }
private static < K , V > ImmutableMap < K , V > fromEntryList ( boolean throwIfDuplicateKeys , Collection < ? extends Entry < ? extends K , ? extends V > > entries ) { int size = entries . size ( ) ; switch ( size ) { case 0: return of ( ) ; case 1: Entry < ? extends K , ? extends V > entry = getOnlyElement ( entries ) ; return of ( ( K ) entry . getKey ( ) , ( V ) entry . getValue ( ) ) ; default: @SuppressWarnings ( "unchecked" ) / / TODO ( cpovirk ) : Consider storing an Entry < ? , ? > [] . Entry < K , V > [] entryArray = entries . toArray ( ( Entry < K , V > [] ) new Entry < ? , ? > [entries . size ( ) ] ) ; return new RegularImmutableMap < K , V > ( throwIfDuplicateKeys , entryArray ) ; }
public void testMax ( ) { assertThat ( max ( GREATEST ) ) . isEqualTo ( GREATEST ) ; assertThat ( max ( LEAST ) ) . isEqualTo ( LEAST ) ; assertThat ( max ( 8 . 0f , 6 . 0f , 7 . 0f , 5 . 0f , 3 . 0f , 0 . 0f , 9 . 0f ) ) . isEqualTo ( 9 . 0f ) ; assertThat ( max ( - 0f , 0f ) ) . isEqualTo ( 0f ) ; assertThat ( max ( 0f , - 0f ) ) . isEqualTo ( 0f ) ; assertThat ( max ( NUMBERS ) ) . isEqualTo ( GREATEST ) ; assertThat ( Float . isNaN ( max ( VALUES ) ) ) . isTrue ( ) ; }
public void testUnmodifiableIterable ( ) { List < String > list = newArrayList ( "a" , "b" , "c" ) ; Iterable < String > iterable = Iterables . unmodifiableIterable ( list ) ; Iterator < String > iterator = iterable . iterator ( ) ; iterator . next ( ) ; assertThrows ( UnsupportedOperationException . class , ( ) - > iterator . remove ( ) ) ; assertEquals ( "[a , b , c]" , iterable . toString ( ) ) ; }
private static < E extends @Nullable Object > boolean addAllImpl ( Multiset < E > self , AbstractMapBasedMultiset < ? extends E > elements ) { if ( elements . isEmpty ( ) ) { return false ; }
public Hasher putDouble ( double d ) { for ( Hasher hasher : hashers ) { hasher . putDouble ( d ) ; }
public boolean isSatisfied ( ) { return count < items . length ; }
public double addAndGet ( int i , double delta ) { return accumulateAndGet ( i , delta , Double::sum ) ; }
private static @Nullable Constructor < Thread > getBigThreadConstructor ( ) { try { return Thread . class . getConstructor ( ThreadGroup . class , Runnable . class , String . class , long . class , boolean . class ) ; }
public static short min ( short . . . array ) { checkArgument ( array . length > 0 ) ; short min = array[0] ; for ( int i = 1 ; i < array . length ; i + + ) { if ( array[i] < min ) { min = array[i] ; }
public List < String > create ( String[] elements ) { ImmutableMap . Builder < String , Integer > builder = ImmutableMap . builder ( ) ; for ( int i = 0 ; i < elements . length ; i + + ) { builder . put ( elements[i] , i ) ; }
public void testConstructor2 ( ) { AtomicDouble a = new AtomicDouble ( ) ; assertBitEquals ( 0 . 0 , a . get ( ) ) ; }
public void testSerialization_elementSet ( ) { Multiset < String > c = ImmutableSortedMultiset . of ( "a" , "b" , "a" ) ; Collection < String > copy = SerializableTester . reserializeAndAssert ( c . elementSet ( ) ) ; assertThat ( copy ) . containsExactly ( "a" , "b" ) . inOrder ( ) ; }
public RangeMap < K , V > subRangeMap ( Range < K > range ) { if ( ! range . isConnected ( subRange ) ) { return emptySubRangeMap ( ) ; }
public boolean containsValue ( @Nullable Object value ) { for ( @Nullable V[] row : array ) { for ( V element : row ) { if ( Objects . equals ( value , element ) ) { return true ; }
protected SortedSet < E > standardTailSet ( @ParametricNullness E fromElement ) { return tailSet ( fromElement , true ) ; }
public E get ( int index ) { return delegateList ( ) . get ( index ) ; }
public Iterator < Entry < K , V > > iterator ( ) { return new TransformedIterator < Entry < K , V > , Entry < K , V > > ( filteredEntrySet . iterator ( ) ) { @Override Entry < K , V > transform ( Entry < K , V > entry ) { return new ForwardingMapEntry < K , V > ( ) { @Override protected Entry < K , V > delegate ( ) { return entry ; }
protected @Nullable Entry < E > computeNext ( ) { while ( iterator1 . hasNext ( ) ) { Entry < E > entry1 = iterator1 . next ( ) ; E element = entry1 . getElement ( ) ; int count = min ( entry1 . getCount ( ) , multiset2 . count ( element ) ) ; if ( count > 0 ) { return immutableEntry ( element , count ) ; }
public void testGet_expireAfterAccess ( ) { Object computed = new Object ( ) ; LoadingCache < Object , Object > cache = CacheBuilder . newBuilder ( ) . expireAfterAccess ( 0 , SECONDS ) . removalListener ( listener ) . build ( constantLoader ( computed ) ) ; Object key = new Object ( ) ; assertThat ( cache . getUnchecked ( key ) ) . isSameInstanceAs ( computed ) ; RemovalNotification < Object , Object > notification = listener . remove ( ) ; assertThat ( notification . getKey ( ) ) . isSameInstanceAs ( key ) ; assertThat ( notification . getValue ( ) ) . isSameInstanceAs ( computed ) ; assertThat ( notification . getCause ( ) ) . isEqualTo ( RemovalCause . SIZE ) ; assertThat ( listener . isEmpty ( ) ) . isTrue ( ) ; checkEmpty ( cache ) ; }
private static byte @Nullable [] textToNumericFormatV4 ( String ipString ) { if ( IPV4_DELIMITER_MATCHER . countIn ( ipString ) + 1 ! = IPV4_PART_COUNT ) { return null ; / / Wrong number of parts }
public void testCopyOfEmptyMap ( ) { ImmutableBiMap < String , Integer > copy = ImmutableBiMap . copyOf ( Collections . < String , Integer > emptyMap ( ) ) ; assertEquals ( Collections . < String , Integer > emptyMap ( ) , copy ) ; assertSame ( copy , ImmutableBiMap . copyOf ( copy ) ) ; assertSame ( ImmutableBiMap . of ( ) , copy ) ; }
public void testCreate ( ) { Multiset < String > multiset = HashMultiset . create ( ) ; multiset . add ( "foo" , 2 ) ; multiset . add ( "bar" ) ; assertEquals ( 3 , multiset . size ( ) ) ; assertEquals ( 2 , multiset . count ( "foo" ) ) ; }
public * suffix was found . * / private int publicSuffixIndex ( ) { int publicSuffixIndexLocal = publicSuffixIndexCache ; if ( publicSuffixIndexLocal = = SUFFIX_NOT_INITIALIZED ) { publicSuffixIndexCache = publicSuffixIndexLocal = findSuffixOfType ( Optional . < PublicSuffixType > absent ( ) ) ; }
public void testNullPointerExceptions ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicStaticMethods ( EvictingQueue . class ) ; tester . testAllPublicConstructors ( EvictingQueue . class ) ; EvictingQueue < String > queue = EvictingQueue . create ( 5 ) ; / / The queue must be non - empty so it throws a NPE correctly queue . add ( "one" ) ; tester . testAllPublicInstanceMethods ( queue ) ; }
public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 , E e8 ) { return new RegularImmutableList < E > ( ImmutableList . < E > nullCheckedList ( e1 , e2 , e3 , e4 , e5 , e6 , e7 , e8 ) ) ; }
public void accept ( double t ) { this . holder = t ; }
public void testCheckState_simpleMessage_success ( ) { checkState ( true , IGNORE_ME ) ; }
public void testMapSplitter_extraValueDelimiter ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > COMMA_SPLITTER . withKeyValueSeparator ( " = " ) . split ( "a = 1 , c = 2 = " ) ) ; }
public @Nullable V compute ( K key , BiFunction < ? super K , ? super @Nullable V , ? extends @Nullable V > function ) { checkNotNull ( key ) ; checkNotNull ( function ) ; int hash = hash ( key ) ; return segmentFor ( hash ) . compute ( key , hash , function ) ; }
public int size ( ) { int size = 0 ; for ( E e : unfiltered ) { if ( predicate . apply ( e ) ) { size + + ; }
public void testNulls ( ) { try { Class . forName ( "java . lang . reflect . AnnotatedType" ) ; }
public static int gcd ( int a , int b ) { / * * The reason we require both arguments to be > = 0 is because otherwise , what do you return on * gcd ( 0 , Integer . MIN_VALUE ) ? BigInteger . gcd would return positive 2^31 , but positive 2^31 isn't * an int . * / checkNonNegative ( "a" , a ) ; checkNonNegative ( "b" , b ) ; if ( a = = 0 ) { / / 0 % b = = 0 , so b divides a , but the converse doesn't hold . / / BigInteger . gcd is consistent with this decision . return b ; }
public void testContains ( ) { assertThat ( Ints . contains ( EMPTY , ( int ) 1 ) ) . isFalse ( ) ; assertThat ( Ints . contains ( ARRAY1 , ( int ) 2 ) ) . isFalse ( ) ; assertThat ( Ints . contains ( ARRAY234 , ( int ) 1 ) ) . isFalse ( ) ; assertThat ( Ints . contains ( new int[] { ( int ) - 1 }
public void addEdge_parallelEdge_allowsParallelEdges ( ) { assume ( ) . that ( graphIsMutable ( ) ) . isTrue ( ) ; assume ( ) . that ( network . allowsParallelEdges ( ) ) . isTrue ( ) ; assertThat ( networkAsMutableNetwork . addEdge ( N1 , N2 , E12 ) ) . isTrue ( ) ; assertThat ( networkAsMutableNetwork . addEdge ( N2 , N1 , E21 ) ) . isTrue ( ) ; assertThat ( networkAsMutableNetwork . addEdge ( N1 , N2 , E12_A ) ) . isTrue ( ) ; assertThat ( network . edgesConnecting ( N1 , N2 ) ) . containsExactly ( E12 , E12_A , E21 ) ; }
public Hasher putChar ( char c ) { for ( Hasher hasher : hashers ) { hasher . putChar ( c ) ; }
public TypeParameterSignature apply ( TypeVariable < ? > from ) { return new TypeParameterSignature ( from ) ; }
public static < K extends @Nullable Object , V extends @Nullable Object > IdentityHashMap < K , V > newIdentityHashMap ( ) { return new IdentityHashMap < > ( ) ; }
public void testBase64OmitPadding ( ) { BaseEncoding enc = base64 ( ) . omitPadding ( ) ; testEncodingWithSeparators ( enc , "" , "" ) ; testEncodingWithSeparators ( enc , "f" , "Zg" ) ; testEncodingWithSeparators ( enc , "fo" , "Zm8" ) ; testEncodingWithSeparators ( enc , "foo" , "Zm9v" ) ; testEncodingWithSeparators ( enc , "foob" , "Zm9vYg" ) ; testEncodingWithSeparators ( enc , "fooba" , "Zm9vYmE" ) ; testEncodingWithSeparators ( enc , "foobar" , "Zm9vYmFy" ) ; }
public void testIdentityKeyEquality_strongKeys ( ) { testIdentityKeyEquality ( STRONG ) ; }
public void testPaddedPartition_general ( ) { ImmutableList < List < @Nullable Integer > > expectedElements = ImmutableList . of ( asList ( 1 , 2 , 3 ) , asList ( 4 , 5 , 6 ) , Arrays . < @Nullable Integer > asList ( 7 , null , null ) ) ; new IteratorTester < List < Integer > > ( 5 , IteratorFeature . UNMODIFIABLE , expectedElements , IteratorTester . KnownOrder . KNOWN_ORDER ) { @Override protected Iterator < List < Integer > > newTargetIterator ( ) { Iterator < Integer > source = Iterators . forArray ( 1 , 2 , 3 , 4 , 5 , 6 , 7 ) ; return Iterators . paddedPartition ( source , 3 ) ; }
public boolean matches ( char c ) { return c = = match ; }
public void testPlusForSpace ( ) { UnicodeEscaper basicEscaper = new PercentEscaper ( "" , false ) ; UnicodeEscaper plusForSpaceEscaper = new PercentEscaper ( "" , true ) ; UnicodeEscaper spaceEscaper = new PercentEscaper ( " " , false ) ; assertEquals ( "string%20with%20spaces" , basicEscaper . escape ( "string with spaces" ) ) ; assertEquals ( "string + with + spaces" , plusForSpaceEscaper . escape ( "string with spaces" ) ) ; assertEquals ( "string with spaces" , spaceEscaper . escape ( "string with spaces" ) ) ; }
public Builder < K , V > putAll ( Iterable < ? extends Entry < ? extends K , ? extends V > > entries ) { super . putAll ( entries ) ; return this ; }
private static void testSortDescending ( int[] input , int fromIndex , int toIndex , int[] expectedOutput ) { input = Arrays . copyOf ( input , input . length ) ; Ints . sortDescending ( input , fromIndex , toIndex ) ; assertThat ( input ) . isEqualTo ( expectedOutput ) ; }
public Builder < E > add ( E . . . elements ) { checkNotNull ( elements ) ; / / for GWT for ( E element : elements ) { add ( checkNotNull ( element ) ) ; }
public void testRemoveAt ( ) { long seed = new Random ( ) . nextLong ( ) ; Random random = new Random ( seed ) ; int heapSize = 999 ; int numberOfModifications = reduceIterationsIfGwt ( 500 ) ; MinMaxPriorityQueue < Integer > mmHeap = rawtypeToWildcard ( MinMaxPriorityQueue . expectedSize ( heapSize ) ) . create ( ) ; for ( int i = 0 ; i < heapSize ; i + + ) { mmHeap . add ( random . nextInt ( ) ) ; }
public < T extends @Nullable Object > boolean mightContain ( @ParametricNullness T object , Funnel < ? super T > funnel , int numHashFunctions , LockFreeBitArray bits ) { long bitSize = bits . bitSize ( ) ; byte[] bytes = Hashing . murmur3_128 ( ) . hashObject ( object , funnel ) . getBytesInternal ( ) ; long hash1 = lowerEight ( bytes ) ; long hash2 = upperEight ( bytes ) ; long combinedHash = hash1 ; for ( int i = 0 ; i < numHashFunctions ; i + + ) { / / Make the combined hash positive and indexable if ( ! bits . get ( ( combinedHash & Long . MAX_VALUE ) % bitSize ) ) { return false ; }
public void testImmutableMultiset ( ) { assertFreshInstance ( new TypeToken < ImmutableSortedSet < String > > ( ) { }
public Map < Object , Object > create ( List < ? > keys ) { return ImmutableMap . builder ( ) . putAll ( transform ( keys , k - > immutableEntry ( k , "dummy value" ) ) ) . buildOrThrow ( ) ; }
public void testCopyOf_shortcut_empty ( ) { Collection < String > c = ImmutableSortedMultiset . of ( ) ; assertSame ( c , ImmutableSortedMultiset . copyOf ( c ) ) ; }
public static @Nullable Integer tryParse ( String string , int radix ) { Long result = Longs . tryParse ( string , radix ) ; if ( result = = null | | result . longValue ( ) ! = result . intValue ( ) ) { return null ; }
public Set < Entry < K , V > > entrySet ( ) { Set < Entry < K , V > > es = entrySet ; return ( es ! = null ) ? es : ( entrySet = new EntrySet ( ) ) ; }
public NetworkBuilder < N , E > allowsSelfLoops ( boolean allowsSelfLoops ) { this . allowsSelfLoops = allowsSelfLoops ; return this ; }
private static String getUsername ( ) { / * * https: / / github . com / google / guava / issues / 6634: ProcessHandle has more accurate information , * but that class isn't available under all environments that we support . We use it if * available and fall back if not . * / String fromSystemProperty = requireNonNull ( USER_NAME . value ( ) ) ; try { Class < ? > processHandleClass = Class . forName ( "java . lang . ProcessHandle" ) ; Class < ? > processHandleInfoClass = Class . forName ( "java . lang . ProcessHandle$Info" ) ; Class < ? > optionalClass = Class . forName ( "java . util . Optional" ) ; / * * We don't * need * to use reflection to access Optional: It's available on all JDKs we * support , and Android code won't get this far , anyway , because ProcessHandle is * unavailable . But given how much other reflection we're using , we might as well use it * here , too , so that we don't need to also suppress an AndroidApiChecker error . * / Method currentMethod = processHandleClass . getMethod ( "current" ) ; Method infoMethod = processHandleClass . getMethod ( "info" ) ; Method userMethod = processHandleInfoClass . getMethod ( "user" ) ; Method orElseMethod = optionalClass . getMethod ( "orElse" , Object . class ) ; Object current = currentMethod . invoke ( null ) ; Object info = infoMethod . invoke ( current ) ; Object user = userMethod . invoke ( info ) ; return ( String ) requireNonNull ( orElseMethod . invoke ( user , fromSystemProperty ) ) ; }
public static ImmutableDoubleArray of ( double e0 , double e1 ) { return new ImmutableDoubleArray ( new double[] { e0 , e1 }
public void testEntrySetToTypedArrayMutationThrows ( ) { map . putInstance ( String . class , "test" ) ; @SuppressWarnings ( "unchecked" ) / / Should get a CCE later if cast is wrong Entry < ? , Object > entry = ( Entry < ? , Object > ) map . entrySet ( ) . toArray ( new Entry < ? , ? > [0] ) [0] ; assertEquals ( TypeToken . of ( String . class ) , entry . getKey ( ) ) ; assertEquals ( "test" , entry . getValue ( ) ) ; assertThrows ( UnsupportedOperationException . class , ( ) - > entry . setValue ( 1 ) ) ; }
public HashBasedTableColumnTest ( ) { super ( false , true , true , true , false ) ; }
public void testIsFinite ( ) { for ( float value : NUMBERS ) { assertThat ( Floats . isFinite ( value ) ) . isEqualTo ( Float . isFinite ( value ) ) ; }
public Test testsForConcurrentSkipListMapNatural ( ) { return NavigableMapTestSuiteBuilder . using ( new TestStringSortedMapGenerator ( ) { @Override protected SortedMap < String , String > create ( Entry < String , String > [] entries ) { return populate ( new ConcurrentSkipListMap < String , String > ( ) , entries ) ; }
public void testScale_index_computeInPlace_explicitVarargs ( ) { assertThat ( Quantiles . scale ( 10 ) . index ( 5 ) . computeInPlace ( 78 . 9 , 12 . 3 , 45 . 6 ) ) . isWithin ( ALLOWED_ERROR ) . of ( 45 . 6 ) ; }
public void testCartesianProduct_lastIndexOf ( ) { List < List < Integer > > actual = cartesianProduct ( list ( 1 , 1 ) , list ( 2 , 3 ) ) ; assertThat ( actual . lastIndexOf ( list ( 1 , 2 ) ) ) . isEqualTo ( 2 ) ; assertThat ( actual . lastIndexOf ( list ( 1 , 3 ) ) ) . isEqualTo ( 3 ) ; assertThat ( actual . lastIndexOf ( list ( 1 , 1 ) ) ) . isEqualTo ( - 1 ) ; assertThat ( actual . lastIndexOf ( list ( 1 ) ) ) . isEqualTo ( - 1 ) ; assertThat ( actual . lastIndexOf ( list ( 1 , 1 , 1 ) ) ) . isEqualTo ( - 1 ) ; }
public static boolean awaitUninterruptibly ( Condition condition , Duration timeout ) { return awaitUninterruptibly ( condition , toNanosSaturated ( timeout ) , NANOSECONDS ) ; }
public void testRetainAll ( ) { List < String > list = newArrayList ( "a" , "b" , "c" , "d" , "e" ) ; assertTrue ( Iterators . retainAll ( list . iterator ( ) , newArrayList ( "b" , "d" , "f" ) ) ) ; assertEquals ( newArrayList ( "b" , "d" ) , list ) ; assertFalse ( Iterators . retainAll ( list . iterator ( ) , newArrayList ( "b" , "e" , "d" ) ) ) ; assertEquals ( newArrayList ( "b" , "d" ) , list ) ; }
public void testIntersectAgainstMatchingEndpointsRange ( ) { GeneralRange < Integer > range = GeneralRange . range ( ORDERING , 2 , CLOSED , 4 , OPEN ) ; assertEquals ( GeneralRange . range ( ORDERING , 2 , OPEN , 4 , OPEN ) , range . intersect ( GeneralRange . range ( ORDERING , 2 , OPEN , 4 , CLOSED ) ) ) ; }
public FakeTicker advance ( long nanoseconds ) { nanos . addAndGet ( nanoseconds ) ; return this ; }
public boolean contains ( Object object ) { throw new UnsupportedOperationException ( ) ; }
public static < C extends Comparable > ImmutableRangeSet < C > of ( ) { return ( ImmutableRangeSet < C > ) EMPTY ; }
public static void sort ( long[] array ) { checkNotNull ( array ) ; sort ( array , 0 , array . length ) ; }
public Iterable < Entry < AnEnum , String > > order ( List < Entry < AnEnum , String > > insertionOrder ) { return orderEntriesByKey ( insertionOrder ) ; }
public void testPutCoalescing ( ) { / / { [0 . . 1 ) : 1 , [1 . . 2 ) : 1 , [2 . . 3 ) : 2 }
public boolean retainAll ( Collection < ? > collection ) { return removeIf ( element - > ! collection . contains ( element ) ) ; }
private static < I extends Iterator < ? > > Iterator < I > consumingForArray ( @Nullable I . . . elements ) { return new UnmodifiableIterator < I > ( ) { int index = 0 ; @Override public boolean hasNext ( ) { return index < elements . length ; }
public OutputStream openStream ( ) { return ByteStreams . nullOutputStream ( ) ; }
private static boolean isThreadBlockedOnInstanceOf ( Thread t , Class < ? > blocker ) { return t . getState ( ) = = Thread . State . WAITING & & blocker . isInstance ( LockSupport . getBlocker ( t ) ) ; }
public void testFilteredEntriesIllegalPutAll ( ) { Map < String , Integer > unfiltered = createUnfiltered ( ) ; unfiltered . put ( "cat" , 3 ) ; unfiltered . put ( "dog" , 2 ) ; unfiltered . put ( "horse" , 5 ) ; Map < String , Integer > filtered = Maps . filterEntries ( unfiltered , CORRECT_LENGTH ) ; assertEquals ( ImmutableMap . of ( "cat" , 3 , "horse" , 5 ) , filtered ) ; filtered . put ( "chicken" , 7 ) ; assertEquals ( ImmutableMap . of ( "cat" , 3 , "horse" , 5 , "chicken" , 7 ) , filtered ) ; assertThrows ( IllegalArgumentException . class , ( ) - > filtered . putAll ( ImmutableMap . of ( "sheep" , 5 , "cow" , 7 ) ) ) ; assertEquals ( ImmutableMap . of ( "cat" , 3 , "horse" , 5 , "chicken" , 7 ) , filtered ) ; }
public static < K extends @Nullable Object , V extends @Nullable Object > CompactLinkedHashMap < K , V > create ( ) { return new CompactLinkedHashMap < > ( ) ; }
public boolean equals ( @Nullable Object obj ) { if ( obj instanceof UnsignedInteger ) { UnsignedInteger other = ( UnsignedInteger ) obj ; return value = = other . value ; }
public void testMappedToNull ( ) { initMapWithNullValue ( ) ; assertEquals ( "Map . merge ( keyMappedToNull , value , function ) should return value" , v3 ( ) , getMap ( ) . merge ( getKeyForNullValue ( ) , v3 ( ) , ( oldV , newV ) - > { throw new AssertionFailedError ( "Should not call merge function if key was mapped to null" ) ; }
public Entry < String , Collection < String > > aboveSamplesGreater ( ) { return mapEntry ( "~~ c" , ( Collection < String > ) ImmutableSortedSet . of ( "~above" ) ) ; }
public @Nullable Entry < K , V > higherEntry ( K key ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate ( ) . higherEntry ( key ) ; }
public void testHashCodeMatchesAsMap ( ) { assertEquals ( multimap ( ) . asMap ( ) . hashCode ( ) , multimap ( ) . hashCode ( ) ) ; }
public void test6to4Addresses ( ) { ImmutableSet < String > non6to4Addresses = ImmutableSet . of ( "::1 . 2 . 3 . 4" , "3ffe::1" , "::" , "::1" ) ; for ( String non6to4Address : non6to4Addresses ) { InetAddress ip = InetAddresses . forString ( non6to4Address ) ; assertFalse ( InetAddresses . is6to4Address ( ( Inet6Address ) ip ) ) ; assertThrows ( "IllegalArgumentException expected for '" + non6to4Address + "'" , IllegalArgumentException . class , ( ) - > InetAddresses . get6to4IPv4Address ( ( Inet6Address ) ip ) ) ; }
public @Nullable V get ( @Nullable Object key ) { return forwardDelegate . get ( key ) ; }
public void testClear ( ) { MapMakerInternalMap < Object , Object , ? , ? > map = makeMap ( createMapMaker ( ) . concurrencyLevel ( 1 ) . initialCapacity ( 1 ) ) ; Segment < Object , Object , ? , ? > segment = map . segments[0] ; AtomicReferenceArray < ? extends InternalEntry < Object , Object , ? > > table = segment . table ; assertEquals ( 1 , table . length ( ) ) ; Object key = new Object ( ) ; Object value = new Object ( ) ; int hash = map . hash ( key ) ; InternalEntry < Object , Object , ? > entry = segment . newEntryForTesting ( key , hash , null ) ; segment . setValueForTesting ( entry , value ) ; segment . setTableEntryForTesting ( 0 , entry ) ; segment . readCount . incrementAndGet ( ) ; segment . count = 1 ; assertSame ( entry , table . get ( 0 ) ) ; segment . clear ( ) ; assertThat ( table . get ( 0 ) ) . isNull ( ) ; assertEquals ( 0 , segment . readCount . get ( ) ) ; assertEquals ( 0 , segment . count ) ; }
public @Nullable V getValue ( ) { return at ( rowIndex , columnIndex ) ; }
public static < E extends @Nullable Object > ArrayList < E > newArrayListWithExpectedSize ( int estimatedSize ) { return new ArrayList < > ( computeArrayListCapacity ( estimatedSize ) ) ; }
private int reversePosition ( int index ) { int size = size ( ) ; checkPositionIndex ( index , size ) ; return size - index ; }
public void testValuesIteration ( ) { List < Integer > addItems = ImmutableList . of ( 99 , 88 , 77 ) ; for ( int startIndex : new int[] { 0 , 3 , 5 }
public void testCount_nullAbsent ( ) { assertEquals ( "multiset . count ( null ) didn't return 0" , 0 , getMultiset ( ) . count ( null ) ) ; }
public void run ( ) { future . set ( "success" ) ; if ( ! future . isDone ( ) ) { errorMessage . set ( "Set call exited before future was complete . " ) ; }
protected @Nullable E standardLower ( @ParametricNullness E e ) { return Iterators . getNext ( headSet ( e , false ) . descendingIterator ( ) , null ) ; }
public void testListenLaterSetAsynchronouslyLaterDelegateInterrupted ( ) { CountingRunnable before = new CountingRunnable ( ) ; CountingRunnable inBetween = new CountingRunnable ( ) ; CountingRunnable after = new CountingRunnable ( ) ; future . addListener ( before , directExecutor ( ) ) ; future . setFuture ( delegate ) ; future . addListener ( inBetween , directExecutor ( ) ) ; delegate . cancel ( true ) ; future . addListener ( after , directExecutor ( ) ) ; before . assertRun ( ) ; inBetween . assertRun ( ) ; after . assertRun ( ) ; }
public boolean equals ( @Nullable Object object ) { if ( object instanceof AsList ) { AsList that = ( AsList ) object ; return this . parent . equals ( that . parent ) ; }
public String toString ( ) { return "throwing ( ) " ; }
public static < T extends @Nullable Object > FluentIterable < T > concat ( Iterable < ? extends T > . . . inputs ) { return concatNoDefensiveCopy ( Arrays . copyOf ( inputs , inputs . length ) ) ; }
public boolean hasNext ( ) { for ( ; index < enumConstants . length ; index + + ) { if ( counts[index] > 0 ) { return true ; }
public SortedMap < K , ValueDifference < V > > entriesDiffering ( ) { return ( SortedMap < K , ValueDifference < V > > ) super . entriesDiffering ( ) ; }
public Builder < K , V > putAll ( K key , Iterable < ? extends V > values ) { if ( key = = null ) { throw new NullPointerException ( "null key in entry: null = " + Iterables . toString ( values ) ) ; }
public String toString ( ) { return AbstractExecutionThreadService . this . toString ( ) ; }
public void testCreate ( ) { EnumHashBiMap < Currency , String > bimap = EnumHashBiMap . create ( Currency . class ) ; assertTrue ( bimap . isEmpty ( ) ) ; assertEquals ( " { }
protected NavigableMap < K , V > delegate ( ) { return backingMap ; }
public Set < Entry < K , V > > entrySet ( ) { return new StandardEntrySet ( ) { @Override public Iterator < Entry < K , V > > iterator ( ) { return delegate ( ) . entrySet ( ) . iterator ( ) ; }
public TypeToken < ? > getType ( ) { return type ; }
public static Traverser < File > fileTraverser ( ) { return Traverser . forTree ( FILE_TREE ) ; }
private static < T extends Enum < T > > Map < String , WeakReference < ? extends Enum < ? > > > populateCache ( Class < T > enumClass ) { Map < String , WeakReference < ? extends Enum < ? > > > result = new HashMap < > ( ) ; for ( T enumInstance : EnumSet . allOf ( enumClass ) ) { result . put ( enumInstance . name ( ) , new WeakReference < Enum < ? > > ( enumInstance ) ) ; }
public void testForEachPair_oneEmpty ( ) { Streams . forEachPair ( Stream . of ( "a" ) , Stream . empty ( ) , ( a , b ) - > fail ( ) ) ; }
public Iterator < Entry < K , Collection < V > > > iterator ( ) { return Maps . asMapEntryIterator ( multimap . keySet ( ) , multimap::get ) ; }
public void testUnionEmptyNonempty ( ) { Multiset < String > ms1 = HashMultiset . create ( ) ; Multiset < String > ms2 = HashMultiset . create ( asList ( "a" , "b" , "a" ) ) ; assertEquals ( ms2 , union ( ms1 , ms2 ) ) ; }
public V getValue ( ) { return node . value ; }
public < T > void testWhere_incompatibleParameterizedTypeMapping ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > new TypeResolver ( ) . where ( new TypeCapture < Iterable < T > > ( ) { }
public void testFuzzyCompare6 ( ) { runTestFuzzyCompare ( 6 ) ; }
public void testIndexOf_arrayTarget ( ) { assertThat ( Ints . indexOf ( EMPTY , EMPTY ) ) . isEqualTo ( 0 ) ; assertThat ( Ints . indexOf ( ARRAY234 , EMPTY ) ) . isEqualTo ( 0 ) ; assertThat ( Ints . indexOf ( EMPTY , ARRAY234 ) ) . isEqualTo ( - 1 ) ; assertThat ( Ints . indexOf ( ARRAY234 , ARRAY1 ) ) . isEqualTo ( - 1 ) ; assertThat ( Ints . indexOf ( ARRAY1 , ARRAY234 ) ) . isEqualTo ( - 1 ) ; assertThat ( Ints . indexOf ( ARRAY1 , ARRAY1 ) ) . isEqualTo ( 0 ) ; assertThat ( Ints . indexOf ( ARRAY234 , ARRAY234 ) ) . isEqualTo ( 0 ) ; assertThat ( Ints . indexOf ( ARRAY234 , new int[] { ( int ) 2 , ( int ) 3 }
public void testAwaitTimeoutMultiInterruptNoExpire ( ) { TimedLatch latch = new TimedLatch ( / * countdownInMillis = * / 100 ) ; repeatedlyInterruptTestThread ( tearDownStack ) ; latch . awaitSuccessfully ( LONG_DELAY_MS ) ; assertInterrupted ( ) ; }
public void testCheckPositionIndex_withDesc_negative ( ) { IndexOutOfBoundsException expected = assertThrows ( IndexOutOfBoundsException . class , ( ) - > checkPositionIndex ( - 1 , 1 , "foo" ) ) ; assertThat ( expected ) . hasMessageThat ( ) . isEqualTo ( "foo ( - 1 ) must not be negative" ) ; }
public static < E extends @Nullable Object > TreeSet < E > newTreeSet ( Comparator < ? super E > comparator ) { return new TreeSet < > ( checkNotNull ( comparator ) ) ; }
private static void runConcurrentlyMutatedTest ( Collection < Integer > initialContents , Iterable < ListFrobber > actionsToPerformConcurrently , WrapWithIterable wrap ) { ConcurrentlyMutatedList < Integer > concurrentlyMutatedList = newConcurrentlyMutatedList ( initialContents , actionsToPerformConcurrently ) ; Iterable < Integer > iterableToCopy = wrap = = WrapWithIterable . WRAP ? unmodifiableIterable ( concurrentlyMutatedList ) : concurrentlyMutatedList ; ImmutableList < Integer > copyOfIterable = ImmutableList . copyOf ( iterableToCopy ) ; assertTrue ( concurrentlyMutatedList . getAllStates ( ) . contains ( copyOfIterable ) ) ; }
protected void initMapWithNullValue ( ) { resetMap ( createArrayWithNullValue ( ) ) ; }
public long remove ( K key ) { Long result = map . remove ( key ) ; return ( result = = null ) ? 0L : result . longValue ( ) ; }
public void forEachEntry ( ObjIntConsumer < ? super E > action ) { checkNotNull ( action ) ; for ( AvlNode < E > node = firstNode ( ) ; node ! = header & & node ! = null & & ! range . tooHigh ( node . getElement ( ) ) ; node = node . succ ( ) ) { action . accept ( node . getElement ( ) , node . getCount ( ) ) ; }
public void testTransformPreservesIOOBEsThrownByFunction ( ) { assertThrows ( IndexOutOfBoundsException . class , ( ) - > transform ( ImmutableList . of ( "foo" , "bar" ) , new Function < String , String > ( ) { @Override public String apply ( String input ) { throw new IndexOutOfBoundsException ( ) ; }
public Entry < K , V > aboveSamplesLesser ( ) { return delegate ( ) . belowSamplesGreater ( ) ; }
public < T > T newProxy ( T target , Class < T > interfaceType , long timeoutDuration , TimeUnit timeoutUnit ) { checkNotNull ( target ) ; checkNotNull ( interfaceType ) ; checkNotNull ( timeoutUnit ) ; checkPositiveTimeout ( timeoutDuration ) ; checkArgument ( interfaceType . isInterface ( ) , "interfaceType must be an interface type" ) ; Set < Method > interruptibleMethods = findInterruptibleMethods ( interfaceType ) ; InvocationHandler handler = ( obj , method , args ) - > { Callable < @Nullable Object > callable = ( ) - > { try { return method . invoke ( target , args ) ; }
public void put ( K key , V value ) { throw new UnsupportedOperationException ( ) ; }
public void testRemoveAllNullKeyAbsent ( ) { assertEmpty ( multimap ( ) . removeAll ( null ) ) ; expectUnchanged ( ) ; }
public int compareTo ( Cut < Comparable < ? > > o ) { return ( o = = this ) ? 0 : 1 ; }
public static < T extends @Nullable Object > T getLast ( Iterable < ? extends T > iterable , @ParametricNullness T defaultValue ) { if ( iterable instanceof Collection ) { Collection < ? extends T > c = ( Collection < ? extends T > ) iterable ; if ( c . isEmpty ( ) ) { return defaultValue ; }
public void testUnderRegistrySuffix ( ) { for ( String name : SOMEWHERE_UNDER_RS ) { InternetDomainName domain = InternetDomainName . from ( name ) ; assertFalse ( name , domain . isRegistrySuffix ( ) ) ; assertTrue ( name , domain . hasRegistrySuffix ( ) ) ; assertTrue ( name , domain . isUnderRegistrySuffix ( ) ) ; }
public void testInvalidTopPrivateDomain ( ) { ImmutableSet < String > badCookieDomains = ImmutableSet . of ( "co . uk" , "foo" , "com" ) ; for ( String domain : badCookieDomains ) { assertThrows ( IllegalStateException . class , ( ) - > InternetDomainName . from ( domain ) . topPrivateDomain ( ) ) ; }
protected Map < String , Map < Integer , Character > > makePopulatedMap ( ) { TreeBasedTable < String , Integer , Character > table = makeTable ( ) ; populateTable ( table ) ; return table . rowMap ( ) . headMap ( "x" ) ; }
public SameBooleanInstance ( Boolean i ) { this . i = checkNotNull ( i ) ; }
public static Method getSetValueWithNullValuesAbsentMethod ( ) { return getMethod ( MapEntrySetTester . class , "testSetValueWithNullValuesAbsent" ) ; }
public void testRoundLog2Down ( ) { for ( double d : POSITIVE_FINITE_DOUBLE_CANDIDATES ) { int log2 = DoubleMath . log2 ( d , DOWN ) ; if ( d > = 1 . 0 ) { assertTrue ( log2 > = 0 ) ; assertTrue ( StrictMath . pow ( 2 . 0 , log2 ) < = d ) ; assertTrue ( StrictMath . pow ( 2 . 0 , log2 + 1 ) > d ) ; }
public static ExecutorService getExitingExecutorService ( ThreadPoolExecutor executor , long terminationTimeout , TimeUnit timeUnit ) { return new Application ( ) . getExitingExecutorService ( executor , terminationTimeout , timeUnit ) ; }
protected Scheduler scheduler ( ) { return new CustomScheduler ( ) { @Override @SuppressWarnings ( "ThreadPriorityCheck" ) / / doing our best to test for races protected Schedule getNextSchedule ( ) throws Exception { if ( state ( ) ! = State . STARTING ) { inGetNextSchedule . await ( ) ; Thread . yield ( ) ; throw new RuntimeException ( "boom" ) ; }
public @Nullable E pollLast ( ) { return isEmpty ( ) ? null : removeAndGet ( getMaxElementIndex ( ) ) ; }
public static CharMatcher javaLetterOrDigit ( ) { return JavaLetterOrDigit . INSTANCE ; }
public static ByteSourceFactory byteArraySourceFactory ( ) { return new ByteArraySourceFactory ( ) ; }
private static void testRotate ( double[] input , int distance , int fromIndex , int toIndex , double[] expectedOutput ) { input = Arrays . copyOf ( input , input . length ) ; Doubles . rotate ( input , distance , fromIndex , toIndex ) ; assertThat ( input ) . isEqualTo ( expectedOutput ) ; }
public void testConstantsFactorials ( ) { long expected = 1 ; for ( int i = 0 ; i < LongMath . factorials . length ; i + + , expected * = i ) { assertEquals ( expected , LongMath . factorials[i] ) ; }
public E removeLast ( ) { if ( isEmpty ( ) ) { throw new NoSuchElementException ( ) ; }
public boolean equals ( @Nullable Object obj ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . equals ( obj ) ; }
public void testPermutationSetContains ( ) { List < Integer > list = newArrayList ( 3 , 2 , 1 ) ; Collection < List < Integer > > permutationSet = Collections2 . permutations ( list ) ; assertTrue ( permutationSet . contains ( newArrayList ( 1 , 2 , 3 ) ) ) ; assertTrue ( permutationSet . contains ( newArrayList ( 2 , 3 , 1 ) ) ) ; assertFalse ( permutationSet . contains ( newArrayList ( 1 , 2 ) ) ) ; assertFalse ( permutationSet . contains ( newArrayList ( 1 , 1 , 2 , 3 ) ) ) ; assertFalse ( permutationSet . contains ( newArrayList ( 1 , 2 , 3 , 4 ) ) ) ; assertFalse ( permutationSet . contains ( null ) ) ; }
public List < T > topK ( ) { @SuppressWarnings ( "nullness" ) / / safe because we pass sort ( ) a range that contains real Ts T[] castBuffer = ( T[] ) buffer ; sort ( castBuffer , 0 , bufferSize , comparator ) ; if ( bufferSize > k ) { Arrays . fill ( buffer , k , buffer . length , null ) ; bufferSize = k ; threshold = buffer[k - 1] ; }
public Queue < Integer > create ( Comparator < Integer > comparator ) { return new PriorityQueue < > ( 11 , comparator ) ; }
public @Nullable Void getResult ( ) { return null ; }
public void testFromStringParseableNonsense ( ) { / / Examples of nonsense that gets through . checkFromStringCase ( "[[:]]" , 86 , "[:]" , 86 , false ) ; checkFromStringCase ( "x:y:z" , 87 , "x:y:z" , 87 , false ) ; checkFromStringCase ( "" , 88 , "" , 88 , false ) ; checkFromStringCase ( ":" , 99 , "" , 99 , false ) ; checkFromStringCase ( ":123" , - 1 , "" , 123 , true ) ; checkFromStringCase ( "\nOMG\t" , 89 , "\nOMG\t" , 89 , false ) ; }
public @Nullable Entry < K , V > higherEntry ( K key ) { return standardHigherEntry ( key ) ; }
public CharMatcher and ( CharMatcher other ) { return other . matches ( match ) ? this : none ( ) ; }
public void testFromArrayAndAppend ( ) { FluentIterable < TimeUnit > unused = FluentIterable . from ( TimeUnit . values ( ) ) . append ( SECONDS ) ; }
public void testIntegersOffset ( ) { assertEquals ( 1 , DiscreteDomain . integers ( ) . offset ( 0 , 1 ) . intValue ( ) ) ; assertEquals ( Integer . MAX_VALUE , DiscreteDomain . integers ( ) . offset ( Integer . MIN_VALUE , ( 1L < < 32 ) - 1 ) . intValue ( ) ) ; }
private void assertSetCountIncreasingFailure ( E element , int count ) { try { setCountNoCheckReturnValue ( element , count ) ; fail ( "a call to multiset . setCount ( ) to increase an element's count should throw" ) ; }
public Test testsForCopyOnWriteArrayList ( ) { return ListTestSuiteBuilder . using ( new TestStringListGenerator ( ) { @Override public List < String > create ( String[] elements ) { return new CopyOnWriteArrayList < > ( MinimalCollection . of ( elements ) ) ; }
public void testValues ( ) { BiMap < String , Integer > map = create ( ) ; Set < Integer > values = map . values ( ) ; assertTrue ( values instanceof SynchronizedSet ) ; assertSame ( mutex , ( ( SynchronizedSet < ? > ) values ) . mutex ) ; }
private static void assertIsPrimitive ( TypeToken < ? > type ) { assertTrue ( type . isPrimitive ( ) ) ; assertNotWrapper ( type ) ; assertEquals ( TypeToken . of ( Primitives . wrap ( ( Class < ? > ) type . getType ( ) ) ) , type . wrap ( ) ) ; }
public boolean apply ( Integer n ) { return ( n & 1 ) = = 0 ; / / isEven ( ) }
public Iterable < Entry < String , String > > order ( List < Entry < String , String > > insertionOrder ) { return insertionOrder ; }
public void testClosedOpen ( ) { Range < Integer > range = Range . closedOpen ( 5 , 8 ) ; checkContains ( range ) ; assertTrue ( range . hasLowerBound ( ) ) ; assertEquals ( 5 , ( int ) range . lowerEndpoint ( ) ) ; assertEquals ( CLOSED , range . lowerBoundType ( ) ) ; assertTrue ( range . hasUpperBound ( ) ) ; assertEquals ( 8 , ( int ) range . upperEndpoint ( ) ) ; assertEquals ( OPEN , range . upperBoundType ( ) ) ; assertFalse ( range . isEmpty ( ) ) ; assertEquals ( "[5 . . 8 ) " , range . toString ( ) ) ; reserializeAndAssert ( range ) ; }
public void testSetFutureSelf_toStringException ( ) { SettableFuture < String > orig = SettableFuture . create ( ) ; orig . setFuture ( new AbstractFuture < String > ( ) { @Override public String toString ( ) { throw new NullPointerException ( ) ; }
public void testFilterNothing ( ) { Iterator < String > unfiltered = Collections . < String > emptyList ( ) . iterator ( ) ; Iterator < String > filtered = filter ( unfiltered , new Predicate < String > ( ) { @Override public boolean apply ( String s ) { throw new AssertionFailedError ( "Should never be evaluated" ) ; }
private static final InvocationHandler X_RETURNER = new InvocationHandler ( ) { @Override public Object invoke ( Object proxy , Method method , Object[] args ) throws Throwable { return "x" ; }
public static < T extends @Nullable Object > AsyncCallable < T > asAsyncCallable ( Callable < T > callable , ListeningExecutorService listeningExecutorService ) { checkNotNull ( callable ) ; checkNotNull ( listeningExecutorService ) ; return ( ) - > listeningExecutorService . submit ( callable ) ; }
protected SortedMap < K , V > delegate ( ) { return delegate ; }
public void testGetGenericSuperclass_wildcard_boundIsClass ( ) { assertEquals ( TypeToken . of ( Object . class ) , TypeToken . of ( Types . subtypeOf ( Object . class ) ) . getGenericSuperclass ( ) ) ; assertEquals ( new TypeToken < Object[] > ( ) { }
public void testScale_index_compute_integerCollection ( ) { assertThat ( Quantiles . scale ( 10 ) . index ( 1 ) . compute ( SIXTEEN_SQUARES_INTEGERS ) ) . isWithin ( ALLOWED_ERROR ) . of ( SIXTEEN_SQUARES_DECILE_1 ) ; }
public Test allTests ( ) { TestSuite suite = new TestSuite ( "java . util Sets" ) ; suite . addTest ( testsForCheckedNavigableSet ( ) ) ; suite . addTest ( testsForEmptySet ( ) ) ; suite . addTest ( testsForEmptyNavigableSet ( ) ) ; suite . addTest ( testsForEmptySortedSet ( ) ) ; suite . addTest ( testsForSingletonSet ( ) ) ; suite . addTest ( testsForHashSet ( ) ) ; suite . addTest ( testsForLinkedHashSet ( ) ) ; suite . addTest ( testsForEnumSet ( ) ) ; suite . addTest ( testsForSynchronizedNavigableSet ( ) ) ; suite . addTest ( testsForTreeSetNatural ( ) ) ; suite . addTest ( testsForTreeSetWithComparator ( ) ) ; suite . addTest ( testsForCopyOnWriteArraySet ( ) ) ; suite . addTest ( testsForUnmodifiableSet ( ) ) ; suite . addTest ( testsForUnmodifiableNavigableSet ( ) ) ; suite . addTest ( testsForCheckedSet ( ) ) ; suite . addTest ( testsForCheckedSortedSet ( ) ) ; suite . addTest ( testsForAbstractSet ( ) ) ; suite . addTest ( testsForBadlyCollidingHashSet ( ) ) ; suite . addTest ( testsForConcurrentSkipListSetNatural ( ) ) ; suite . addTest ( testsForConcurrentSkipListSetWithComparator ( ) ) ; return suite ; }
public void testToImmutableMultisetCountFunction ( ) { BiPredicate < ImmutableMultiset < String > , ImmutableMultiset < String > > equivalence = ( ms1 , ms2 ) - > ms1 . equals ( ms2 ) & & ms1 . entrySet ( ) . asList ( ) . equals ( ms2 . entrySet ( ) . asList ( ) ) ; CollectorTester . of ( ImmutableMultiset . < Multiset . Entry < String > , String > toImmutableMultiset ( Multiset . Entry::getElement , Multiset . Entry::getCount ) , equivalence ) . expectCollects ( ImmutableMultiset . of ( ) ) . expectCollects ( ImmutableMultiset . of ( "a" , "a" , "b" , "c" , "c" , "c" ) , Multisets . immutableEntry ( "a" , 1 ) , Multisets . immutableEntry ( "b" , 1 ) , Multisets . immutableEntry ( "a" , 1 ) , Multisets . immutableEntry ( "c" , 3 ) ) ; }
public void clear ( ) { int oldSize = size ( ) ; / / calls refreshIfEmpty if ( oldSize = = 0 ) { return ; }
public SortedSet < K > keySet ( ) { return ( SortedSet < K > ) super . keySet ( ) ; }
public void testCopyOf_sortedSet_comparator ( ) { SortedSet < String > set = copyOf ( Sets . < String > newTreeSet ( ) ) ; assertSame ( Ordering . natural ( ) , set . comparator ( ) ) ; }
public static < T extends @Nullable Object > Enumeration < T > asEnumeration ( Iterator < T > iterator ) { checkNotNull ( iterator ) ; return new Enumeration < T > ( ) { @Override public boolean hasMoreElements ( ) { return iterator . hasNext ( ) ; }
public boolean isTopPrivateDomain ( ) { return publicSuffixIndex ( ) = = 1 ; }
public void testTryAcquireTimeoutMultiInterruptExpiredMultiPermit ( ) { / * * We don't "need" to schedule a release ( ) call at all here , but by doing * so , we come the closest we can to testing that the wait time is * appropriately decreased on each progressive tryAcquire ( ) call . * / TimedSemaphore semaphore = TimedSemaphore . createWithDelay ( LONG_DELAY_MS ) ; repeatedlyInterruptTestThread ( tearDownStack ) ; semaphore . tryAcquireUnsuccessfully ( 10 , 70 ) ; assertInterrupted ( ) ; }
public void testSqrtMatchesBigInteger ( ) { for ( long x : POSITIVE_LONG_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { / / Promote the long value ( rather than using longValue ( ) on the expected value ) to avoid / / any risk of truncation which could lead to a false positive . assertEquals ( BigIntegerMath . sqrt ( valueOf ( x ) , mode ) , valueOf ( LongMath . sqrt ( x , mode ) ) ) ; }
public final int nextIndex ( ) { return position ; }
public ExceptionWithManyConstructorsButOnlyOneThrowable ( String message , String a1 ) { super ( message ) ; }
private < T > @Nullable T getDummyValue ( TypeToken < T > type ) { Class < ? super T > rawType = type . getRawType ( ) ; @SuppressWarnings ( "unchecked" ) / / Assume all default values are generics safe . T defaultValue = ( T ) defaultValues . getInstance ( rawType ) ; if ( defaultValue ! = null ) { return defaultValue ; }
public void testEquals ( ) { / / sanity check on construction of copyOfWrappedSet assertThat ( wrappedSet ) . isEqualTo ( copyOfWrappedSet ) ; / / test that setToTest is still valid assertThat ( setToTest ) . isEqualTo ( wrappedSet ) ; assertThat ( setToTest ) . isEqualTo ( copyOfWrappedSet ) ; / / invalidate setToTest wrappedSet . remove ( 1 ) ; / / sanity check on update of wrappedSet assertThat ( wrappedSet ) . isNotEqualTo ( copyOfWrappedSet ) ; ImmutableSet < Integer > copyOfModifiedSet = ImmutableSet . copyOf ( wrappedSet ) ; / / { 2 , 3 }
public void testToString ( ) { Future < ? > unused = serializer . submitAsync ( firstCallable , directExecutor ( ) ) ; TestCallable secondCallable = new TestCallable ( SettableFuture . create ( ) ) ; Future < ? > second = serializer . submitAsync ( secondCallable , directExecutor ( ) ) ; assertThat ( secondCallable . called ) . isFalse ( ) ; assertThat ( second . toString ( ) ) . contains ( secondCallable . toString ( ) ) ; firstFuture . set ( null ) ; assertThat ( second . toString ( ) ) . contains ( secondCallable . future . toString ( ) ) ; }
private Outcome doCall ( ) { List < Object > arguments = new ArrayList < > ( ) ; if ( isGuarded ( method ) ) { arguments . add ( guard ) ; }
public @Nullable K higherKey ( @ParametricNullness K key ) { return sortedMap ( ) . higherKey ( key ) ; }
protected Collection < String > create ( String[] elements ) { Table < Integer , Character , String > table = HashBasedTable . create ( ) ; for ( int i = 0 ; i < elements . length ; i + + ) { table . put ( i , 'a' , "x" + checkNotNull ( elements[i] ) ) ; }
public void testGetNext_withDefault_empty_null ( ) { Iterator < String > iterator = emptyIterator ( ) ; assertThat ( Iterators . < @Nullable String > getNext ( iterator , null ) ) . isNull ( ) ; }
public String toString ( ) { return "Hashing . crc32c ( ) " ; }
public static double meanOf ( double . . . values ) { checkArgument ( values . length > 0 ) ; double mean = values[0] ; for ( int index = 1 ; index < values . length ; index + + ) { double value = values[index] ; if ( isFinite ( value ) & & isFinite ( mean ) ) { / / Art of Computer Programming vol . 2 , Knuth , 4 . 2 . 2 , ( 15 ) mean + = ( value - mean ) / ( index + 1 ) ; }
public static < T extends @Nullable Object > T[] concat ( T[] first , T[] second , Class < @NonNull T > type ) { T[] result = newArray ( type , first . length + second . length ) ; arraycopy ( first , 0 , result , 0 , first . length ) ; arraycopy ( second , 0 , result , first . length , second . length ) ; return result ; }
public void testSubList_get ( ) { List < E > list = getList ( ) ; int size = getNumElements ( ) ; List < E > copy = list . subList ( 0 , size ) ; List < E > head = list . subList ( 0 , size - 1 ) ; List < E > tail = list . subList ( 1 , size ) ; assertEquals ( list . get ( 0 ) , copy . get ( 0 ) ) ; assertEquals ( list . get ( size - 1 ) , copy . get ( size - 1 ) ) ; assertEquals ( list . get ( 1 ) , tail . get ( 0 ) ) ; assertEquals ( list . get ( size - 1 ) , tail . get ( size - 2 ) ) ; assertEquals ( list . get ( 0 ) , head . get ( 0 ) ) ; assertEquals ( list . get ( size - 2 ) , head . get ( size - 2 ) ) ; for ( List < E > subList : asList ( copy , head , tail ) ) { for ( int index : asList ( - 1 , subList . size ( ) ) ) { assertThrows ( IndexOutOfBoundsException . class , ( ) - > subList . get ( index ) ) ; }
public method asserting subtype relationship . * / final < T > T isSubtype ( T sub ) { Type returnType = method . getGenericReturnType ( ) ; Type paramType = getOnlyParameterType ( ) ; TestSubtype spec = method . getAnnotation ( TestSubtype . class ) ; assertWithMessage ( "%s is subtype of %s" , paramType , returnType ) . that ( TypeToken . of ( paramType ) . isSubtypeOf ( returnType ) ) . isTrue ( ) ; assertWithMessage ( "%s is supertype of %s" , returnType , paramType ) . that ( TypeToken . of ( returnType ) . isSupertypeOf ( paramType ) ) . isTrue ( ) ; if ( ! spec . suppressGetSubtype ( ) ) { assertThat ( getSubtype ( returnType , TypeToken . of ( paramType ) . getRawType ( ) ) ) . isEqualTo ( paramType ) ; }
private static @Nullable Collection < IOException > concat ( @Nullable Collection < IOException > exceptions , @Nullable Collection < IOException > other ) { if ( exceptions = = null ) { return other ; }
public Optional < V > edgeValue ( EndpointPair < N > endpoints ) { return delegate ( ) . edgeValue ( endpoints ) ; }
public ByteSource asByteSource ( Charset charset ) { return new AsByteSource ( charset ) ; }
public void forGraph_depthFirstPostOrderIterable_twoTrees ( ) { assertEqualCharNodes ( Traverser . forGraph ( TWO_TREES ) . depthFirstPostOrder ( charactersOf ( "a" ) ) , "ba" ) ; assertEqualCharNodes ( Traverser . forGraph ( TWO_TREES ) . depthFirstPostOrder ( charactersOf ( "ac" ) ) , "badc" ) ; }
public void testGetAndAdd ( ) { for ( double x : VALUES ) { for ( double y : VALUES ) { AtomicDouble a = new AtomicDouble ( x ) ; double z = a . getAndAdd ( y ) ; assertBitEquals ( x , z ) ; assertBitEquals ( x + y , a . get ( ) ) ; }
public void run ( ) { / * * firstFuture just completed , but AggregateFuture hasn't yet had time to record the * exception in seenExceptions . When we complete secondFuture with the same exception , * we want for AggregateFuture to still detect that it's been previously seen . * / secondFuture . setException ( sameInstance ) ; }
public void testSubSet_e_b_e_b ( ) { NavigableSet < String > set = create ( ) ; NavigableSet < String > subSet = set . subSet ( "a" , false , "b" , true ) ; assertTrue ( subSet instanceof SynchronizedNavigableSet ) ; assertSame ( MUTEX , ( ( SynchronizedNavigableSet < String > ) subSet ) . mutex ) ; }
private Splitter ( Strategy strategy ) { this ( strategy , false , CharMatcher . none ( ) , Integer . MAX_VALUE ) ; }
public void signalAll ( ) { lock . lock ( ) ; try { condition . signalAll ( ) ; }
public void testInvalidIntRange ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > ContiguousSet . closed ( 2 , 1 ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > ContiguousSet . closedOpen ( 2 , 1 ) ) ; }
public void testLimitSeparator ( ) { String simple = "a , b , c , d" ; Iterable < String > items = COMMA_SPLITTER . limit ( 2 ) . split ( simple ) ; assertThat ( items ) . containsExactly ( "a" , "b , c , d" ) . inOrder ( ) ; }
public boolean addAll ( Collection < ? extends V > collection ) { addAll ( 0 , collection ) ; return true ; }
public String toString ( ) { return "Functions . constant ( " + value + " ) " ; }
public void testGCDNegativeZeroThrows ( ) { for ( long a : NEGATIVE_LONG_CANDIDATES ) { assertThrows ( IllegalArgumentException . class , ( ) - > LongMath . gcd ( a , 0 ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > LongMath . gcd ( 0 , a ) ) ; }
public void testEquals_list ( ) { assertFalse ( "A List should never equal a Set . " , getSet ( ) . equals ( copyToList ( getSet ( ) ) ) ) ; }
public void testEnsureCapacity ( ) { assertThat ( Floats . ensureCapacity ( EMPTY , 0 , 1 ) ) . isSameInstanceAs ( EMPTY ) ; assertThat ( Floats . ensureCapacity ( ARRAY1 , 0 , 1 ) ) . isSameInstanceAs ( ARRAY1 ) ; assertThat ( Floats . ensureCapacity ( ARRAY1 , 1 , 1 ) ) . isSameInstanceAs ( ARRAY1 ) ; assertThat ( Arrays . equals ( new float[] { 1 . 0f , 0 . 0f , 0 . 0f }
public NavigableMap < Cut < C > , Range < C > > tailMap ( Cut < C > fromKey , boolean inclusive ) { return subMap ( Range . downTo ( fromKey , BoundType . forBoolean ( inclusive ) ) ) ; }
public void testEquals_longerList ( ) { Collection < E > moreElements = getSampleElements ( getNumElements ( ) + 1 ) ; assertFalse ( "Lists of different sizes should not be equal . " , getList ( ) . equals ( new ArrayList < E > ( moreElements ) ) ) ; }
public void testIdentity_same ( ) { Function < @Nullable String , @Nullable String > identity = Functions . identity ( ) ; assertThat ( identity . apply ( null ) ) . isNull ( ) ; assertSame ( "foo" , identity . apply ( "foo" ) ) ; }
public void testAnyMatch ( ) { ArrayList < String > list = new ArrayList < > ( ) ; FluentIterable < String > iterable = FluentIterable . < String > from ( list ) ; Predicate < String > predicate = equalTo ( "pants" ) ; assertFalse ( iterable . anyMatch ( predicate ) ) ; list . add ( "cool" ) ; assertFalse ( iterable . anyMatch ( predicate ) ) ; list . add ( "pants" ) ; assertTrue ( iterable . anyMatch ( predicate ) ) ; }
public void testContains ( ) { assertThat ( Floats . contains ( EMPTY , 1 . 0f ) ) . isFalse ( ) ; assertThat ( Floats . contains ( ARRAY1 , 2 . 0f ) ) . isFalse ( ) ; assertThat ( Floats . contains ( ARRAY234 , 1 . 0f ) ) . isFalse ( ) ; assertThat ( Floats . contains ( new float[] { - 1 . 0f }
public static Equivalence < Object > identity ( ) { return Identity . INSTANCE ; }
public void putAll ( RangeMap < Comparable < ? > , ? extends Object > rangeMap ) { if ( ! rangeMap . asMapOfRanges ( ) . isEmpty ( ) ) { throw new IllegalArgumentException ( "Cannot putAll ( nonEmptyRangeMap ) into an empty subRangeMap" ) ; }
public void testStream ( ) { ImmutableDoubleArray . of ( ) . stream ( ) . forEach ( i - > fail ( ) ) ; ImmutableDoubleArray . of ( 0 , 1 , 3 ) . subArray ( 1 , 1 ) . stream ( ) . forEach ( i - > fail ( ) ) ; assertThat ( ImmutableDoubleArray . of ( 0 , 1 , 3 ) . stream ( ) . toArray ( ) ) . isEqualTo ( new double[] { 0 , 1 , 3 }
public void testLinkedClear ( ) { ListMultimap < String , Integer > map = create ( ) ; map . put ( "foo" , 1 ) ; map . put ( "foo" , 2 ) ; map . put ( "bar" , 3 ) ; List < Integer > foos = map . get ( "foo" ) ; Collection < Integer > values = map . values ( ) ; assertEquals ( asList ( 1 , 2 ) , foos ) ; assertThat ( values ) . containsExactly ( 1 , 2 , 3 ) . inOrder ( ) ; map . clear ( ) ; assertEquals ( emptyList ( ) , foos ) ; assertThat ( values ) . isEmpty ( ) ; assertEquals ( "[]" , map . entries ( ) . toString ( ) ) ; assertEquals ( " { }
public void testFirst_sortedSet ( ) { SortedSet < String > sortedSet = ImmutableSortedSet . of ( "b" , "c" , "a" ) ; assertThat ( FluentIterable . from ( sortedSet ) . first ( ) ) . hasValue ( "a" ) ; }
public Collection < V > replaceValues ( @ParametricNullness K key , Iterable < ? extends V > values ) { Iterator < ? extends V > iterator = values . iterator ( ) ; if ( ! iterator . hasNext ( ) ) { return removeAll ( key ) ; }
public void remove ( Range < C > rangeToRemove ) { TreeRangeSet . this . add ( rangeToRemove ) ; }
private static < R , C , V > RegularImmutableTable < R , C , V > forCellsInternal ( Iterable < Cell < R , C , V > > cells , @Nullable Comparator < ? super R > rowComparator , @Nullable Comparator < ? super C > columnComparator ) { Set < R > rowSpaceBuilder = new LinkedHashSet < > ( ) ; Set < C > columnSpaceBuilder = new LinkedHashSet < > ( ) ; ImmutableList < Cell < R , C , V > > cellList = ImmutableList . copyOf ( cells ) ; for ( Cell < R , C , V > cell : cells ) { rowSpaceBuilder . add ( cell . getRowKey ( ) ) ; columnSpaceBuilder . add ( cell . getColumnKey ( ) ) ; }
public NoNullCheckNeededDespiteNotInstantiable ( NotInstantiable x ) { checkNotNull ( x ) ; }
public Test testsForEmptyNavigableSet ( ) { return SetTestSuiteBuilder . using ( new TestStringSortedSetGenerator ( ) { @Override public NavigableSet < String > create ( String[] elements ) { return Collections . emptyNavigableSet ( ) ; }
public static boolean removeOccurrences ( Multiset < ? > multisetToModify , Iterable < ? > occurrencesToRemove ) { if ( occurrencesToRemove instanceof Multiset ) { return removeOccurrences ( multisetToModify , ( Multiset < ? > ) occurrencesToRemove ) ; }
public void putEdge_nodesNotInGraph ( ) { assume ( ) . that ( graphIsMutable ( ) ) . isTrue ( ) ; graphAsMutableGraph . addNode ( N1 ) ; assertThat ( graphAsMutableGraph . putEdge ( N1 , N5 ) ) . isTrue ( ) ; assertThat ( graphAsMutableGraph . putEdge ( N4 , N1 ) ) . isTrue ( ) ; assertThat ( graphAsMutableGraph . putEdge ( N2 , N3 ) ) . isTrue ( ) ; assertThat ( graph . nodes ( ) ) . containsExactly ( N1 , N5 , N4 , N2 , N3 ) . inOrder ( ) ; assertThat ( graph . successors ( N1 ) ) . containsExactly ( N5 ) ; assertThat ( graph . successors ( N2 ) ) . containsExactly ( N3 ) ; assertThat ( graph . successors ( N3 ) ) . isEmpty ( ) ; assertThat ( graph . successors ( N4 ) ) . containsExactly ( N1 ) ; assertThat ( graph . successors ( N5 ) ) . isEmpty ( ) ; }
public String getKey ( ) { return next . getKey ( ) ; }
public NavigableMap < K , V > subMap ( K fromKey , boolean fromInclusive , K toKey , boolean toInclusive ) { return new SafeTreeMap < > ( delegate . subMap ( checkValid ( fromKey ) , fromInclusive , checkValid ( toKey ) , toInclusive ) ) ; }
public Map < K , Long > asMap ( ) { Map < K , Long > result = asMap ; return ( result = = null ) ? asMap = createAsMap ( ) : result ; }
public B named ( String name ) { if ( name . contains ( " ( " ) ) { throw new IllegalArgumentException ( "Eclipse hides all characters after " + "' ( ' ; please use '[]' or other characters instead of parentheses" ) ; }
private static void doParallelCacheOp ( int count , IntConsumer consumer ) { IntStream . range ( 0 , count ) . parallel ( ) . forEach ( consumer ) ; }
public K next ( ) { Entry < K , V > entry = entryIterator . next ( ) ; / / store local reference for thread - safety cacheEntry = entry ; return entry . getKey ( ) ; }
public @Nullable E lower ( @ParametricNullness E e ) { return Iterators . find ( unfiltered ( ) . headSet ( e , false ) . descendingIterator ( ) , predicate , null ) ; }
public @Nullable Entry < K , V > floorEntry ( @ParametricNullness K key ) { return forward ( ) . ceilingEntry ( key ) ; }
protected Map < String , String > create ( Entry < String , String > [] entries ) { Map < String , String > map = new HashMap < > ( ) ; putEntries ( map , entries ) ; map . putAll ( ENTRIES_TO_FILTER ) ; return Maps . filterEntries ( map , FILTER_ENTRIES ) ; }
public @Nullable V get ( @Nullable Object key ) { return StandardTable . this . get ( key , columnKey ) ; }
public static < T extends @Nullable Object , S extends T > Comparator < Iterable < S > > lexicographical ( Comparator < T > comparator ) { return new LexicographicalOrdering < S > ( checkNotNull ( comparator ) ) ; }
protected SortedMap < String , Integer > makeEmptyMap ( ) { return ImmutableSortedMap . of ( ) ; }
public @Nullable Collection < V > get ( @Nullable Object key ) { Collection < V > result = unfiltered . asMap ( ) . get ( key ) ; if ( result = = null ) { return null ; }
private static boolean isSmall ( int totalCharacters , int tableLength ) { return totalCharacters < = SmallCharMatcher . MAX_SIZE & & tableLength > ( totalCharacters * 4 * Character . SIZE ) ; / / err on the side of BitSetMatcher }
public static < V extends @Nullable Object > ListenableFuture < V > listenInPoolThread ( Future < V > future , Executor executor ) { checkNotNull ( executor ) ; if ( future instanceof ListenableFuture ) { return ( ListenableFuture < V > ) future ; }
public boolean equals ( @Nullable Object object ) { if ( object instanceof FunctionBasedConverter ) { FunctionBasedConverter < ? , ? > that = ( FunctionBasedConverter < ? , ? > ) object ; return this . forwardFunction . equals ( that . forwardFunction ) & & this . backwardFunction . equals ( that . backwardFunction ) ; }
public Hasher putShort ( short s ) { ByteBuffer scratch = scratch ( ) ; scratch . putShort ( s ) ; return update ( scratch , Shorts . BYTES ) ; }
public SortedSet < R > rowKeySet ( ) { return Collections . unmodifiableSortedSet ( delegate ( ) . rowKeySet ( ) ) ; }
public void execute ( Runnable command ) { command . run ( ) ; }
public String toString ( ) { return delegate . toString ( ) ; }
public SampleElements < Entry < Country , Currency > > samples ( ) { return new SampleElements < > ( mapEntry ( Country . CANADA , Currency . DOLLAR ) , mapEntry ( Country . CHILE , Currency . PESO ) , mapEntry ( Country . UK , Currency . POUND ) , mapEntry ( Country . JAPAN , Currency . YEN ) , mapEntry ( Country . SWITZERLAND , Currency . FRANC ) ) ; }
public void testImmutableMap ( ) { assertFreshInstance ( new TypeToken < ImmutableMap < String , Integer > > ( ) { }
public void replaceAll ( BiFunction < ? super V , ? super K , ? extends K > function ) { checkNotNull ( function ) ; Node < K , V > oldFirst = obverse . firstInKeyInsertionOrder ; clear ( ) ; for ( Node < K , V > node = oldFirst ; node ! = null ; node = node . nextInKeyInsertionOrder ) { put ( node . value , function . apply ( node . value , node . key ) ) ; }
private static < T extends Comparable < ? super T > > void assertLessThan ( T a , T b ) { if ( a . compareTo ( b ) > = 0 ) { fail ( String . format ( Locale . ROOT , "Expected %s to be less than %s" , a , b ) ) ; }
private HostSpecifier ( String canonicalForm ) { this . canonicalForm = canonicalForm ; }
private static void testSortDescending ( byte[] input , byte[] expectedOutput ) { input = Arrays . copyOf ( input , input . length ) ; UnsignedBytes . sortDescending ( input ) ; assertThat ( input ) . isEqualTo ( expectedOutput ) ; }
public void testGetUnchecked_null ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { assertThrows ( NullPointerException . class , ( ) - > cache . getUnchecked ( null ) ) ; checkEmpty ( cache ) ; }
public void testSequential ( ) { @SuppressWarnings ( { "unchecked" , "DoNotMock" }
public void testAsListIsEmpty ( ) { assertThat ( Booleans . asList ( EMPTY ) . isEmpty ( ) ) . isTrue ( ) ; assertThat ( Booleans . asList ( ARRAY_FALSE ) . isEmpty ( ) ) . isFalse ( ) ; }
public Integer maxValue ( ) { return DELEGATE . maxValue ( ) ; }
public Set < EndpointPair < N > > outEdges ( N node ) { checkNotNull ( node ) ; checkArgument ( nodes ( ) . contains ( node ) ) ; IncidentEdgeSet < N > incident = new IncidentEdgeSet < N > ( this , node , IncidentEdgeSet . EdgeType . OUTGOING ) { @Override public UnmodifiableIterator < EndpointPair < N > > iterator ( ) { return Iterators . unmodifiableIterator ( Iterators . transform ( graph . successors ( node ) . iterator ( ) , ( N successor ) - > graph . isDirected ( ) ? EndpointPair . ordered ( node , successor ) : EndpointPair . unordered ( node , successor ) ) ) ; }
public void testMultimapCollectorGenerics ( ) { ListMultimap < Integer , String > unused = Stream . of ( "foo" , "bar" , "quux" ) . collect ( toMultimap ( String::length , s - > s , rawtypeToWildcard ( MultimapBuilder . treeKeys ( ) ) . arrayListValues ( ) ::build ) ) ; }
public static < K , V > ImmutableMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 , K k6 , V v6 , K k7 , V v7 , K k8 , V v8 , K k9 , V v9 , K k10 , V v10 ) { return RegularImmutableMap . fromEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) , entryOf ( k4 , v4 ) , entryOf ( k5 , v5 ) , entryOf ( k6 , v6 ) , entryOf ( k7 , v7 ) , entryOf ( k8 , v8 ) , entryOf ( k9 , v9 ) , entryOf ( k10 , v10 ) ) ; }
public boolean tryAdvance ( Consumer < ? super R > action ) { if ( fromSpliterator . tryAdvance ( this ) ) { action . accept ( function . apply ( holder , index + + ) ) ; return true ; }
public void testContainsEntryWithNullValueAbsent ( ) { assertFalse ( multimap ( ) . entries ( ) . contains ( mapEntry ( k0 ( ) , null ) ) ) ; }
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( MultisetTestSuiteBuilder . using ( concurrentHashMultisetGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . GENERAL_PURPOSE , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . named ( "ConcurrentHashMultiset" ) . createTestSuite ( ) ) ; suite . addTest ( MultisetTestSuiteBuilder . using ( concurrentSkipListMultisetGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . KNOWN_ORDER , CollectionFeature . GENERAL_PURPOSE , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . named ( "ConcurrentSkipListMultiset" ) . createTestSuite ( ) ) ; suite . addTestSuite ( ConcurrentHashMultisetTest . class ) ; return suite ; }
public void testRetainAll_partialOverlapUnsupported ( ) { expectThrows ( partialOverlap ) ; expectUnchanged ( ) ; }
public static Method getAddNullSupportedMethod ( ) { return getMethod ( CollectionAddTester . class , "testAdd_nullSupported" ) ; }
public void testRemove_nullNotSupported ( ) { try { assertFalse ( "remove ( null ) should return false or throw NullPointerException" , collection . remove ( null ) ) ; }
public int indexOf ( @Nullable Object target ) { return target instanceof Integer ? parent . indexOf ( ( Integer ) target ) : - 1 ; }
public void testExplicitMax_b297601553 ( ) { Ordering < Integer > c = Ordering . explicit ( 1 , 2 , 3 ) ; / / TODO ( b / 297601553 ) : this should probably throw an CCE since 0 isn't explicitly listed assertEquals ( 0 , ( int ) c . max ( asList ( 0 ) ) ) ; IncomparableValueException expected = assertThrows ( IncomparableValueException . class , ( ) - > c . max ( asList ( 0 , 1 ) ) ) ; assertEquals ( 0 , expected . value ) ; }
protected void processRemaining ( ByteBuffer bb ) { long k1 = 0 ; long k2 = 0 ; length + = bb . remaining ( ) ; switch ( bb . remaining ( ) ) { case 15: k2 ^ = ( long ) toUnsignedInt ( bb . get ( 14 ) ) < < 48 ; / / fall through case 14: k2 ^ = ( long ) toUnsignedInt ( bb . get ( 13 ) ) < < 40 ; / / fall through case 13: k2 ^ = ( long ) toUnsignedInt ( bb . get ( 12 ) ) < < 32 ; / / fall through case 12: k2 ^ = ( long ) toUnsignedInt ( bb . get ( 11 ) ) < < 24 ; / / fall through case 11: k2 ^ = ( long ) toUnsignedInt ( bb . get ( 10 ) ) < < 16 ; / / fall through case 10: k2 ^ = ( long ) toUnsignedInt ( bb . get ( 9 ) ) < < 8 ; / / fall through case 9: k2 ^ = ( long ) toUnsignedInt ( bb . get ( 8 ) ) ; / / fall through case 8: k1 ^ = bb . getLong ( ) ; break ; case 7: k1 ^ = ( long ) toUnsignedInt ( bb . get ( 6 ) ) < < 48 ; / / fall through case 6: k1 ^ = ( long ) toUnsignedInt ( bb . get ( 5 ) ) < < 40 ; / / fall through case 5: k1 ^ = ( long ) toUnsignedInt ( bb . get ( 4 ) ) < < 32 ; / / fall through case 4: k1 ^ = ( long ) toUnsignedInt ( bb . get ( 3 ) ) < < 24 ; / / fall through case 3: k1 ^ = ( long ) toUnsignedInt ( bb . get ( 2 ) ) < < 16 ; / / fall through case 2: k1 ^ = ( long ) toUnsignedInt ( bb . get ( 1 ) ) < < 8 ; / / fall through case 1: k1 ^ = ( long ) toUnsignedInt ( bb . get ( 0 ) ) ; break ; default: throw new AssertionError ( "Should never get here . " ) ; }
public void testTest_transitive ( ) { Object group1Item1 = new TestObject ( 1 , 1 ) ; Object group1Item2 = new TestObject ( 1 , 2 ) ; Object group1Item3 = new TestObject ( 1 , 3 ) ; equivalenceMock . expectEquivalent ( group1Item1 , group1Item2 ) ; equivalenceMock . expectEquivalent ( group1Item1 , group1Item3 ) ; equivalenceMock . expectEquivalent ( group1Item2 , group1Item1 ) ; equivalenceMock . expectDistinct ( group1Item2 , group1Item3 ) ; equivalenceMock . expectEquivalent ( group1Item3 , group1Item1 ) ; equivalenceMock . expectEquivalent ( group1Item3 , group1Item2 ) ; equivalenceMock . expectHash ( group1Item1 , 1 ) ; equivalenceMock . expectHash ( group1Item2 , 1 ) ; equivalenceMock . expectHash ( group1Item3 , 1 ) ; equivalenceMock . replay ( ) ; try { tester . addEquivalenceGroup ( group1Item1 , group1Item2 , group1Item3 ) . test ( ) ; }
public void testIsEmpty ( ) { assertTrue ( FluentIterable . < String > from ( Collections . < String > emptyList ( ) ) . isEmpty ( ) ) ; assertFalse ( FluentIterable . < String > from ( Lists . newArrayList ( "foo" ) ) . isEmpty ( ) ) ; }
public void edgesConnecting_nodesNotInGraph ( ) { network . addNode ( N1 ) ; network . addNode ( N2 ) ; IllegalArgumentException e = assertThrows ( IllegalArgumentException . class , ( ) - > networkForTest . edgesConnecting ( N1 , NODE_NOT_IN_GRAPH ) ) ; assertNodeNotInGraphErrorMessage ( e ) ; e = assertThrows ( IllegalArgumentException . class , ( ) - > networkForTest . edgesConnecting ( NODE_NOT_IN_GRAPH , N2 ) ) ; assertNodeNotInGraphErrorMessage ( e ) ; e = assertThrows ( IllegalArgumentException . class , ( ) - > networkForTest . edgesConnecting ( NODE_NOT_IN_GRAPH , NODE_NOT_IN_GRAPH ) ) ; assertNodeNotInGraphErrorMessage ( e ) ; }
private void validate ( ) { / / Don't use checkState ( ) , because we don't want the overhead of generating the error message / / unless it's actually going to be used ; validate ( ) is called for all set method calls , so it / / needs to be fast . / / ( We could instead generate the message once , when the set is created , but zero is better . ) if ( ! validator . get ( ) ) { throw new IllegalStateException ( errorMessage . get ( ) ) ; }
protected Table < Character , String , Integer > makeTable ( ) { return ArrayTable . create ( asList ( 'a' , 'b' , 'c' ) , asList ( "one" , "two" , "three" , "four" ) ) ; }
public String collapseFrom ( CharSequence sequence , char replacement ) { / / This implementation avoids unnecessary allocation . int len = sequence . length ( ) ; for ( int i = 0 ; i < len ; i + + ) { char c = sequence . charAt ( i ) ; if ( matches ( c ) ) { if ( c = = replacement & & ( i = = len - 1 | | ! matches ( sequence . charAt ( i + 1 ) ) ) ) { / / a no - op replacement i + + ; }
private static void scheduleEnableWrites ( BlockingQueue < String > queue , long countdownInMillis ) { Runnable toRun = new EnableWrites ( queue , countdownInMillis ) ; / / TODO ( cpovirk ) : automatically fail the test if this thread throws Thread enablerThread = new Thread ( toRun ) ; enablerThread . start ( ) ; }
public boolean removeIf ( java . util . function . Predicate < ? super T > filter ) { checkNotNull ( filter ) ; return fromCollection . removeIf ( element - > filter . test ( function . apply ( element ) ) ) ; }
public void outDegree_selfLoop ( ) { assume ( ) . that ( network . allowsSelfLoops ( ) ) . isTrue ( ) ; addEdge ( N1 , N1 , E11 ) ; assertThat ( network . outDegree ( N1 ) ) . isEqualTo ( 2 ) ; addEdge ( N2 , N1 , E12 ) ; assertThat ( network . outDegree ( N1 ) ) . isEqualTo ( 3 ) ; }
public Set < E > incidentEdges ( N node ) { return delegate ( ) . incidentEdges ( node ) ; }
private NetworkConnections < N , E > addNodeInternal ( N node ) { NetworkConnections < N , E > connections = newConnections ( ) ; checkState ( nodeConnections . put ( node , connections ) = = null ) ; return connections ; }
public void testFromStringFailsWithShortInputs ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > HashCode . fromString ( "" ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > HashCode . fromString ( "7" ) ) ; HashCode unused = HashCode . fromString ( "7f" ) ; }
public K firstKey ( ) { return backingSet ( ) . first ( ) ; }
public void addAll ( PairedStats values ) { if ( values . count ( ) = = 0 ) { return ; }
public void removeAll ( RangeSet < C > other ) { throw new UnsupportedOperationException ( ) ; }
public void testSplitNullString ( ) { assertThrows ( NullPointerException . class , ( ) - > COMMA_SPLITTER . split ( null ) ) ; }
public boolean contains ( @Nullable Object obj ) { return adjacentNodeValues . containsKey ( obj ) ; }
public static < K , V > ImmutableMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 , K k6 , V v6 , K k7 , V v7 , K k8 , V v8 ) { return new RegularImmutableMap < K , V > ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) , entryOf ( k4 , v4 ) , entryOf ( k5 , v5 ) , entryOf ( k6 , v6 ) , entryOf ( k7 , v7 ) , entryOf ( k8 , v8 ) ) ; }
public void immutableGraphBuilder_appliesGraphBuilderConfig ( ) { ImmutableGraph < String > emptyGraph = GraphBuilder . directed ( ) . allowsSelfLoops ( true ) . nodeOrder ( ElementOrder . < String > natural ( ) ) . immutable ( ) . build ( ) ; assertThat ( emptyGraph . isDirected ( ) ) . isTrue ( ) ; assertThat ( emptyGraph . allowsSelfLoops ( ) ) . isTrue ( ) ; assertThat ( emptyGraph . nodeOrder ( ) ) . isEqualTo ( ElementOrder . < String > natural ( ) ) ; }
public List < String > apply ( Integer from ) { String value = String . valueOf ( from ) ; return ImmutableList . of ( value , value ) ; }
public void onSuccess ( String result ) { synchronized ( monitor ) { assertFalse ( wasCalled ) ; wasCalled = true ; assertEquals ( value , result ) ; }
public void testMergeWithRemappingFunctionReturningNullValue ( ) { / / { [1 . . 2 ) : 1 , [3 , 4 ) : 2 }
public void testSerialization ( ) { Multimap < String , Integer > multimap = createMultimap ( ) ; SerializableTester . reserializeAndAssert ( multimap ) ; assertEquals ( multimap . size ( ) , SerializableTester . reserialize ( multimap ) . size ( ) ) ; SerializableTester . reserializeAndAssert ( multimap . get ( "foo" ) ) ; LenientSerializableTester . reserializeAndAssertLenient ( multimap . keySet ( ) ) ; LenientSerializableTester . reserializeAndAssertLenient ( multimap . keys ( ) ) ; SerializableTester . reserializeAndAssert ( multimap . asMap ( ) ) ; Collection < Integer > valuesCopy = SerializableTester . reserialize ( multimap . values ( ) ) ; assertEquals ( HashMultiset . create ( multimap . values ( ) ) , HashMultiset . create ( valuesCopy ) ) ; }
public static < K , V > NavigableMapTestSuiteBuilder < K , V > using ( TestSortedMapGenerator < K , V > generator ) { NavigableMapTestSuiteBuilder < K , V > result = new NavigableMapTestSuiteBuilder < > ( ) ; result . usingGenerator ( generator ) ; return result ; }
protected int getNumEntries ( ) { return getNumElements ( ) ; }
public static ByteSource concat ( Iterable < ? extends ByteSource > sources ) { return new ConcatenatedByteSource ( sources ) ; }
public void testMappingWithSlope_maximalSlope ( ) { double x1 = 1 . 2 ; double y1 = 3 . 4 ; double slope = Double . MAX_VALUE ; LinearTransformation transformation = LinearTransformation . mapping ( x1 , y1 ) . withSlope ( slope ) ; assertThat ( transformation . isVertical ( ) ) . isFalse ( ) ; assertThat ( transformation . isHorizontal ( ) ) . isFalse ( ) ; assertThat ( transformation . slope ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( slope ) ; / / Note that we cannot test the actual mapping of points , as the results will be unreliable due / / to loss of precision with this value of the slope . }
public void publish ( @Nullable LogRecord record ) { synchronized ( lock ) { if ( record ! = null ) { list . add ( record ) ; }
public @Nullable Entry < K , V > floorEntry ( @ParametricNullness K key ) { return unmodifiableOrNull ( delegate . floorEntry ( key ) ) ; }
public void testAllEqual ( ) { Ordering < @Nullable Object > comparator = Ordering . allEqual ( ) ; assertSame ( comparator , comparator . reverse ( ) ) ; assertEquals ( 0 , comparator . compare ( null , null ) ) ; assertEquals ( 0 , comparator . compare ( new Object ( ) , new Object ( ) ) ) ; assertEquals ( 0 , comparator . compare ( "apples" , "oranges" ) ) ; assertSame ( comparator , reserialize ( comparator ) ) ; assertEquals ( "Ordering . allEqual ( ) " , comparator . toString ( ) ) ; List < String > strings = ImmutableList . of ( "b" , "a" , "d" , "c" ) ; assertEquals ( strings , comparator . sortedCopy ( strings ) ) ; assertEquals ( strings , comparator . immutableSortedCopy ( strings ) ) ; }
public void testBuildMutateBuild ( ) { ThreadFactory factory1 = builder . setPriority ( 1 ) . build ( ) ; assertEquals ( 1 , factory1 . newThread ( monitoredRunnable ) . getPriority ( ) ) ; ThreadFactory factory2 = builder . setPriority ( 2 ) . build ( ) ; assertEquals ( 1 , factory1 . newThread ( monitoredRunnable ) . getPriority ( ) ) ; assertEquals ( 2 , factory2 . newThread ( monitoredRunnable ) . getPriority ( ) ) ; }
public static void checkArgument ( boolean expression , String errorMessageTemplate , char p1 ) { if ( ! expression ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; }
protected Collection < Method > suppressForCheckedMap ( ) { return emptySet ( ) ; }
public void testLeastOfIterable_empty_0 ( ) { List < Integer > result = numberOrdering . leastOf ( Arrays . < Integer > asList ( ) , 0 ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . < Integer > of ( ) , result ) ; }
public static boolean isMaximum ( InetAddress address ) { byte[] addr = address . getAddress ( ) ; for ( byte b : addr ) { if ( b ! = ( byte ) 0xff ) { return false ; }
public String toString ( ) { return "ClassWithTerribleHashCode ( " + value + " ) " ; }
public String toString ( ) { return "Ints . stringConverter ( ) " ; }
public void testRemovePresentConcurrentWithIteration ( ) { assertThrows ( ConcurrentModificationException . class , ( ) - > { Iterator < E > iterator = collection . iterator ( ) ; assertTrue ( collection . remove ( e0 ( ) ) ) ; iterator . next ( ) ; }
public Collection < V > values ( ) { synchronized ( mutex ) { if ( valuesCollection = = null ) { valuesCollection = collection ( delegate ( ) . values ( ) , mutex ) ; }
public UnmodifiableTableRowMapTest ( ) { super ( false , false , false , false ) ; }
public String toString ( ) { return "Funnels . longFunnel ( ) " ; }
public @Nullable Spliterator < OutElementT > trySplit ( ) { Spliterator < InElementT > fromSplit = fromSpliterator . trySplit ( ) ; return ( fromSplit ! = null ) ? map ( fromSplit , function ) : null ; }
public void testAsListHashcode ( ) { assertThat ( Booleans . asList ( EMPTY ) . hashCode ( ) ) . isEqualTo ( 1 ) ; assertThat ( Booleans . asList ( ARRAY_FALSE ) . hashCode ( ) ) . isEqualTo ( Booleans . asList ( ARRAY_FALSE ) . hashCode ( ) ) ; List < Boolean > reference = Booleans . asList ( ARRAY_FALSE ) ; assertThat ( reference . hashCode ( ) ) . isEqualTo ( Booleans . asList ( ARRAY_FALSE ) . hashCode ( ) ) ; }
public Builder < K , V > orderEntriesByValue ( Comparator < ? super V > valueComparator ) { checkState ( this . valueComparator = = null , "valueComparator was already set" ) ; this . valueComparator = checkNotNull ( valueComparator , "valueComparator" ) ; return this ; }
public @Nullable K floorKey ( @ParametricNullness K key ) { return Maps . keyOrNull ( floorEntry ( key ) ) ; }
public < E extends T > E max ( Iterable < E > iterable ) { return forwardOrder . min ( iterable ) ; }
public static List < Method > getRemoveDuplicateInitializingMethods ( ) { return asList ( getMethod ( MultisetRemoveTester . class , "testRemove_some_occurrences_present" ) ) ; }
public void testToStringSize1 ( ) { table = ArrayTable . create ( ImmutableList . of ( "foo" ) , ImmutableList . of ( 1 ) ) ; table . put ( "foo" , 1 , 'a' ) ; assertEquals ( " { foo = { 1 = a }
protected List < String > create ( String[] elements ) { ImmutableSortedMap . Builder < Integer , String > builder = ImmutableSortedMap . naturalOrder ( ) ; for ( int i = 0 ; i < elements . length ; i + + ) { builder . put ( i , elements[i] ) ; }
public V[] createArray ( int length ) { / / noinspection UnnecessaryLocalVariable V[] vs = ( ( TestMapGenerator < K , V > ) mapGenerator . getInnerGenerator ( ) ) . createValueArray ( length ) ; return vs ; }
public final AnEnum[] createKeyArray ( int length ) { return new AnEnum[length] ; }
public void testGetSupertype_fromRawClass ( ) { assertEquals ( Types . newParameterizedType ( Iterable . class , List . class . getTypeParameters ( ) [0] ) , new TypeToken < List > ( ) { }
private static boolean isTimed ( Method method ) { return isLongTimeUnitBased ( method ) | | isDurationBased ( method ) ; }
public < T > NullPointerTester setDefault ( Class < T > type , T value ) { defaults . putInstance ( type , checkNotNull ( value ) ) ; return this ; }
public String transformEntry ( String key , Boolean value ) { * return value ? key : "yes" + key ; * }
public void testBuilder_withImmutableEntry ( ) { ImmutableMultimap < String , Integer > multimap = new Builder < String , Integer > ( ) . put ( immutableEntry ( "one" , 1 ) ) . build ( ) ; assertEquals ( asList ( 1 ) , multimap . get ( "one" ) ) ; }
public void testNulls ( ) { new NullPointerTester ( ) . testAllPublicStaticMethods ( Shorts . class ) ; }
private void insertIntoHashBucketsOnly ( Node < K , V > node ) { int keyBucket = node . keyHash & mask ; node . nextInKToVBucket = hashTableKToV[keyBucket] ; hashTableKToV[keyBucket] = node ; int valueBucket = node . valueHash & mask ; node . nextInVToKBucket = hashTableVToK[valueBucket] ; hashTableVToK[valueBucket] = node ; size + + ; modCount + + ; }
public T next ( ) { return delegate ( ) . next ( ) ; }
public static boolean isPowerOfTwo ( int x ) { return x > 0 & ( x & ( x - 1 ) ) = = 0 ; }
public void testToImmutableTableMergingNullMerge ( ) { Collector < Cell < String , String , Integer > , ? , ImmutableTable < String , String , Integer > > collector = toImmutableTable ( Cell::getRowKey , Cell::getColumnKey , Cell::getValue , ( v1 , v2 ) - > null ) ; assertThrows ( NullPointerException . class , ( ) - > Stream . of ( immutableCell ( "one" , "uno" , 1 ) , immutableCell ( "one" , "uno" , 2 ) ) . collect ( collector ) ) ; }
public static < E > ImmutableSet < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 ) { return create ( e1 , e2 , e3 , e4 , e5 ) ; }
public String type ( ) { return type ; }
public Spliterator < E > spliterator ( ) { return CollectSpliterators . indexed ( size ( ) , SPLITERATOR_CHARACTERISTICS , this::get ) ; }
private static TestCase generateWaitForWhenNotOccupyingTestCase ( Method method , boolean fair ) { boolean timed = isTimed ( method ) ; / / Not going to bother with all timeouts , just 0ms . String testName = method . getName ( ) + ( fair ? " ( fair ) " : " ( nonfair ) " ) + ( timed ? " ( 0ms ) " : " ( ) " ) + " / NotOccupying - > IMSE" ; return new TestCase ( testName ) { @Override protected void runTest ( ) throws Throwable { Monitor monitor = new Monitor ( fair ) ; FlagGuard guard = new FlagGuard ( monitor ) ; List < Object > arguments = new ArrayList < > ( ) ; arguments . add ( guard ) ; if ( isDurationBased ( method ) ) { arguments . add ( Duration . ZERO ) ; }
public Monitor ( boolean fair ) { this . fair = fair ; this . lock = new ReentrantLock ( fair ) ; }
public boolean containsValue ( @Nullable Object value ) { / / does not impact recency ordering if ( value = = null ) { return false ; }
private static Test testsForFilterNoNulls ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override public Set < String > create ( String[] elements ) { Set < String > unfiltered = new LinkedHashSet < > ( ) ; unfiltered . add ( "yyy" ) ; unfiltered . addAll ( ImmutableList . copyOf ( elements ) ) ; unfiltered . add ( "zzz" ) ; return Sets . filter ( unfiltered , Collections2Test . LENGTH_1 ) ; }
public int size ( ) { return delegate . size ( ) ; }
public void testSynchronizedSortedSetMultimap ( ) { SortedSetMultimap < String , Integer > multimap = synchronizedSortedSetMultimap ( TreeMultimap . < String , Integer > create ( ) ) ; multimap . putAll ( "foo" , asList ( 3 , - 1 , 2 , 4 , 1 ) ) ; multimap . putAll ( "bar" , asList ( 1 , 2 , 3 , 1 ) ) ; assertThat ( multimap . removeAll ( "foo" ) ) . containsExactly ( - 1 , 1 , 2 , 3 , 4 ) . inOrder ( ) ; assertFalse ( multimap . containsKey ( "foo" ) ) ; assertThat ( multimap . replaceValues ( "bar" , asList ( 6 , 5 ) ) ) . containsExactly ( 1 , 2 , 3 ) . inOrder ( ) ; assertThat ( multimap . get ( "bar" ) ) . containsExactly ( 5 , 6 ) . inOrder ( ) ; }
public String toString ( ) { return comparator + ":" + ( lowerBoundType = = CLOSED ? '[' : ' ( ' ) + ( hasLowerBound ? lowerEndpoint : " - \u221e" ) + ' , ' + ( hasUpperBound ? upperEndpoint : "\u221e" ) + ( upperBoundType = = CLOSED ? ']' : ' ) ' ) ; }
public void putEdge_doesntAllowSelfLoops ( ) { assume ( ) . that ( graphIsMutable ( ) ) . isTrue ( ) ; assume ( ) . that ( graph . allowsSelfLoops ( ) ) . isFalse ( ) ; IllegalArgumentException e = assertThrows ( IllegalArgumentException . class , ( ) - > graphAsMutableGraph . putEdge ( N1 , N1 ) ) ; assertThat ( e ) . hasMessageThat ( ) . contains ( ERROR_SELF_LOOP ) ; }
public void testFuzzyCompare7 ( ) { assertEquals ( 7 , size ( TOLERANCE_CANDIDATES ) ) ; }
public void testEquality ( ) { new EqualsTester ( ) . addEqualityGroup ( spec ( "1 . 2 . 3 . 4" ) , spec ( "1 . 2 . 3 . 4" ) ) . addEqualityGroup ( spec ( "2001:db8::1" ) , spec ( "2001:db8::1" ) , spec ( "[2001:db8::1]" ) ) . addEqualityGroup ( spec ( "2001:db8::2" ) ) . addEqualityGroup ( spec ( "google . com" ) , spec ( "google . com" ) ) . addEqualityGroup ( spec ( "www . google . com" ) ) . testEquals ( ) ; }
private void becomeSubsumedInto ( CloseableList otherCloseables ) { checkAndUpdateState ( OPEN , SUBSUMED ) ; otherCloseables . add ( closeables , directExecutor ( ) ) ; }
public void testBase32InvalidDecodings ( ) { / / These contain bytes not in the decodabet . assertFailsToDecode ( base32 ( ) , "A " , "Unrecognized character: 0x20" ) ; assertFailsToDecode ( base32 ( ) , "Wf2 ! " , "Unrecognized character: f" ) ; / / This sentence just isn't base32 ( ) encoded . assertFailsToDecode ( base32 ( ) , "let's not talk of love or chains ! " ) ; / / An 8n + { 1 , 3 , 6 }
public void testCombineUnordered ( ) { HashCode hash31 = HashCode . fromInt ( 31 ) ; HashCode hash32 = HashCode . fromInt ( 32 ) ; assertEquals ( hash32 , Hashing . combineUnordered ( ImmutableList . of ( hash32 ) ) ) ; assertEquals ( HashCode . fromInt ( 64 ) , Hashing . combineUnordered ( ImmutableList . of ( hash32 , hash32 ) ) ) ; assertEquals ( HashCode . fromInt ( 96 ) , Hashing . combineUnordered ( ImmutableList . of ( hash32 , hash32 , hash32 ) ) ) ; assertEquals ( Hashing . combineUnordered ( ImmutableList . of ( hash31 , hash32 ) ) , Hashing . combineUnordered ( ImmutableList . of ( hash32 , hash31 ) ) ) ; }
public void testCopyOf_iteratorContainingNull ( ) { Iterator < @Nullable String > iterator = Arrays . < @Nullable String > asList ( "a" , null , "b" ) . iterator ( ) ; assertThrows ( NullPointerException . class , ( ) - > ImmutableList . copyOf ( ( Iterator < String > ) iterator ) ) ; }
public void testAnonymousClassWithTwoParametersConstructor ( ) { abstract class Base { @SuppressWarnings ( "unused" ) / / called by reflection Base ( String s , int i ) { }
public AnnotatedType getAnnotatedType ( ) { return requireNonNull ( ( AnnotatedType ) annotatedType ) ; }
private FutureCombiner ( boolean allMustSucceed , ImmutableList < ListenableFuture < ? extends V > > futures ) { this . allMustSucceed = allMustSucceed ; this . futures = futures ; }
public void testCopyOf_subSet ( ) { SortedSet < String > set = of ( "e" , "a" , "f" , "b" , "d" , "c" ) ; SortedSet < String > subset = set . subSet ( "c" , "e" ) ; SortedSet < String > copy = copyOf ( subset ) ; assertEquals ( subset , copy ) ; }
public void testBoxedDoubleStreamToStats ( ) { Stats stats = megaPrimitiveDoubleStream ( ) . boxed ( ) . collect ( toStats ( ) ) ; assertThat ( stats . count ( ) ) . isEqualTo ( MEGA_STREAM_COUNT ) ; assertThat ( stats . mean ( ) ) . isWithin ( ALLOWED_ERROR * MEGA_STREAM_COUNT ) . of ( MEGA_STREAM_MEAN ) ; assertThat ( stats . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR * MEGA_STREAM_COUNT ) . of ( MEGA_STREAM_POPULATION_VARIANCE ) ; assertThat ( stats . min ( ) ) . isEqualTo ( MEGA_STREAM_MIN ) ; assertThat ( stats . max ( ) ) . isEqualTo ( MEGA_STREAM_MAX ) ; }
public void testGetOnlyElement_noDefault_valid ( ) { Iterable < String > iterable = singletonList ( "foo" ) ; assertEquals ( "foo" , getOnlyElement ( iterable ) ) ; }
public void testSetCount_removeNull_nullSupported ( ) { initCollectionWithNullElement ( ) ; assertSetCount ( null , 0 ) ; }
public void testMax ( ) { assertThat ( max ( LEAST ) ) . isEqualTo ( LEAST ) ; assertThat ( max ( GREATEST ) ) . isEqualTo ( GREATEST ) ; assertThat ( max ( ( int ) 8L , ( int ) 6L , ( int ) 7L , ( int ) 0x12345678L , ( int ) 0x5a4316b8L , ( int ) 0xff1a618bL , ( int ) 0L ) ) . isEqualTo ( ( int ) 0xff1a618bL ) ; }
public static < K extends @Nullable Object , V1 extends @Nullable Object , V2 extends @Nullable Object > Multimap < K , V2 > transformEntries ( Multimap < K , V1 > fromMap , EntryTransformer < ? super K , ? super V1 , V2 > transformer ) { return new TransformedEntriesMultimap < > ( fromMap , transformer ) ; }
public SortedMap < String , String > create ( Entry < String , String > [] entries ) { ImmutableSortedMap . Builder < String , String > builder = ImmutableSortedMap . naturalOrder ( ) ; for ( Entry < String , String > entry : entries ) { checkNotNull ( entry ) ; builder . put ( entry . getKey ( ) , entry . getValue ( ) ) ; }
public int lastIndexOf ( double target ) { for ( int i = end - 1 ; i > = start ; i - - ) { if ( areEqual ( array[i] , target ) ) { return i - start ; }
public void testAnonymousClassInConstructor ( ) { AnonymousClassInConstructor unused = new AnonymousClassInConstructor ( ) ; }
private static Iterable < CacheBuilder < Object , Object > > allKeyValueStrengthMakers ( ) { return ImmutableList . of ( createCacheBuilder ( ) , createCacheBuilder ( ) . weakValues ( ) , createCacheBuilder ( ) . softValues ( ) , createCacheBuilder ( ) . weakKeys ( ) , createCacheBuilder ( ) . weakKeys ( ) . weakValues ( ) , createCacheBuilder ( ) . weakKeys ( ) . softValues ( ) ) ; }
public Set < N > adjacentNodes ( ) { return Collections . unmodifiableSet ( adjacentNodesMultiset ( ) . elementSet ( ) ) ; }
private static int getByteArrayBaseOffset ( ) { if ( theUnsafe = = null ) { return OFFSET_UNSAFE_APPROACH_IS_UNAVAILABLE ; }
public static < K , V > ImmutableMap < K , V > of ( K k1 , V v1 , K k2 , V v2 ) { return new RegularImmutableMap < K , V > ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) ) ; }
public boolean contains ( Object o ) { return MapMakerInternalMap . this . containsValue ( o ) ; }
public boolean isTerminated ( ) { return delegate ( ) . isTerminated ( ) ; }
public void testSimpleWeights ( ) { RateLimiter rateLimiter = RateLimiter . create ( 1 . 0 , stopwatch ) ; rateLimiter . acquire ( 1 ) ; / / no wait rateLimiter . acquire ( 1 ) ; / / R1 . 00 , to repay previous rateLimiter . acquire ( 2 ) ; / / R1 . 00 , to repay previous rateLimiter . acquire ( 4 ) ; / / R2 . 00 , to repay previous rateLimiter . acquire ( 8 ) ; / / R4 . 00 , to repay previous rateLimiter . acquire ( 1 ) ; / / R8 . 00 , to repay previous assertEvents ( "R0 . 00" , "R1 . 00" , "R1 . 00" , "R2 . 00" , "R4 . 00" , "R8 . 00" ) ; }
public CacheStats minus ( CacheStats other ) { return new CacheStats ( max ( 0 , saturatedSubtract ( hitCount , other . hitCount ) ) , max ( 0 , saturatedSubtract ( missCount , other . missCount ) ) , max ( 0 , saturatedSubtract ( loadSuccessCount , other . loadSuccessCount ) ) , max ( 0 , saturatedSubtract ( loadExceptionCount , other . loadExceptionCount ) ) , max ( 0 , saturatedSubtract ( totalLoadTime , other . totalLoadTime ) ) , max ( 0 , saturatedSubtract ( evictionCount , other . evictionCount ) ) ) ; }
public static CharSink asCharSink ( File file , Charset charset , FileWriteMode . . . modes ) { return asByteSink ( file , modes ) . asCharSink ( charset ) ; }
public void testNewHashSetWithExpectedSizeSmall ( ) { HashSet < Integer > set = Sets . newHashSetWithExpectedSize ( 0 ) ; verifySetContents ( set , EMPTY_COLLECTION ) ; }
public void testCopyExceptions ( ) { / / test that exceptions are suppressed for ( ByteSource in : BROKEN_SOURCES ) { int suppressed = runSuppressionFailureTest ( in , newNormalByteSink ( ) ) ; assertEquals ( 0 , suppressed ) ; suppressed = runSuppressionFailureTest ( in , BROKEN_CLOSE_SINK ) ; assertEquals ( ( in = = BROKEN_OPEN_SOURCE ) ? 0 : 1 , suppressed ) ; }
protected Collection < Entry < K , V > > actualContents ( ) { return multimap . entries ( ) ; }
public int size ( ) { return getConnectingEdge ( ) = = null ? 0 : 1 ; }
public void testAddAtIndex_nullUnsupported ( ) { assertThrows ( NullPointerException . class , ( ) - > getList ( ) . add ( 0 , null ) ) ; expectUnchanged ( ) ; expectNullMissingWhenNullUnsupported ( "Should not contain null after unsupported add ( n , null ) " ) ; }
public long getAccessTime ( ) { return 0 ; }
public int compareTo ( Object o ) { return toString ( ) . compareTo ( o . toString ( ) ) ; }
public @Nullable Entry < K , V > firstEntry ( ) { return unmodifiableOrNull ( delegate . firstEntry ( ) ) ; }
public void testIsEmpty_yes ( ) { assertTrue ( "isEmpty ( ) should return true" , collection . isEmpty ( ) ) ; }
public boolean remove ( @Nullable Object o ) { if ( contains ( o ) ) { map ( ) . remove ( o ) ; return true ; }
protected ListenableFuture < String > buildChainingFuture ( ListenableFuture < Integer > inputFuture ) { return transform ( inputFuture , new ComposeFunction ( ) , directExecutor ( ) ) ; }
private static @Nullable Collection < IOException > deleteDirectoryContentsInsecure ( DirectoryStream < Path > dir ) { Collection < IOException > exceptions = null ; try { for ( Path entry : dir ) { exceptions = concat ( exceptions , deleteRecursivelyInsecure ( entry ) ) ; }
public void testWriteBytesToOversizedArrayLongMaxLength ( ) { byte[] dest = new byte[5] ; HASH_ABCD . writeBytesTo ( dest , 0 , 5 ) ; assertThat ( dest ) . isEqualTo ( new byte[] { ( byte ) 0xaa , ( byte ) 0xbb , ( byte ) 0xcc , ( byte ) 0xdd , ( byte ) 0x00 }
public boolean containsValue ( @Nullable Object value ) { return findEntryByValue ( value ) ! = ABSENT ; }
public static < K extends Comparable < ? super K > , V > ImmutableSortedMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 , K k6 , V v6 , K k7 , V v7 , K k8 , V v8 , K k9 , V v9 ) { / * * This explicit type parameter works around what seems to be a javac bug in certain * configurations: b / 339186525#comment6 * / return ImmutableSortedMap . fromEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) , entryOf ( k4 , v4 ) , entryOf ( k5 , v5 ) , entryOf ( k6 , v6 ) , entryOf ( k7 , v7 ) , entryOf ( k8 , v8 ) , entryOf ( k9 , v9 ) ) ; }
public void putEdge_allowsSelfLoops ( ) { assume ( ) . that ( graphIsMutable ( ) ) . isTrue ( ) ; assume ( ) . that ( graph . allowsSelfLoops ( ) ) . isTrue ( ) ; assertThat ( graphAsMutableGraph . putEdge ( N1 , N1 ) ) . isTrue ( ) ; assertThat ( graph . successors ( N1 ) ) . containsExactly ( N1 ) ; assertThat ( graph . predecessors ( N1 ) ) . containsExactly ( N1 ) ; }
public void testMinMaxNatural ( ) { assertThat ( min ( 1 , 2 ) ) . isEqualTo ( 1 ) ; assertThat ( min ( 2 , 1 ) ) . isEqualTo ( 1 ) ; assertThat ( max ( 1 , 2 ) ) . isEqualTo ( 2 ) ; assertThat ( max ( 2 , 1 ) ) . isEqualTo ( 2 ) ; }
public void testIndexOf_arrayTarget ( ) { assertThat ( Doubles . indexOf ( EMPTY , EMPTY ) ) . isEqualTo ( 0 ) ; assertThat ( Doubles . indexOf ( ARRAY234 , EMPTY ) ) . isEqualTo ( 0 ) ; assertThat ( Doubles . indexOf ( EMPTY , ARRAY234 ) ) . isEqualTo ( - 1 ) ; assertThat ( Doubles . indexOf ( ARRAY234 , ARRAY1 ) ) . isEqualTo ( - 1 ) ; assertThat ( Doubles . indexOf ( ARRAY1 , ARRAY234 ) ) . isEqualTo ( - 1 ) ; assertThat ( Doubles . indexOf ( ARRAY1 , ARRAY1 ) ) . isEqualTo ( 0 ) ; assertThat ( Doubles . indexOf ( ARRAY234 , ARRAY234 ) ) . isEqualTo ( 0 ) ; assertThat ( Doubles . indexOf ( ARRAY234 , new double[] { 2 . 0 , 3 . 0 }
public static < K , V > ConcurrentNavigableMapTestSuiteBuilder < K , V > using ( TestSortedMapGenerator < K , V > generator ) { ConcurrentNavigableMapTestSuiteBuilder < K , V > result = new ConcurrentNavigableMapTestSuiteBuilder < > ( ) ; result . usingGenerator ( generator ) ; return result ; }
public void testForEach ( ) { ImmutableDoubleArray . of ( ) . forEach ( i - > fail ( ) ) ; ImmutableDoubleArray . of ( 0 , 1 , 3 ) . subArray ( 1 , 1 ) . forEach ( i - > fail ( ) ) ; AtomicInteger count = new AtomicInteger ( 0 ) ; ImmutableDoubleArray . of ( 0 , 1 , 2 , 3 ) . forEach ( i - > assertThat ( i ) . isEqualTo ( ( double ) count . getAndIncrement ( ) ) ) ; assertThat ( count . get ( ) ) . isEqualTo ( 4 ) ; }
public void testDoubleValue ( ) { for ( long value : TEST_LONGS ) { UnsignedLong unsignedValue = UnsignedLong . fromLongBits ( value ) ; assertWithMessage ( "Double value of %s" , unsignedValue ) . that ( unsignedValue . doubleValue ( ) ) . isEqualTo ( unsignedValue . bigIntegerValue ( ) . doubleValue ( ) ) ; }
public ListIterator < V > listIterator ( int index ) { refreshIfEmpty ( ) ; return new WrappedListIterator ( index ) ; }
protected final V v3 ( ) { return e3 ( ) . getValue ( ) ; }
public void forGraph_breadthFirst_cycle ( ) { Traverser < Character > traverser = Traverser . forGraph ( CYCLE_GRAPH ) ; assertEqualCharNodes ( traverser . breadthFirst ( 'a' ) , "abcd" ) ; assertEqualCharNodes ( traverser . breadthFirst ( 'b' ) , "bcda" ) ; assertEqualCharNodes ( traverser . breadthFirst ( 'c' ) , "cdab" ) ; assertEqualCharNodes ( traverser . breadthFirst ( 'd' ) , "dabc" ) ; }
public SampleElements < Entry < String , Integer > > samples ( ) { return new SampleElements < > ( mapEntry ( "foo" , 5 ) , mapEntry ( "bar" , 3 ) , mapEntry ( "baz" , 17 ) , mapEntry ( "quux" , 1 ) , mapEntry ( "toaster" , - 2 ) ) ; }
private void assertThreeToThree ( ) { initThreeCopies ( ) ; assertSetCount ( e0 ( ) , 3 ) ; }
protected @Nullable Entry < K , V > standardFloorEntry ( @ParametricNullness K key ) { return headMap ( key , true ) . lastEntry ( ) ; }
public void testReplaceEntry_supportedPresent ( ) { assertTrue ( getMap ( ) . replace ( k0 ( ) , v0 ( ) , v3 ( ) ) ) ; expectReplacement ( entry ( k0 ( ) , v3 ( ) ) ) ; }
public boolean equals ( @Nullable Object obj ) { if ( obj instanceof SameInterfaceInstance ) { SameInterfaceInstance that = ( SameInterfaceInstance ) obj ; return s = = that . s ; }
public < T extends @Nullable Object > Future < T > submit ( Callable < T > task ) { return delegate ( ) . submit ( task ) ; }
protected Multimap < String , Integer > create ( ) { Multimap < String , Integer > unfiltered = HashMultimap . create ( ) ; unfiltered . put ( "foo" , 55556 ) ; unfiltered . put ( "badkey" , 1 ) ; return Multimaps . filterEntries ( unfiltered , ENTRY_PREDICATE ) ; }
public boolean hasNext ( ) { return i < array . length ; }
public static < K extends @Nullable Object , V extends @Nullable Object > SetMultimap < K , V > newSetMultimap ( Map < K , Collection < V > > map , Supplier < ? extends Set < V > > factory ) { return new CustomSetMultimap < > ( map , factory ) ; }
public void testCeilingPowerOfTwo ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { BigInteger result = BigIntegerMath . ceilingPowerOfTwo ( x ) ; assertTrue ( BigIntegerMath . isPowerOfTwo ( result ) ) ; assertThat ( result ) . isAtLeast ( x ) ; assertThat ( result ) . isLessThan ( x . add ( x ) ) ; }
public CharMatcher and ( CharMatcher other ) { return checkNotNull ( other ) ; }
public static < E extends @Nullable Object > int binarySearch ( List < ? extends E > list , @ParametricNullness E key , Comparator < ? super E > comparator , KeyPresentBehavior presentBehavior , KeyAbsentBehavior absentBehavior ) { checkNotNull ( comparator ) ; checkNotNull ( list ) ; checkNotNull ( presentBehavior ) ; checkNotNull ( absentBehavior ) ; if ( ! ( list instanceof RandomAccess ) ) { list = new ArrayList < > ( list ) ; }
public boolean containsKey ( @Nullable Object key ) { return StandardTable . this . contains ( key , columnKey ) ; }
public void normalNormal ( String first , Integer second ) { reactToNullParameters ( first , second ) ; }
public void testFrequency ( ) { List < @Nullable String > list = newArrayList ( "a" , null , "b" , null , "a" , null ) ; assertEquals ( 2 , frequency ( list . iterator ( ) , "a" ) ) ; assertEquals ( 1 , frequency ( list . iterator ( ) , "b" ) ) ; assertEquals ( 0 , frequency ( list . iterator ( ) , "c" ) ) ; assertEquals ( 0 , frequency ( list . iterator ( ) , 4 . 2 ) ) ; assertEquals ( 3 , frequency ( list . iterator ( ) , null ) ) ; }
private void runRemovalScheduler ( LoadingCache < String , Integer > cache , CountingRemovalListener < String , Integer > removalListener , WatchedCreatorLoader loader , FakeTicker ticker , String keyPrefix , long ttl ) { loader . setKeyPrefix ( keyPrefix ) ; int shift1 = 10 + VALUE_PREFIX ; loader . setValuePrefix ( shift1 ) ; / / fill with initial data for ( int i = 0 ; i < 10 ; i + + ) { assertThat ( cache . getUnchecked ( keyPrefix + i ) ) . isEqualTo ( i + shift1 ) ; }
private ValueHolder addHolder ( ) { ValueHolder valueHolder = new ValueHolder ( ) ; holderTail = holderTail . next = valueHolder ; return valueHolder ; }
private void startDraining ( boolean overflow ) { Java8Compatibility . flip ( byteBuffer ) ; if ( overflow & & byteBuffer . remaining ( ) = = 0 ) { byteBuffer = ByteBuffer . allocate ( byteBuffer . capacity ( ) * 2 ) ; }
public void testForArrayLengthWithPositionBoundaryCases ( ) { String[] array = { "foo" , "bar" }
public boolean equals ( @Nullable Object o ) { if ( o instanceof SequentialFunnel ) { SequentialFunnel < ? > funnel = ( SequentialFunnel < ? > ) o ; return elementFunnel . equals ( funnel . elementFunnel ) ; }
public HashingOutputStream ( HashFunction hashFunction , OutputStream out ) { super ( checkNotNull ( out ) ) ; this . hasher = checkNotNull ( hashFunction . newHasher ( ) ) ; }
public void testConverterDefaultValue ( ) { new ConverterDefaultValueChecker ( ) . check ( ) ; }
public void testParameterizedType ( ) { TypeToken < ImmutableList < Integer > > type = new TypeToken < ImmutableList < Integer > > ( ) { }
public void testClassWrapper ( ) { TypeToken < String > typeExpression = TypeToken . of ( String . class ) ; assertEquals ( String . class , typeExpression . getType ( ) ) ; assertEquals ( String . class , typeExpression . getRawType ( ) ) ; }
public int compare ( @ParametricNullness T a , @ParametricNullness T b ) { return forwardOrder . compare ( b , a ) ; }
public boolean contains ( @Nullable Object obj ) { if ( obj instanceof Entry ) { Entry < ? , ? > entry = ( Entry < ? , ? > ) obj ; if ( containsColumn ( entry . getKey ( ) ) ) { / / requireNonNull is safe because of the containsColumn check . return requireNonNull ( get ( entry . getKey ( ) ) ) . equals ( entry . getValue ( ) ) ; }
public void addListener ( Runnable listener , Executor exec ) { executionList . add ( listener , exec ) ; / / When a listener is first added , we run a task that will wait for the delegate to finish , / / and when it is done will run the listeners . if ( hasListeners . compareAndSet ( false , true ) ) { if ( delegate . isDone ( ) ) { / / If the delegate is already done , run the execution list immediately on the current / / thread . executionList . execute ( ) ; return ; }
public static ByteArrayDataOutput newDataOutput ( ) { return newDataOutput ( new ByteArrayOutputStream ( ) ) ; }
public static < N > EndpointPair < N > ordered ( N source , N target ) { return new Ordered < > ( source , target ) ; }
public void testTransformViewRandomAccess ( ) { List < Integer > fromList = new ArrayList < > ( SOME_LIST ) ; List < String > toList = transform ( fromList , SOME_FUNCTION ) ; assertTransformView ( fromList , toList ) ; }
public void incidentEdges_checkReturnedSetMutability ( ) { addNode ( N1 ) ; Set < String > incidentEdges = network . incidentEdges ( N1 ) ; assertThrows ( UnsupportedOperationException . class , ( ) - > incidentEdges . add ( E12 ) ) ; addEdge ( N1 , N2 , E12 ) ; assertThat ( network . incidentEdges ( N1 ) ) . containsExactlyElementsIn ( incidentEdges ) ; }
private MinimalIterable ( Iterator < E > iterator ) { this . iterator = iterator ; }
public void testIsUriInetAddress ( ) { assertTrue ( InetAddresses . isUriInetAddress ( "192 . 168 . 1 . 1" ) ) ; assertTrue ( InetAddresses . isUriInetAddress ( "[3ffe:0:0:0:0:0:0:1]" ) ) ; assertTrue ( InetAddresses . isUriInetAddress ( "[::ffff:192 . 0 . 2 . 1]" ) ) ; assertFalse ( InetAddresses . isUriInetAddress ( "[192 . 168 . 1 . 1" ) ) ; assertFalse ( InetAddresses . isUriInetAddress ( "192 . 168 . 1 . 1]" ) ) ; assertFalse ( InetAddresses . isUriInetAddress ( "" ) ) ; assertFalse ( InetAddresses . isUriInetAddress ( "192 . 168 . 999 . 888" ) ) ; assertFalse ( InetAddresses . isUriInetAddress ( "www . google . com" ) ) ; assertFalse ( InetAddresses . isUriInetAddress ( "1:2e" ) ) ; assertFalse ( InetAddresses . isUriInetAddress ( "[3ffe:0:0:0:0:0:0:1" ) ) ; assertFalse ( InetAddresses . isUriInetAddress ( "3ffe:0:0:0:0:0:0:1]" ) ) ; assertFalse ( InetAddresses . isUriInetAddress ( "3ffe:0:0:0:0:0:0:1" ) ) ; assertFalse ( InetAddresses . isUriInetAddress ( "::ffff:192 . 0 . 2 . 1" ) ) ; }
public static String getFileExtension ( Path path ) { Path name = path . getFileName ( ) ; / / null for empty paths and root - only paths if ( name = = null ) { return "" ; }
public void testBase64CannotUpperCase ( ) { assertThrows ( IllegalStateException . class , ( ) - > base64 ( ) . upperCase ( ) ) ; }
public void run ( ) { terminated . set ( shutdownAndAwaitTermination ( service , 1L , SECONDS ) ) ; interrupted . set ( Thread . currentThread ( ) . isInterrupted ( ) ) ; }
private boolean isExpired ( Timestamped < V > stamped ) { if ( ( expireAfterAccess = = UNSET_INT ) & & ( expireAfterWrite = = UNSET_INT ) ) { return false ; }
public void testRemoveKeyFromKeySetRemovesFromInverse ( ) { getMap ( ) . keySet ( ) . remove ( k0 ( ) ) ; expectMissing ( e0 ( ) ) ; }
public ImmutableSet < ClassInfo > getAllClasses ( ) { return FluentIterable . from ( resources ) . filter ( ClassInfo . class ) . toSet ( ) ; }
public int size ( ) { return AbstractNetwork . this . edges ( ) . size ( ) ; }
public boolean wasStreamOpened ( ) { return inputStreamOpened ; }
public void testRoundToDouble_smallNegative ( ) { new RoundToDoubleTester ( BigInteger . valueOf ( - 16 ) ) . setExpectation ( - 16 . 0 , RoundingMode . values ( ) ) . test ( ) ; }
public void testConstrainToRange ( ) { assertThat ( Ints . constrainToRange ( ( int ) 1 , ( int ) 0 , ( int ) 5 ) ) . isEqualTo ( ( int ) 1 ) ; assertThat ( Ints . constrainToRange ( ( int ) 1 , ( int ) 1 , ( int ) 5 ) ) . isEqualTo ( ( int ) 1 ) ; assertThat ( Ints . constrainToRange ( ( int ) 1 , ( int ) 3 , ( int ) 5 ) ) . isEqualTo ( ( int ) 3 ) ; assertThat ( Ints . constrainToRange ( ( int ) 0 , ( int ) - 5 , ( int ) - 1 ) ) . isEqualTo ( ( int ) - 1 ) ; assertThat ( Ints . constrainToRange ( ( int ) 5 , ( int ) 2 , ( int ) 2 ) ) . isEqualTo ( ( int ) 2 ) ; assertThrows ( IllegalArgumentException . class , ( ) - > Ints . constrainToRange ( ( int ) 1 , ( int ) 3 , ( int ) 2 ) ) ; }
public void testOr_supplier_absent ( ) { assertEquals ( "fallback" , Optional . absent ( ) . or ( Suppliers . ofInstance ( "fallback" ) ) ) ; }
public ImmutableList < String > parts ( ) { return parts ; }
public static Method getPutNullKeyUnsupportedMethod ( ) { return getMethod ( MapPutTester . class , "testPut_nullKeyUnsupported" ) ; }
public void testTryParseOfToHexStringIsOriginal ( ) { for ( float f : NUMBERS ) { checkTryParse ( f , Float . toHexString ( f ) ) ; }
protected List < Class < ? extends AbstractTester > > getTesters ( ) { List < Class < ? extends AbstractTester > > testers = copyToList ( super . getTesters ( ) ) ; testers . add ( NavigableSetNavigationTester . class ) ; return testers ; }
public void testPredicateMethods ( ) { Range < Integer > predicate = Range . closed ( 2 , 3 ) ; assertFalse ( predicate . apply ( 1 ) ) ; assertTrue ( predicate . apply ( 2 ) ) ; assertTrue ( predicate . apply ( 3 ) ) ; assertFalse ( predicate . apply ( 4 ) ) ; }
public void testAssertSubtypeTokenBeforeSupertypeToken_subtypeFirst ( ) { assertSubtypeTokenBeforeSupertypeToken ( ImmutableList . of ( TypeToken . of ( String . class ) , TypeToken . of ( CharSequence . class ) ) ) ; }
public ImmutableSet < Object > create ( List < ? > list ) { ImmutableSet . Builder < Object > builder = ImmutableSet . builder ( ) ; for ( Object o : list ) { builder . add ( o ) ; }
public void testFromLong ( ) { for ( ExpectedHashCode expected : expectedHashCodes ) { if ( expected . bytes . length = = 8 ) { HashCode fromLong = HashCode . fromLong ( expected . asLong ) ; assertExpectedHashCode ( expected , fromLong ) ; }
public void testTryFind_alwaysFalse_isPresent ( ) { Iterable < String > list = Lists . newArrayList ( "cool" , "pants" ) ; Iterator < String > iterator = list . iterator ( ) ; assertThat ( tryFind ( iterator , Predicates . alwaysFalse ( ) ) ) . isAbsent ( ) ; assertFalse ( iterator . hasNext ( ) ) ; }
private FreshValueGenerator newFreshValueGenerator ( ) { FreshValueGenerator generator = new FreshValueGenerator ( ) { @Override @Nullable Object interfaceMethodCalled ( Class < ? > interfaceType , Method method ) { return getDummyValue ( TypeToken . of ( interfaceType ) . method ( method ) . getReturnType ( ) ) ; }
public boolean equals ( @Nullable Object o ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . equals ( o ) ; }
public Set < E > edgesConnecting ( N node ) { return new EdgesConnecting < > ( ( ( BiMap < E , N > ) incidentEdgeMap ) . inverse ( ) , node ) ; }
public void testContains_no ( ) { assertFalse ( "containsKey ( notPresent ) should return false" , getMap ( ) . containsKey ( k3 ( ) ) ) ; }
public void add ( Range < C > rangeToAdd ) { TreeRangeSet . this . remove ( rangeToAdd ) ; }
private static TimeUnit chooseUnit ( long nanos ) { if ( DAYS . convert ( nanos , NANOSECONDS ) > 0 ) { return DAYS ; }
public void testAssertSubtypeTokenBeforeSupertypeToken_oneType ( ) { assertSubtypeTokenBeforeSupertypeToken ( ImmutableList . of ( TypeToken . of ( String . class ) ) ) ; }
public Hasher putInt ( int i ) { putByte ( ( byte ) i ) ; putByte ( ( byte ) ( i > > > 8 ) ) ; putByte ( ( byte ) ( i > > > 16 ) ) ; putByte ( ( byte ) ( i > > > 24 ) ) ; return this ; }
public void testCompare ( ) { for ( long x : VALUES ) { for ( long y : VALUES ) { / / note: spec requires only that the sign is the same assertWithMessage ( "%s , %s" , x , y ) . that ( Longs . compare ( x , y ) ) . isEqualTo ( Long . compare ( x , y ) ) ; }
protected Collection < Method > suppressForLinkedHashSet ( ) { return emptySet ( ) ; }
public void setAccessTime ( long time ) { this . accessTime = time ; }
public void transpose_directedGraph ( ) { MutableGraph < Integer > directedGraph = GraphBuilder . directed ( ) . allowsSelfLoops ( true ) . build ( ) ; directedGraph . putEdge ( N1 , N3 ) ; directedGraph . putEdge ( N3 , N1 ) ; directedGraph . putEdge ( N1 , N2 ) ; directedGraph . putEdge ( N1 , N1 ) ; directedGraph . putEdge ( N3 , N4 ) ; MutableGraph < Integer > expectedTranspose = GraphBuilder . directed ( ) . allowsSelfLoops ( true ) . build ( ) ; expectedTranspose . putEdge ( N3 , N1 ) ; expectedTranspose . putEdge ( N1 , N3 ) ; expectedTranspose . putEdge ( N2 , N1 ) ; expectedTranspose . putEdge ( N1 , N1 ) ; expectedTranspose . putEdge ( N4 , N3 ) ; Graph < Integer > transpose = transpose ( directedGraph ) ; assertThat ( transpose ) . isEqualTo ( expectedTranspose ) ; assertThat ( transpose ( transpose ) ) . isSameInstanceAs ( directedGraph ) ; AbstractGraphTest . validateGraph ( transpose ) ; for ( Integer node : directedGraph . nodes ( ) ) { assertThat ( directedGraph . inDegree ( node ) ) . isSameInstanceAs ( transpose . outDegree ( node ) ) ; assertThat ( directedGraph . outDegree ( node ) ) . isSameInstanceAs ( transpose . inDegree ( node ) ) ; }
public ImmutableSortedMap < K , V > tailMap ( K fromKeyParam , boolean inclusive ) { / / Declare a "true" local variable so that the Checker Framework will infer nullness . K fromKey = fromKeyParam ; checkNotNull ( fromKey ) ; if ( ! inclusive ) { fromKey = higher ( fromKey ) ; if ( fromKey = = null ) { return new Builder < K , V > ( this . comparator ) . build ( ) ; }
public SortedMapSubmapTestMapGenerator ( TestSortedMapGenerator < K , V > delegate , Bound to , Bound from ) { super ( delegate ) ; this . to = to ; this . from = from ; SortedMap < K , V > emptyMap = delegate . create ( ) ; this . entryComparator = entryComparator ( emptyMap . comparator ( ) ) ; / / derive values for inclusive filtering from the input samples SampleElements < Entry < K , V > > samples = delegate . samples ( ) ; List < Entry < K , V > > samplesList = asList ( samples . e0 ( ) , samples . e1 ( ) , samples . e2 ( ) , samples . e3 ( ) , samples . e4 ( ) ) ; sort ( samplesList , entryComparator ) ; this . firstInclusive = samplesList . get ( 0 ) . getKey ( ) ; this . lastInclusive = samplesList . get ( samplesList . size ( ) - 1 ) . getKey ( ) ; }
public static < T > T checkNotNull ( @Nullable T reference , String errorMessageTemplate , @Nullable Object p1 , @Nullable Object p2 , @Nullable Object p3 , @Nullable Object p4 ) { if ( reference = = null ) { throw new NullPointerException ( Platform . lenientFormat ( errorMessageTemplate , p1 , p2 , p3 , p4 ) ) ; }
public int hashCode ( ) { return System . identityHashCode ( s ) ; }
public void testNullInput ( ) { UnicodeEscaper e = SIMPLE_ESCAPER ; assertThrows ( NullPointerException . class , ( ) - > e . escape ( ( String ) null ) ) ; }
public static MultimapBuilderWithKeys < @Nullable Object > hashKeys ( int expectedKeys ) { checkNonnegative ( expectedKeys , "expectedKeys" ) ; return new MultimapBuilderWithKeys < @Nullable Object > ( ) { @Override < K extends @Nullable Object , V extends @Nullable Object > Map < K , Collection < V > > createMap ( ) { return Platform . newHashMapWithExpectedSize ( expectedKeys ) ; }
public final boolean isEmpty ( ) { return delegate . isEmpty ( ) ; }
public void testLinkedAsMapEntries ( ) { Multimap < String , Integer > map = create ( ) ; map . put ( "bar" , 1 ) ; map . put ( "foo" , 2 ) ; map . put ( "bar" , 3 ) ; Iterator < Entry < String , Collection < Integer > > > entries = map . asMap ( ) . entrySet ( ) . iterator ( ) ; Entry < String , Collection < Integer > > barEntry = entries . next ( ) ; assertEquals ( "bar" , barEntry . getKey ( ) ) ; assertThat ( barEntry . getValue ( ) ) . containsExactly ( 1 , 3 ) . inOrder ( ) ; assertThrows ( UnsupportedOperationException . class , ( ) - > barEntry . setValue ( Arrays . < Integer > asList ( ) ) ) ; entries . remove ( ) ; / / clear Entry < String , Collection < Integer > > fooEntry = entries . next ( ) ; assertEquals ( "foo" , fooEntry . getKey ( ) ) ; assertThat ( fooEntry . getValue ( ) ) . contains ( 2 ) ; assertFalse ( entries . hasNext ( ) ) ; assertEquals ( " { foo = [2] }
public final String getResourceName ( ) { return resourceName ; }
public SortedSet < E > subSet ( @ParametricNullness E fromElement , @ParametricNullness E toElement ) { return delegate ( ) . subSet ( fromElement , toElement ) ; }
public K belowSamplesLesser ( ) { return delegate . belowSamplesLesser ( ) . getKey ( ) ; }
public void forEach ( Consumer < ? super T > action ) { checkNotNull ( action ) ; unfiltered . forEach ( ( @ParametricNullness T a ) - > { if ( retainIfTrue . test ( a ) ) { action . accept ( a ) ; }
public void testGetCheckedTimed_withGoodAndBadExceptionConstructor ( ) { ExceptionWithGoodAndBadConstructor expected = assertThrows ( ExceptionWithGoodAndBadConstructor . class , ( ) - > getChecked ( FAILED_FUTURE_CHECKED_EXCEPTION , ExceptionWithGoodAndBadConstructor . class , 1 , SECONDS ) ) ; assertThat ( expected ) . hasCauseThat ( ) . isSameInstanceAs ( CHECKED_EXCEPTION ) ; }
private void setSuccessor ( int entry , int succ ) { requireSuccessors ( ) [entry] = succ + 1 ; }
public SortedMultiset < E > subMultiset ( E fromElement , BoundType fromBoundType , E toElement , BoundType toBoundType ) { / / These are checked elsewhere , but NullPointerTester wants them checked eagerly . checkNotNull ( fromBoundType ) ; checkNotNull ( toBoundType ) ; return tailMultiset ( fromElement , fromBoundType ) . headMultiset ( toElement , toBoundType ) ; }
private static int getAlphaIndex ( char c ) { / / Fold upper - case ASCII to lower - case and make zero - indexed and unsigned ( by casting to char ) . return ( char ) ( ( c | CASE_MASK ) - 'a' ) ; }
public SetMultimapBuilder < K0 , @Nullable Object > hashSetValues ( int expectedValuesPerKey ) { checkNonnegative ( expectedValuesPerKey , "expectedValuesPerKey" ) ; return new SetMultimapBuilder < K0 , @Nullable Object > ( ) { @Override public < K extends K0 , V extends @Nullable Object > SetMultimap < K , V > build ( ) { return Multimaps . newSetMultimap ( MultimapBuilderWithKeys . this . createMap ( ) , new HashSetSupplier < V > ( expectedValuesPerKey ) ) ; }
public void successors_selfLoop ( ) { assume ( ) . that ( graph . allowsSelfLoops ( ) ) . isTrue ( ) ; putEdge ( N1 , N1 ) ; assertThat ( graph . successors ( N1 ) ) . containsExactly ( N1 ) ; putEdge ( N1 , N2 ) ; assertThat ( graph . successors ( N1 ) ) . containsExactly ( N1 , N2 ) ; }
public void testOf_empty ( ) { assertEquals ( ImmutableList . of ( ) , Lists . newArrayList ( FluentIterable . of ( ) ) ) ; }
public void edgeValue_directed_backwards ( ) { graph = ValueGraphBuilder . directed ( ) . build ( ) ; graph . putEdgeValue ( 1 , 2 , "A" ) ; assertThat ( graph . edgeValue ( EndpointPair . ordered ( 2 , 1 ) ) ) . isEmpty ( ) ; }
public static long sqrt ( long x , RoundingMode mode ) { checkNonNegative ( "x" , x ) ; if ( fitsInInt ( x ) ) { return IntMath . sqrt ( ( int ) x , mode ) ; }
public void addEdge_parallelEdge_notAllowed ( ) { assume ( ) . that ( graphIsMutable ( ) ) . isTrue ( ) ; assume ( ) . that ( network . allowsParallelEdges ( ) ) . isFalse ( ) ; addEdge ( N1 , N2 , E12 ) ; IllegalArgumentException e = assertThrows ( IllegalArgumentException . class , ( ) - > networkAsMutableNetwork . addEdge ( N1 , N2 , EDGE_NOT_IN_GRAPH ) ) ; assertThat ( e ) . hasMessageThat ( ) . contains ( ERROR_PARALLEL_EDGE ) ; }
private void updateIndex ( ) { if ( index = = ABSENT | | index > obverse . size | | ! Objects . equals ( obverseValue , obverse . values[index] ) ) { index = obverse . findEntryByValue ( obverseValue ) ; }
public void testCopyOf_copiesImmutableSortedSet ( ) { ImmutableSortedSet < String > sortedSet = ImmutableSortedSet . of ( "a" ) ; ImmutableSet < String > copy = ImmutableSet . copyOf ( sortedSet ) ; assertNotSame ( sortedSet , copy ) ; }
public K getKey ( ) { return node . key ; }
public final double getAndAdd ( double delta ) { while ( true ) { long current = value . get ( ) ; double currentVal = longBitsToDouble ( current ) ; double nextVal = currentVal + delta ; long next = doubleToRawLongBits ( nextVal ) ; if ( value . compareAndSet ( current , next ) ) { return currentVal ; }
public void testConstrainToRange ( ) { assertThat ( Chars . constrainToRange ( ( char ) 1 , ( char ) 0 , ( char ) 5 ) ) . isEqualTo ( ( char ) 1 ) ; assertThat ( Chars . constrainToRange ( ( char ) 1 , ( char ) 1 , ( char ) 5 ) ) . isEqualTo ( ( char ) 1 ) ; assertThat ( Chars . constrainToRange ( ( char ) 1 , ( char ) 3 , ( char ) 5 ) ) . isEqualTo ( ( char ) 3 ) ; assertThat ( Chars . constrainToRange ( ( char ) 255 , ( char ) 250 , ( char ) 254 ) ) . isEqualTo ( ( char ) 254 ) ; assertThat ( Chars . constrainToRange ( ( char ) 5 , ( char ) 2 , ( char ) 2 ) ) . isEqualTo ( ( char ) 2 ) ; assertThrows ( IllegalArgumentException . class , ( ) - > Chars . constrainToRange ( ( char ) 1 , ( char ) 3 , ( char ) 2 ) ) ; }
public boolean waitForUninterruptibly ( Guard guard , Duration time ) { return waitForUninterruptibly ( guard , toNanosSaturated ( time ) , NANOSECONDS ) ; }
public static SpliteratorTester < Double > ofDouble ( Supplier < Spliterator . OfDouble > spliteratorSupplier ) { return new SpliteratorTester < > ( ImmutableSet . of ( ( ) - > new GeneralSpliteratorOfObject < > ( spliteratorSupplier . get ( ) ) , ( ) - > new GeneralSpliteratorOfPrimitive < > ( spliteratorSupplier . get ( ) , c - > c::accept ) ) ) ; }
public static < E extends @Nullable Object > HashMultiset < E > create ( ) { return create ( ObjectCountHashMap . DEFAULT_SIZE ) ; }
public void equivalent_edgeSetsDiffer ( ) { network . addEdge ( N1 , N2 , E12 ) ; MutableNetwork < Integer , String > g2 = createNetwork ( edgeType ) ; g2 . addEdge ( N1 , N2 , E13 ) ; assertThat ( network ) . isNotEqualTo ( g2 ) ; }
public void testColumnPutIllegal ( ) { table = create ( "foo" , 1 , 'a' , "bar" , 1 , 'b' , "foo" , 3 , 'c' ) ; Map < String , Character > map = table . column ( 3 ) ; IllegalArgumentException expected = assertThrows ( IllegalArgumentException . class , ( ) - > map . put ( "dog" , 'd' ) ) ; assertThat ( expected ) . hasMessageThat ( ) . isEqualTo ( "Row dog not in [foo , bar , cat]" ) ; }
protected @Nullable E computeNext ( ) { while ( iterator1 . hasNext ( ) ) { Entry < E > entry1 = iterator1 . next ( ) ; E element = entry1 . getElement ( ) ; if ( entry1 . getCount ( ) > multiset2 . count ( element ) ) { return element ; }
public void clear ( ) { obverse . clear ( ) ; }
public static ImmutableList < Character > charactersOf ( String string ) { return new StringAsImmutableList ( checkNotNull ( string ) ) ; }
public void testYStats ( ) { assertStatsApproxEqual ( EMPTY_STATS_ITERABLE , emptyAccumulator . yStats ( ) ) ; assertStatsApproxEqual ( EMPTY_STATS_ITERABLE , emptyAccumulatorByAddAllEmptyPairedStats . yStats ( ) ) ; assertStatsApproxEqual ( OTHER_ONE_VALUE_STATS , oneValueAccumulator . yStats ( ) ) ; assertStatsApproxEqual ( OTHER_ONE_VALUE_STATS , oneValueAccumulatorByAddAllEmptyPairedStats . yStats ( ) ) ; assertStatsApproxEqual ( OTHER_TWO_VALUES_STATS , twoValuesAccumulator . yStats ( ) ) ; assertStatsApproxEqual ( OTHER_TWO_VALUES_STATS , twoValuesAccumulatorByAddAllPartitionedPairedStats . yStats ( ) ) ; assertStatsApproxEqual ( OTHER_MANY_VALUES_STATS , manyValuesAccumulator . yStats ( ) ) ; assertStatsApproxEqual ( OTHER_MANY_VALUES_STATS , manyValuesAccumulatorByAddAllPartitionedPairedStats . yStats ( ) ) ; }
public int hashCode ( ) { return Objects . hash ( function , supplier ) ; }
private void setKey ( int i , K key ) { requireKeys ( ) [i] = key ; }
public @Nullable E pollFirst ( ) { throw new UnsupportedOperationException ( ) ; }
public void remove ( Range < K > rangeToRemove ) { if ( rangeToRemove . isEmpty ( ) ) { return ; }
public boolean replace ( K key , V oldValue , V newValue ) { return delegate ( ) . replace ( key , oldValue , newValue ) ; }
public void testAutoIncrementStep_returnsSameInstance ( ) { FakeTicker ticker = new FakeTicker ( ) ; assertSame ( ticker , ticker . setAutoIncrementStep ( 10 , NANOSECONDS ) ) ; }
public void testSerialization ( ) { reserializeAndAssert ( DiscreteDomain . integers ( ) ) ; reserializeAndAssert ( DiscreteDomain . longs ( ) ) ; reserializeAndAssert ( DiscreteDomain . bigIntegers ( ) ) ; }
public NavigableSet < K > headSet ( @ParametricNullness K toElement ) { return headSet ( toElement , false ) ; }
public void testEmptyMultisetPollFirst ( ) { assertNull ( sortedMultiset . pollFirstEntry ( ) ) ; }
public boolean add ( E e ) { checkNotNull ( e ) ; / / check before removing if ( maxSize = = 0 ) { return true ; }
public void testIncrementAndGet_zero ( ) { AtomicLongMap < String > map = AtomicLongMap . create ( ) ; String key = "key" ; assertEquals ( 0L , map . get ( key ) ) ; assertFalse ( map . containsKey ( key ) ) ; assertEquals ( 1L , map . incrementAndGet ( key ) ) ; assertEquals ( 1L , map . get ( key ) ) ; assertEquals ( 0L , map . decrementAndGet ( key ) ) ; assertEquals ( 0L , map . get ( key ) ) ; assertTrue ( map . containsKey ( key ) ) ; assertEquals ( 1L , map . incrementAndGet ( key ) ) ; assertEquals ( 1L , map . get ( key ) ) ; }
public Set < T > elementSet ( ) { return new StandardElementSet ( ) ; }
public void testKeySetRetainAllNullFromEmpty ( ) { try { super . testKeySetRetainAllNullFromEmpty ( ) ; }
public @Nullable V put ( @ParametricNullness C rowKey , @ParametricNullness R columnKey , @ParametricNullness V value ) { return original . put ( columnKey , rowKey , value ) ; }
private void doTestNoMatches ( CharMatcher matcher , String s ) { reallyTestNoMatches ( matcher , s ) ; reallyTestAllMatches ( matcher . negate ( ) , s ) ; reallyTestNoMatches ( matcher . precomputed ( ) , s ) ; reallyTestAllMatches ( matcher . negate ( ) . precomputed ( ) , s ) ; reallyTestAllMatches ( matcher . precomputed ( ) . negate ( ) , s ) ; reallyTestNoMatches ( forPredicate ( matcher ) , s ) ; reallyTestNoMatches ( matcher , new StringBuilder ( s ) ) ; }
public Collection < Boolean > values ( ) { return new StandardValues ( ) ; }
public void testVerifyNotNull_simple_success ( ) { String result = verifyNotNull ( NON_NULL_STRING ) ; assertSame ( NON_NULL_STRING , result ) ; }
public void testAsListEmpty ( ) { assertThat ( Chars . asList ( EMPTY ) ) . isSameInstanceAs ( Collections . emptyList ( ) ) ; }
public boolean add ( E element ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . add ( element ) ; }
public void testOnResultOf_chained ( ) { Comparator < String > comparator = DECREASING_INTEGER . onResultOf ( StringLengthFunction . STRING_LENGTH ) ; assertTrue ( comparator . compare ( "to" , "be" ) = = 0 ) ; assertTrue ( comparator . compare ( "not" , "or" ) < 0 ) ; assertTrue ( comparator . compare ( "to" , "that" ) > 0 ) ; new EqualsTester ( ) . addEqualityGroup ( comparator , DECREASING_INTEGER . onResultOf ( StringLengthFunction . STRING_LENGTH ) ) . addEqualityGroup ( DECREASING_INTEGER . onResultOf ( Functions . constant ( 1 ) ) ) . addEqualityGroup ( Ordering . natural ( ) ) . testEquals ( ) ; reserializeAndAssert ( comparator ) ; assertEquals ( "Ordering . natural ( ) . reverse ( ) . onResultOf ( STRING_LENGTH ) " , comparator . toString ( ) ) ; }
private Map < R , V > removeColumn ( @Nullable Object column ) { Map < R , V > output = new LinkedHashMap < > ( ) ; Iterator < Entry < R , Map < C , V > > > iterator = backingMap . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Entry < R , Map < C , V > > entry = iterator . next ( ) ; V value = entry . getValue ( ) . remove ( column ) ; if ( value ! = null ) { output . put ( entry . getKey ( ) , value ) ; if ( entry . getValue ( ) . isEmpty ( ) ) { iterator . remove ( ) ; }
public void testInverseEntrySetValueNewKey ( ) { BiMap < Integer , String > map = HashBiMap . create ( ) ; map . put ( 1 , "a" ) ; map . put ( 2 , "b" ) ; Iterator < Entry < String , Integer > > inverseEntryItr = map . inverse ( ) . entrySet ( ) . iterator ( ) ; Entry < String , Integer > entry = inverseEntryItr . next ( ) ; entry . setValue ( 3 ) ; assertEquals ( immutableEntry ( "b" , 2 ) , inverseEntryItr . next ( ) ) ; assertFalse ( inverseEntryItr . hasNext ( ) ) ; assertThat ( map . entrySet ( ) ) . containsExactly ( immutableEntry ( 2 , "b" ) , immutableEntry ( 3 , "a" ) ) . inOrder ( ) ; }
protected void verify ( List < E > elements ) { expectContents ( elements ) ; }
public void testCopyOf_multiset_empty ( ) { Multiset < String > c = HashMultiset . create ( ) ; Multiset < String > multiset = ImmutableSortedMultiset . copyOf ( c ) ; assertTrue ( multiset . isEmpty ( ) ) ; }
public Enum < ? extends Enum < ? > > implicitlyBoundedEnumIsSubtypeOfExplicitlyBoundedEnum ( Enum < ? > e ) { return isSubtype ( e ) ; }
private static void assertNotWrapper ( TypeToken < ? > type ) { assertSame ( type , type . unwrap ( ) ) ; }
public int add ( @ParametricNullness E element , int occurrences ) { throw new UnsupportedOperationException ( ) ; }
public boolean contains ( @Nullable Object object ) { return object ! = null & & super . contains ( object ) ; }
public Iterator < Entry < K , V > > iterator ( ) { return unmodifiableEntryIterator ( entries . iterator ( ) ) ; }
public @Nullable V get ( @Nullable Object key ) { if ( key instanceof Range ) { Range < ? > range = ( Range < ? > ) key ; RangeMapEntry < K , V > rangeMapEntry = entriesByLowerBound . get ( range . lowerBound ) ; if ( rangeMapEntry ! = null & & rangeMapEntry . getKey ( ) . equals ( range ) ) { return rangeMapEntry . getValue ( ) ; }
private static < E > ImmutableList < E > copyFromCollection ( Collection < ? extends E > collection ) { Object[] elements = collection . toArray ( ) ; switch ( elements . length ) { case 0: return of ( ) ; case 1: @SuppressWarnings ( "unchecked" ) / / safe because it came from `collection` E element = ( E ) elements[0] ; return of ( element ) ; default: return new RegularImmutableList < E > ( ImmutableList . < E > nullCheckedList ( elements ) ) ; }
public static < N , E > NetworkBuilder < N , E > from ( Network < N , E > network ) { return new NetworkBuilder < N , E > ( network . isDirected ( ) ) . allowsParallelEdges ( network . allowsParallelEdges ( ) ) . allowsSelfLoops ( network . allowsSelfLoops ( ) ) . nodeOrder ( network . nodeOrder ( ) ) . edgeOrder ( network . edgeOrder ( ) ) ; }
public @Nullable E peek ( ) { Monitor monitor = this . monitor ; if ( monitor . enterIf ( notEmpty ) ) { try { return items[takeIndex] ; }
public void testContainsKey ( ) { Map < K , V > map ; K unmappedKey ; try { map = makePopulatedMap ( ) ; unmappedKey = getKeyNotInPopulatedMap ( ) ; }
public void test_contains_null_iterable_no ( ) { Iterable < String > set = iterable ( "a" , "b" ) ; assertFalse ( Iterables . contains ( set , null ) ) ; }
public void testObjectArrayDefaultValue ( ) { new ObjectArrayDefaultValueChecker ( ) . check ( ) ; }
public EndpointPair < N > incidentNodes ( EndpointPair < N > edge ) { checkArgument ( edges ( ) . contains ( edge ) ) ; return edge ; }
protected long edgeCount ( ) { return delegate ( ) . edges ( ) . size ( ) ; }
public void testEmptyMapFirst ( ) { assertThrows ( NoSuchElementException . class , ( ) - > navigableMap . firstKey ( ) ) ; }
public void testStringSplitOnOnlyDelimitersOmitEmptyStrings ( ) { Iterable < String > empty = Splitter . on ( " . " ) . omitEmptyStrings ( ) . split ( " . . . " ) ; assertThat ( empty ) . isEmpty ( ) ; }
public void testRetainAll_nullCollectionReferenceNonEmptySubject ( ) { assertThrows ( NullPointerException . class , ( ) - > collection . retainAll ( null ) ) ; }
public InstantiableConstructorChosen ( String name ) { checkNotNull ( name ) ; this . name = "good" ; }
public void testSqrtHalfUp ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { BigInteger result = BigIntegerMath . sqrt ( x , HALF_UP ) ; BigInteger plusHalfSquared = result . pow ( 2 ) . add ( result ) . shiftLeft ( 2 ) . add ( ONE ) ; BigInteger x4 = x . shiftLeft ( 2 ) ; / / sqrt ( x ) < result + 0 . 5 , so 4 * x < ( result + 0 . 5 ) ^2 * 4 / / ( result + 0 . 5 ) ^2 * 4 = ( result^2 + result ) * 4 + 1 assertThat ( plusHalfSquared ) . isGreaterThan ( x4 ) ; BigInteger minusHalfSquared = result . pow ( 2 ) . subtract ( result ) . shiftLeft ( 2 ) . add ( ONE ) ; / / sqrt ( x ) > result - 0 . 5 , so 4 * x > ( result - 0 . 5 ) ^2 * 4 / / ( result - 0 . 5 ) ^2 * 4 = ( result^2 - result ) * 4 + 1 assertTrue ( result . equals ( ZERO ) | | x4 . compareTo ( minusHalfSquared ) > = 0 ) ; }
public Float get ( int index ) { checkElementIndex ( index , size ( ) ) ; return array[start + index] ; }
public void testSize2NonCollection ( ) { Iterable < Integer > iterable = new Iterable < Integer > ( ) { @Override public Iterator < Integer > iterator ( ) { return asList ( 0 , 1 ) . iterator ( ) ; }
public void testBuilder_presize_negative ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > ImmutableDoubleArray . builder ( - 1 ) ) ; }
public void testPercentiles_index_computeInPlace ( ) { / / Assert that the computation gives the correct result for all possible percentiles . for ( int index = 0 ; index < = 100 ; index + + ) { double[] dataset = Doubles . toArray ( PSEUDORANDOM_DATASET ) ; assertWithMessage ( "quantile at index %s" , index ) . that ( percentiles ( ) . index ( index ) . computeInPlace ( dataset ) ) . isWithin ( ALLOWED_ERROR ) . of ( expectedLargeDatasetPercentile ( index ) ) ; }
public void testAsMapRemove ( ) { assertContentsInOrder ( multimap ( ) . asMap ( ) . remove ( k0 ( ) ) , v0 ( ) ) ; assertGet ( k0 ( ) ) ; assertEquals ( getNumElements ( ) - 1 , multimap ( ) . size ( ) ) ; }
public Test testsForLinkedHashSet ( ) { return SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override public Set < String > create ( String[] elements ) { return new LinkedHashSet < > ( MinimalCollection . of ( elements ) ) ; }
private ImmutableSortedMap < K , V > getSubMap ( int fromIndex , int toIndex ) { if ( fromIndex = = 0 & & toIndex = = size ( ) ) { return this ; }
public void testCreation_sevenElements ( ) { List < String > list = ImmutableList . of ( "a" , "b" , "c" , "d" , "e" , "f" , "g" ) ; assertEquals ( Lists . newArrayList ( "a" , "b" , "c" , "d" , "e" , "f" , "g" ) , list ) ; }
public void testGetNullPresent ( ) { initMultimapWithNullKey ( ) ; assertContains ( multimap ( ) . get ( null ) , getValueForNullKey ( ) ) ; }
public void testUnionNonemptyEmpty ( ) { Multiset < String > ms1 = HashMultiset . create ( asList ( "a" , "b" , "a" ) ) ; Multiset < String > ms2 = HashMultiset . create ( ) ; assertEquals ( ms1 , union ( ms1 , ms2 ) ) ; }
private K key ( int i ) { return ( K ) requireKeys ( ) [i] ; }
private TestCallable ( ListenableFuture < @Nullable Void > future ) { this . future = future ; }
public void testGetGenericInterfaces_noInterface ( ) { assertThat ( new TypeToken < NoInterface > ( ) { }
public static < E extends @Nullable Object > LinkedHashMultiset < E > create ( int distinctElements ) { return new LinkedHashMultiset < > ( distinctElements ) ; }
public @Nullable V put ( @ParametricNullness K key , @ParametricNullness V value ) { return filteredDelegate . put ( key , value ) ; }
public void putAll ( Table < ? extends R , ? extends C , ? extends V > table ) { throw new UnsupportedOperationException ( ) ; }
public void testApproximateElementCount ( ) { int numInsertions = 1000 ; BloomFilter < Integer > bf = BloomFilter . create ( Funnels . integerFunnel ( ) , numInsertions ) ; bf . put ( - 1 ) ; for ( int i = 0 ; i < numInsertions ; i + + ) { bf . put ( i ) ; }
public void testScale_indexes_varargs_compute_doubleVarargs ( ) { double[] dataset = Doubles . toArray ( SIXTEEN_SQUARES_DOUBLES ) ; assertThat ( Quantiles . scale ( 10 ) . indexes ( 0 , 10 , 5 , 1 , 8 , 1 ) . compute ( dataset ) ) . comparingValuesUsing ( QUANTILE_CORRESPONDENCE ) . containsExactly ( 0 , SIXTEEN_SQUARES_MIN , 10 , SIXTEEN_SQUARES_MAX , 5 , SIXTEEN_SQUARES_MEDIAN , 1 , SIXTEEN_SQUARES_DECILE_1 , 8 , SIXTEEN_SQUARES_DECILE_8 ) ; assertThat ( dataset ) . usingExactEquality ( ) . containsExactlyElementsIn ( SIXTEEN_SQUARES_DOUBLES ) . inOrder ( ) ; }
protected SortedMap < String , Integer > makePopulatedMap ( ) { SortedMap < String , Integer > sortedMap = makeEmptyMap ( ) ; sortedMap . put ( "one" , 1 ) ; sortedMap . put ( "two" , 2 ) ; sortedMap . put ( "three" , 3 ) ; return sortedMap ; }
public void testAsMapRemoveImplementsSortedSet ( ) { List < K > keys = new ArrayList < > ( multimap ( ) . keySet ( ) ) ; for ( K key : keys ) { resetCollection ( ) ; SortedSet < V > valueSet = ( SortedSet < V > ) multimap ( ) . asMap ( ) . remove ( key ) ; assertEquals ( multimap ( ) . valueComparator ( ) , valueSet . comparator ( ) ) ; }
private static final Function < Type , String > SIMPLE_NAME_GETTER = new Function < Type , String > ( ) { @Override public String apply ( Type from ) { if ( from instanceof Class ) { return ( ( Class < ? > ) from ) . getSimpleName ( ) ; }
public final int hashCode ( ) { return element . hashCode ( ) ; }
public void testReplaceAll ( ) { getList ( ) . replaceAll ( e - > samples . e3 ( ) ) ; expectContents ( Collections . nCopies ( getNumElements ( ) , samples . e3 ( ) ) ) ; }
private static void runTestFuzzyCompare ( int toleranceIndex ) { double tolerance = get ( TOLERANCE_CANDIDATES , toleranceIndex ) ; for ( double a : ALL_DOUBLE_CANDIDATES ) { for ( double b : ALL_DOUBLE_CANDIDATES ) { int expected = DoubleMath . fuzzyEquals ( a , b , tolerance ) ? 0 : Double . compare ( a , b ) ; int actual = DoubleMath . fuzzyCompare ( a , b , tolerance ) ; assertEquals ( Integer . signum ( expected ) , Integer . signum ( actual ) ) ; }
private static ParameterizedType canonicalizeWildcardsInParameterizedType ( ParameterizedType type ) { Class < ? > rawType = ( Class < ? > ) type . getRawType ( ) ; TypeVariable < ? > [] typeVars = rawType . getTypeParameters ( ) ; Type[] typeArgs = type . getActualTypeArguments ( ) ; for ( int i = 0 ; i < typeArgs . length ; i + + ) { typeArgs[i] = canonicalizeTypeArg ( typeVars[i] , typeArgs[i] ) ; }
public boolean contains ( @Nullable Object target ) { / / Overridden to prevent a ton of boxing return ( target instanceof Byte ) & & Bytes . indexOf ( array , ( Byte ) target , start , end ) ! = - 1 ; }
private static void testRotate ( long[] input , int distance , long[] expectedOutput ) { input = Arrays . copyOf ( input , input . length ) ; Longs . rotate ( input , distance ) ; assertThat ( input ) . isEqualTo ( expectedOutput ) ; }
public void testGet_constantTypeDoesNotMatch ( ) { assertThat ( ArbitraryInstances . get ( ParentClassHasConstant . class ) ) . isNull ( ) ; }
protected K getKeyForNullValue ( ) { return getEntryNullReplaces ( ) . getKey ( ) ; }
public static void checkArgument ( boolean expression , String errorMessageTemplate , @Nullable Object p1 , @Nullable Object p2 , @Nullable Object p3 , @Nullable Object p4 ) { if ( ! expression ) { throw new IllegalArgumentException ( Platform . lenientFormat ( errorMessageTemplate , p1 , p2 , p3 , p4 ) ) ; }
public void testReverseViewRandomAccess ( ) { List < Integer > fromList = new ArrayList < > ( SOME_LIST ) ; List < Integer > toList = Lists . reverse ( fromList ) ; assertReverseView ( fromList , toList ) ; }
public void testPrimitiveAndWrapper ( ) { ImmutableClassToInstanceMap < Number > ictim = new ImmutableClassToInstanceMap . Builder < Number > ( ) . put ( Integer . class , 0 ) . put ( int . class , 1 ) . build ( ) ; assertEquals ( 2 , ictim . size ( ) ) ; assertEquals ( 0 , ( int ) ictim . getInstance ( Integer . class ) ) ; assertEquals ( 1 , ( int ) ictim . getInstance ( int . class ) ) ; }
public void testNullPointers ( ) { new NullPointerTester ( ) . testAllPublicStaticMethods ( Multisets . class ) ; }
public void testSubList_contains ( ) { List < E > list = getList ( ) ; int size = getNumElements ( ) ; List < E > copy = list . subList ( 0 , size ) ; List < E > head = list . subList ( 0 , size - 1 ) ; List < E > tail = list . subList ( 1 , size ) ; assertTrue ( copy . contains ( list . get ( 0 ) ) ) ; assertTrue ( head . contains ( list . get ( 0 ) ) ) ; assertTrue ( tail . contains ( list . get ( 1 ) ) ) ; / / The following assumes all elements are distinct . assertTrue ( copy . contains ( list . get ( size - 1 ) ) ) ; assertTrue ( head . contains ( list . get ( size - 2 ) ) ) ; assertTrue ( tail . contains ( list . get ( size - 1 ) ) ) ; assertFalse ( head . contains ( list . get ( size - 1 ) ) ) ; assertFalse ( tail . contains ( list . get ( 0 ) ) ) ; }
public boolean isShutdown ( ) { synchronized ( lock ) { return shutdown ; }
public ImmutableSet < E > build ( ) { requireNonNull ( impl ) ; / / see the comment on the field forceCopy = true ; impl = impl . review ( ) ; return impl . build ( ) ; }
public < T extends Iterable < String > > void testGetSupertype_fromTypeVariable ( ) { @SuppressWarnings ( "unchecked" ) / / to construct TypeToken < T > from TypeToken . of ( ) TypeToken < T > typeVariableToken = ( TypeToken < T > ) TypeToken . of ( new TypeCapture < T > ( ) { }
public void testRoundLog2Up ( ) { for ( double d : POSITIVE_FINITE_DOUBLE_CANDIDATES ) { int log2 = DoubleMath . log2 ( d , UP ) ; if ( d > = 1 . 0 ) { assertTrue ( log2 > = 0 ) ; assertTrue ( StrictMath . pow ( 2 . 0 , log2 ) > = d ) ; assertTrue ( StrictMath . pow ( 2 . 0 , log2 - 1 ) < d ) ; }
public boolean hasNext ( ) { / / IteratorTester doesn't expect exceptions for hasNext ( ) . return true ; }
public void funnel ( Iterable < ? extends E > from , PrimitiveSink into ) { for ( E e : from ) { elementFunnel . funnel ( e , into ) ; }
private int getPredecessor ( int entry ) { return requirePredecessors ( ) [entry] - 1 ; }
private SynchronizedCollection ( Collection < E > delegate , @Nullable Object mutex ) { super ( delegate , mutex ) ; }
public void testGetGenericSuperclass_withSuperclass ( ) { TypeToken < ? super ArrayList < String > > superToken = new TypeToken < ArrayList < String > > ( ) { }
public boolean apply ( File file ) { return file . isFile ( ) ; }
public void testTryParseFailures ( ) { for ( String badInput : BAD_TRY_PARSE_INPUTS ) { assertThat ( badInput ) . doesNotMatch ( Pattern . compile ( Doubles . FLOATING_POINT_PATTERN . pattern ( ) , Doubles . FLOATING_POINT_PATTERN . flags ( ) ) ) ; assertThat ( Doubles . tryParse ( badInput ) ) . isEqualTo ( referenceTryParse ( badInput ) ) ; assertThat ( Doubles . tryParse ( badInput ) ) . isNull ( ) ; }
public void testTryParseAllCodePoints ( ) { / / Exercise non - ASCII digit test cases and the like . char[] tmp = new char[2] ; for ( int i = Character . MIN_CODE_POINT ; i < Character . MAX_CODE_POINT ; i + + ) { Character . toChars ( i , tmp , 0 ) ; checkTryParse ( String . copyValueOf ( tmp , 0 , Character . charCount ( i ) ) ) ; }
public @Nullable E ceiling ( E element ) { return forward . floor ( element ) ; }
public Object load ( Object key ) { loadCount . incrementAndGet ( ) ; return new Object ( ) ; }
public Builder < K , V > putAll ( K key , Iterable < ? extends V > values ) { super . putAll ( key , values ) ; return this ; }
public void run ( ) { try { barrier . await ( ) ; }
public void testFillHoleWithOverlap ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closedOpen ( 1 , 3 ) ) ; rangeSet . add ( Range . closedOpen ( 4 , 6 ) ) ; rangeSet . add ( Range . closedOpen ( 2 , 5 ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . closedOpen ( 1 , 6 ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . lessThan ( 1 ) , Range . atLeast ( 6 ) ) . inOrder ( ) ; }
public void checkArray ( FromTo < String , Integer > f , String s ) { calledWith ( f , s ) ; }
public ImmutableSortedMultiset < E > descendingMultiset ( ) { ImmutableSortedMultiset < E > result = descendingMultiset ; if ( result = = null ) { return descendingMultiset = this . isEmpty ( ) ? emptyMultiset ( Ordering . from ( comparator ( ) ) . reverse ( ) ) : new DescendingImmutableSortedMultiset < E > ( this ) ; }
public boolean containsAll ( Collection < ? > c ) { synchronized ( mutex ) { return delegate ( ) . containsAll ( c ) ; }
private static boolean declaresInterruptedEx ( Method method ) { for ( Class < ? > exType : method . getExceptionTypes ( ) ) { / / debate: = = or isAssignableFrom? if ( exType = = InterruptedException . class ) { return true ; }
public void testCartesianProductTooBig ( ) { List < String > list = nCopies ( 10000 , "foo" ) ; assertThrows ( IllegalArgumentException . class , ( ) - > cartesianProduct ( list , list , list , list , list ) ) ; }
public void testPatternSplitWithTrim ( ) { String jacksons = "arfo ( Marlon ) aorf , ( Michael ) orfa , afro ( Jackie ) orfa , ofar ( Jemaine ) , aff ( Tito ) " ; Iterable < String > family = Splitter . on ( Pattern . compile ( " , " ) ) . trimResults ( CharMatcher . anyOf ( "afro" ) . or ( CharMatcher . whitespace ( ) ) ) . split ( jacksons ) ; assertThat ( family ) . containsExactly ( " ( Marlon ) " , " ( Michael ) " , " ( Jackie ) " , " ( Jemaine ) " , " ( Tito ) " ) . inOrder ( ) ; }
public void testRoundExactIntegralDoubleToLong ( ) { for ( double d : INTEGRAL_DOUBLE_CANDIDATES ) { / / every mode except UNNECESSARY BigDecimal expected = new BigDecimal ( d ) . setScale ( 0 , UNNECESSARY ) ; boolean isInBounds = expected . compareTo ( MAX_LONG_AS_BIG_DECIMAL ) < = 0 & expected . compareTo ( MIN_LONG_AS_BIG_DECIMAL ) > = 0 ; try { assertEquals ( expected . longValue ( ) , DoubleMath . roundToLong ( d , UNNECESSARY ) ) ; assertTrue ( isInBounds ) ; }
public void testToArray ( ) { / / need explicit type parameter to avoid javac warning ! ? List < Double > none = Arrays . < Double > asList ( ) ; assertThat ( Doubles . toArray ( none ) ) . isEqualTo ( EMPTY ) ; List < Double > one = Arrays . asList ( 1 . 0 ) ; assertThat ( Doubles . toArray ( one ) ) . isEqualTo ( ARRAY1 ) ; double[] array = { 0 . 0 , 1 . 0 , Math . PI }
public void testInvariantsEmpty ( ) { testInvariants ( TreeRangeSet . create ( ) ) ; }
public void testAnnotatedIn1 ( ) { assertThat ( getSubscriber ( ) . annotatedIn1Events ) . contains ( EVENT ) ; }
public void testNewDataInput_readUnsignedShort ( ) { byte[] data = { 0 , 0 , 0 , 1 , ( byte ) 0xFF , ( byte ) 0xFF , 0x12 , 0x34 }
public void testNewEnumSet_enumSet ( ) { EnumSet < SomeEnum > set = EnumSet . of ( SomeEnum . A , SomeEnum . D ) ; assertEquals ( set , newEnumSet ( set , SomeEnum . class ) ) ; }
public < T extends @Nullable Object > T[] toArray ( T[] array ) { T[] result = super . toArray ( array ) ; if ( size ( ) < result . length ) { / / It works around a GWT bug where elements after last is not / / properly null'ed . @Nullable Object[] unsoundlyCovariantArray = result ; unsoundlyCovariantArray[size ( ) ] = null ; }
public static Comparator < Boolean > trueFirst ( ) { return BooleanComparator . TRUE_FIRST ; }
private Object readResolve ( ) { return new EmptyContiguousSet < > ( domain ) ; }
protected SetTestSuiteBuilder < K > createDerivedKeySetSuite ( TestSetGenerator < K > keySetGenerator ) { return SetTestSuiteBuilder . using ( keySetGenerator ) ; }
public void successors_checkReturnedSetMutability ( ) { assume ( ) . that ( graphIsMutable ( ) ) . isTrue ( ) ; addNode ( N1 ) ; Set < Integer > successors = graph . successors ( N1 ) ; assertThrows ( UnsupportedOperationException . class , ( ) - > successors . add ( N2 ) ) ; putEdge ( N1 , N2 ) ; assertThat ( successors ) . containsExactlyElementsIn ( graph . successors ( N1 ) ) ; }
public void testSlice_returnEmptySource ( ) { assertEquals ( ByteSource . empty ( ) , source . slice ( 0 , 3 ) . slice ( 4 , 3 ) ) ; }
public Hasher putChar ( char c ) { ensureCapacity ( Character . BYTES ) ; buffer . putChar ( c ) ; return this ; }
public void run ( ) { fourthSignal . countDown ( ) ; result . set ( 1 , cache . getUnchecked ( key ) ) ; doneSignal . countDown ( ) ; }
public void testFailsToForward ( ) { try { ForwardingObjectTester . testForwardingObject ( FailToForward . class ) ; }
protected List < TestSuite > createDerivedSuites ( FeatureSpecificTestSuiteBuilder < ? , ? extends OneSizeTestContainerGenerator < M , Entry < K , V > > > parentBuilder ) { / / TODO: Once invariant support is added , supply invariants to each of the / / derived suites , to check that mutations to the derived collections are / / reflected in the underlying map . List < TestSuite > derivedSuites = super . createDerivedSuites ( parentBuilder ) ; if ( parentBuilder . getFeatures ( ) . contains ( CollectionFeature . SERIALIZABLE ) ) { derivedSuites . add ( MultimapTestSuiteBuilder . using ( new ReserializedMultimapGenerator < K , V , M > ( parentBuilder . getSubjectGenerator ( ) ) ) . withFeatures ( computeReserializedMultimapFeatures ( parentBuilder . getFeatures ( ) ) ) . named ( parentBuilder . getName ( ) + " reserialized" ) . suppressing ( parentBuilder . getSuppressedTests ( ) ) . withSetUp ( parentBuilder . getSetUp ( ) ) . withTearDown ( parentBuilder . getTearDown ( ) ) . createTestSuite ( ) ) ; }
private static void assertBasicInvariants ( Striped < ? > striped ) { Set < Object > observed = Sets . newIdentityHashSet ( ) ; / / for the sake of weakly referenced locks . / / this gets the stripes with #getAt ( index ) for ( int i = 0 ; i < striped . size ( ) ; i + + ) { Object object = striped . getAt ( i ) ; assertThat ( object ) . isNotNull ( ) ; assertSame ( object , striped . getAt ( i ) ) ; / / idempotent observed . add ( object ) ; }
public Entry < C , V > next ( ) { return wrapEntry ( iterator . next ( ) ) ; }
private < T extends B > Ordering < T > ordering ( ) { return Ordering . from ( ( Comparator < T > ) comparator ) ; }
public static void sortDescending ( int[] array , int fromIndex , int toIndex ) { checkNotNull ( array ) ; checkPositionIndexes ( fromIndex , toIndex , array . length ) ; for ( int i = fromIndex ; i < toIndex ; i + + ) { array[i] ^ = Integer . MAX_VALUE ; }
public void testToString ( ) { assertEquals ( "foo = 1" , entry ( "foo" , 1 ) . toString ( ) ) ; }
public void testCopyOf_array_nonempty ( ) { double[] array = new double[] { 0 , 1 , 3 }
public String belowSamplesLesser ( ) { return " ! ! a" ; }
public @Nullable V get ( @Nullable Object key ) { return delegate ( ) . get ( key ) ; }
public void run ( ) { lock . lock ( ) ; try { locked . countDown ( ) ; finishLatch . await ( 1 , MINUTES ) ; }
public @Nullable Range < C > rangeContaining ( C value ) { int index = SortedLists . binarySearch ( ranges , Range::lowerBound , Cut . belowValue ( value ) , Ordering . natural ( ) , ANY_PRESENT , NEXT_LOWER ) ; if ( index ! = - 1 ) { Range < C > range = ranges . get ( index ) ; return range . contains ( value ) ? range : null ; }
public void testPeekingIteratorBehavesLikeIteratorOnThreeElementIterable ( ) { actsLikeIteratorHelper ( Lists . newArrayList ( "A" , "B" , "C" ) ) ; }
public String getHost ( ) { return host ; }
public int hashCode ( ) { return ~original . hashCode ( ) ; }
protected NavigableMap < K , V > delegate ( ) { return ( NavigableMap < K , V > ) super . delegate ( ) ; }
public final double updateAndGet ( DoubleUnaryOperator updateFunction ) { while ( true ) { long current = value ; double currentVal = longBitsToDouble ( current ) ; double nextVal = updateFunction . applyAsDouble ( currentVal ) ; long next = doubleToRawLongBits ( nextVal ) ; if ( updater . compareAndSet ( this , current , next ) ) { return nextVal ; }
public boolean isLoading ( ) { return loading ; }
public < T extends B > @Nullable T putInstance ( TypeToken < T > type , T value ) { throw new UnsupportedOperationException ( ) ; }
public void testFloor ( ) { assertEquals ( a , navigableSet . floor ( a ) ) ; assertEquals ( b , navigableSet . floor ( b ) ) ; assertEquals ( c , navigableSet . floor ( c ) ) ; }
private static final Iterable < Integer > SOME_ITERABLE = new Iterable < Integer > ( ) { @Override public Iterator < Integer > iterator ( ) { return SOME_COLLECTION . iterator ( ) ; }
public long getAccessTime ( ) { throw new UnsupportedOperationException ( ) ; }
public void testNewDataOutput_writeFloat ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; out . writeFloat ( Float . intBitsToFloat ( 0x12345678 ) ) ; out . writeFloat ( Float . intBitsToFloat ( 0x76543210 ) ) ; assertThat ( out . toByteArray ( ) ) . isEqualTo ( bytes ) ; }
private static void add ( Map < Class < ? > , Class < ? > > forward , Map < Class < ? > , Class < ? > > backward , Class < ? > key , Class < ? > value ) { forward . put ( key , value ) ; backward . put ( value , key ) ; }
protected Scheduler scheduler ( ) { * return Scheduler . newFixedRateSchedule ( 0 , 1 , TimeUnit . SECONDS ) ; * }
public Hasher newHasher ( int expectedInputSize ) { checkArgument ( expectedInputSize > = 0 ) ; Hasher[] hashers = new Hasher[functions . length] ; for ( int i = 0 ; i < hashers . length ; i + + ) { hashers[i] = functions[i] . newHasher ( expectedInputSize ) ; }
public ImmutableMultisetFloodingTest ( ) { super ( asList ( ConstructionPathway . values ( ) ) , n - > n * log ( n ) , ImmutableList . of ( QueryOp . create ( "count" , ( ms , o ) - > { int unused = ms . count ( o ) ; }
public void testCompute_presentNullToNull ( ) { / / The spec is somewhat ambiguous about this case , but the actual default implementation / / in Map will remove a present null . initMapWithNullValue ( ) ; assertNull ( "Map . compute ( presentMappedToNull , functionReturningNull ) should return null" , getMap ( ) . compute ( getKeyForNullValue ( ) , ( k , v ) - > { assertEquals ( getKeyForNullValue ( ) , k ) ; assertNull ( v ) ; return null ; }
public void testCreation_thirteenElements ( ) { List < String > list = ImmutableList . of ( "a" , "b" , "c" , "d" , "e" , "f" , "g" , "h" , "i" , "j" , "k" , "l" , "m" ) ; assertEquals ( Lists . newArrayList ( "a" , "b" , "c" , "d" , "e" , "f" , "g" , "h" , "i" , "j" , "k" , "l" , "m" ) , list ) ; }
public boolean removeAll ( Collection < ? > c ) { return standardRemoveAll ( c ) ; }
public static boolean isPowerOfTwo ( BigInteger x ) { checkNotNull ( x ) ; return x . signum ( ) > 0 & & x . getLowestSetBit ( ) = = x . bitLength ( ) - 1 ; }
public void testConcurrencyLevel_zero ( ) { CacheBuilder < Object , Object > builder = CacheBuilder . newBuilder ( ) ; assertThrows ( IllegalArgumentException . class , ( ) - > builder . concurrencyLevel ( 0 ) ) ; }
public void testNullPointers ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicConstructors ( Atomics . class ) ; / / there aren't any tester . testAllPublicStaticMethods ( Atomics . class ) ; }
public static void checkState ( boolean expression , String errorMessageTemplate , char p1 , long p2 ) { if ( ! expression ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; }
public void testCreation_manyDuplicates ( ) { / / now we'll get the varargs overload @SuppressWarnings ( "DistinctVarargsChecker" ) / / deliberately testing deduplication ImmutableSet < String > set = ImmutableSet . of ( "a" , "b" , "c" , "c" , "c" , "c" , "b" , "b" , "a" , "a" , "c" , "c" , "c" , "a" ) ; assertThat ( set ) . containsExactly ( "a" , "b" , "c" ) . inOrder ( ) ; }
private < T > TypeToken < Iterable < T > > anyIterableType ( ) { return new TypeToken < Iterable < T > > ( ) { }
public int hashCode ( ) { K k = getKey ( ) ; V v = getValue ( ) ; return ( ( k = = null ) ? 0 : k . hashCode ( ) ) ^ ( ( v = = null ) ? 0 : v . hashCode ( ) ) ; }
public void testInverseSerialization ( ) { ImmutableBiMap < String , Integer > bimap = ImmutableBiMap . copyOf ( ImmutableMap . of ( 1 , "one" , 2 , "two" ) ) . inverse ( ) ; ImmutableBiMap < String , Integer > copy = SerializableTester . reserializeAndAssert ( bimap ) ; assertEquals ( Integer . valueOf ( 1 ) , copy . get ( "one" ) ) ; assertEquals ( "one" , copy . inverse ( ) . get ( 1 ) ) ; assertSame ( copy , copy . inverse ( ) . inverse ( ) ) ; }
public void testElementSetRemoveDuplicatePropagatesToMultiset ( ) { initThreeCopies ( ) ; int size = getNumElements ( ) ; int expectedSize = size - getMultiset ( ) . count ( e0 ( ) ) ; Set < E > elementSet = getMultiset ( ) . elementSet ( ) ; assertTrue ( elementSet . remove ( e0 ( ) ) ) ; assertEmpty ( getMultiset ( ) ) ; assertEquals ( expectedSize , getMultiset ( ) . size ( ) ) ; }
public boolean apply ( Character character ) { return matches ( character ) ; }
protected final char @Nullable [] escape ( char c ) { if ( c < replacementsLength ) { char[] chars = replacements[c] ; if ( chars ! = null ) { return chars ; }
private void deleteFromTableVToK ( int entry , int valueHash ) { checkArgument ( entry ! = ABSENT ) ; int valueBucket = bucket ( valueHash ) ; if ( hashTableVToK[valueBucket] = = entry ) { hashTableVToK[valueBucket] = nextInBucketVToK[entry] ; nextInBucketVToK[entry] = ABSENT ; return ; }
public void testDivByZeroAlwaysFails ( ) { for ( int p : ALL_INTEGER_CANDIDATES ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { assertThrows ( ArithmeticException . class , ( ) - > IntMath . divide ( p , 0 , mode ) ) ; }
public void testSplitterIterableIsLazy_char ( ) { assertSplitterIterableIsLazy ( COMMA_SPLITTER ) ; }
public void testCheckNonNegative_zeroDouble ( ) { MathPreconditions . checkNonNegative ( "double" , 0d ) ; }
public void testSortedMap ( ) { assertFreshInstance ( new TypeToken < SortedMap < ? , String > > ( ) { }
public void testNewLinkedListEmpty ( ) { @SuppressWarnings ( "UseCollectionConstructor" ) / / test of factory method LinkedList < Integer > list = Lists . newLinkedList ( ) ; assertEquals ( emptyList ( ) , list ) ; }
private static void verifyOccupiedMethodsInCurrentThread ( Monitor monitor , boolean expectedIsOccupied , boolean expectedIsOccupiedByCurrentThread , int expectedOccupiedDepth ) { assertEquals ( expectedIsOccupied , monitor . isOccupied ( ) ) ; assertEquals ( expectedIsOccupiedByCurrentThread , monitor . isOccupiedByCurrentThread ( ) ) ; assertEquals ( expectedOccupiedDepth , monitor . getOccupiedDepth ( ) ) ; }
public void testNonEmptyToShorter ( ) { checkArrayEquals ( new String[9] , ObjectArrays . newArray ( new String[10] , 9 ) ) ; }
public Builder < K , V > orderValuesBy ( Comparator < ? super V > valueComparator ) { this . valueComparator = checkNotNull ( valueComparator ) ; return this ; }
public RangeMap < Comparable < ? > , Object > subRangeMap ( Range < Comparable < ? > > range ) { checkNotNull ( range ) ; return this ; }
public void testLast_emptySortedSet ( ) { SortedSet < String > sortedSet = ImmutableSortedSet . of ( ) ; assertThat ( FluentIterable . from ( sortedSet ) . last ( ) ) . isAbsent ( ) ; }
private static Test testsForTransform ( ) { return CollectionTestSuiteBuilder . using ( new TestStringCollectionGenerator ( ) { @Override public Collection < @Nullable String > create ( @Nullable String[] elements ) { List < @Nullable String > list = new ArrayList < > ( ) ; for ( String element : elements ) { list . add ( ( element = = null ) ? null : "q" + element ) ; }
public int getLoadCount ( ) { return countLoad . get ( ) ; }
private static void getAll ( LoadingCache < Integer , Integer > cache , List < Integer > keys ) { for ( int i : keys ) { cache . getUnchecked ( i ) ; }
public void edgesConnecting_disconnectedNodes ( ) { addNode ( N1 ) ; addNode ( N2 ) ; assertThat ( network . edgesConnecting ( N1 , N2 ) ) . isEmpty ( ) ; }
public void predecessors_oneEdge ( ) { putEdge ( N1 , N2 ) ; assertThat ( graph . predecessors ( N2 ) ) . containsExactly ( N1 ) ; assertThat ( graph . predecessors ( N1 ) ) . containsExactly ( N2 ) ; }
public static < E > ReserializingTestCollectionGenerator < E > newInstance ( TestCollectionGenerator < E > delegate ) { return new ReserializingTestCollectionGenerator < > ( delegate ) ; }
public float floatValue ( ) { return ( float ) get ( ) ; }
public void testContainsEntryWithIncomparableValue ( ) { try { assertFalse ( getMap ( ) . entrySet ( ) . contains ( mapEntry ( k0 ( ) , IncomparableType . INSTANCE ) ) ) ; }
public void testEquals ( ) { new EqualsTester ( ) . addEqualityGroup ( Equivalence . equals ( ) , Equivalence . equals ( ) ) . addEqualityGroup ( Equivalence . identity ( ) , Equivalence . identity ( ) ) . testEquals ( ) ; }
public static double meanOf ( Iterable < ? extends Number > values ) { return meanOf ( values . iterator ( ) ) ; }
public void forGraph_depthFirstPreOrderIterable_twoTrees ( ) { assertEqualCharNodes ( Traverser . forGraph ( TWO_TREES ) . depthFirstPreOrder ( charactersOf ( "a" ) ) , "ab" ) ; assertEqualCharNodes ( Traverser . forGraph ( TWO_TREES ) . depthFirstPreOrder ( charactersOf ( "ac" ) ) , "abcd" ) ; }
public static < T extends @Nullable Object > Ordering < T > compound ( Iterable < ? extends Comparator < ? super T > > comparators ) { return new CompoundOrdering < > ( comparators ) ; }
public void testGetGenericInterfaces_wildcard_boundIsInterface ( ) { TypeToken < Iterable < String > > interfaceType = new TypeToken < Iterable < String > > ( ) { }
public void testScale_indexes_collection_tooHigh ( ) { Quantiles . Scale intermediate = Quantiles . scale ( 10 ) ; assertThrows ( IllegalArgumentException . class , ( ) - > intermediate . indexes ( ImmutableList . of ( 1 , 11 , 3 ) ) ) ; }
public boolean retainAll ( Collection < ? > c ) { return removeEntryIf ( compose ( not ( in ( c ) ) , Entry::getKey ) ) ; }
private static HashCode fmix ( int h1 , int length ) { h1 ^ = length ; h1 ^ = h1 > > > 16 ; h1 * = 0x85ebca6b ; h1 ^ = h1 > > > 13 ; h1 * = 0xc2b2ae35 ; h1 ^ = h1 > > > 16 ; return HashCode . fromInt ( h1 ) ; }
public void testFloorPowerOfTwo ( ) { for ( long x : POSITIVE_LONG_CANDIDATES ) { BigInteger expectedResult = BigIntegerMath . floorPowerOfTwo ( BigInteger . valueOf ( x ) ) ; assertEquals ( expectedResult . longValue ( ) , LongMath . floorPowerOfTwo ( x ) ) ; }
public boolean equals ( @Nullable Object obj ) { if ( obj instanceof SupplierFunction ) { SupplierFunction < ? , ? > that = ( SupplierFunction < ? , ? > ) obj ; return this . supplier . equals ( that . supplier ) ; }
public Iterable < Enum < ? extends Enum < ? extends Enum < ? > > > > implicitEnumBoundIsSubtypeOfNestedExplicitEnumBound ( List < Enum < ? > > listOfEnums ) { return isSubtype ( listOfEnums ) ; }
public boolean equals ( @Nullable Object object ) { / / Warning: this is broken if size ( ) = = 0 , so it is critical that we / / substitute an empty ImmutableSet to the user in place of this if ( object instanceof CartesianSet ) { CartesianSet < ? > that = ( CartesianSet < ? > ) object ; return this . axes . equals ( that . axes ) ; }
public @Nullable E higher ( @ParametricNullness E e ) { return delegate . higher ( e ) ; }
public boolean putEdge ( N nodeU , N nodeV ) { return backingValueGraph . putEdgeValue ( nodeU , nodeV , Presence . EDGE_EXISTS ) = = null ; }
public < T > void testVisitParameterizedType ( ) { Type type = new TypeCapture < Iterable < T > > ( ) { }
public V[] createArray ( int length ) { V[] vs = ( ( TestBiMapGenerator < K , V > ) mapGenerator . getInnerGenerator ( ) ) . createValueArray ( length ) ; return vs ; }
public void test_contains_nonnull_set_yes ( ) { Iterable < @Nullable String > set = newHashSet ( "a" , null , "b" ) ; assertTrue ( Iterables . contains ( set , "b" ) ) ; }
public void testPutAllTable ( ) { table = create ( "foo" , 1 , 'a' , "bar" , 1 , 'b' , "foo" , 3 , 'c' ) ; Table < String , Integer , @NonNull C > other = HashBasedTable . create ( ) ; other . put ( "foo" , 1 , cellValue ( 'd' ) ) ; other . put ( "bar" , 2 , cellValue ( 'e' ) ) ; other . put ( "cat" , 2 , cellValue ( 'f' ) ) ; table . putAll ( other ) ; assertEquals ( ( Character ) 'd' , table . get ( "foo" , 1 ) ) ; assertEquals ( ( Character ) 'b' , table . get ( "bar" , 1 ) ) ; assertEquals ( ( Character ) 'c' , table . get ( "foo" , 3 ) ) ; assertEquals ( ( Character ) 'e' , table . get ( "bar" , 2 ) ) ; assertEquals ( ( Character ) 'f' , table . get ( "cat" , 2 ) ) ; assertSize ( 5 ) ; }
public void testPutAllWithNullKey ( ) { Multimap < K , V > source = getSubjectGenerator ( ) . create ( mapEntry ( null , v0 ( ) ) ) ; assertTrue ( multimap ( ) . putAll ( source ) ) ; assertTrue ( multimap ( ) . containsEntry ( null , v0 ( ) ) ) ; }
public Double get ( int index ) { return parent . get ( index ) ; }
private static final ListenerCallQueue . Event < Listener > STOPPED_EVENT = new ListenerCallQueue . Event < Listener > ( ) { @Override public void call ( Listener listener ) { listener . stopped ( ) ; }
private Directed ( BaseGraph < N > graph ) { super ( graph ) ; }
public void testContains_keyWithNullValueContained ( ) { initMapWithNullValue ( ) ; assertTrue ( "containsKey ( keyForNullValue ) should return true" , getMap ( ) . containsKey ( getKeyForNullValue ( ) ) ) ; }
public static < K , V > ImmutableBiMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 , K k6 , V v6 , K k7 , V v7 ) { checkEntryNotNull ( k1 , v1 ) ; checkEntryNotNull ( k2 , v2 ) ; checkEntryNotNull ( k3 , v3 ) ; checkEntryNotNull ( k4 , v4 ) ; checkEntryNotNull ( k5 , v5 ) ; checkEntryNotNull ( k6 , v6 ) ; checkEntryNotNull ( k7 , v7 ) ; return new RegularImmutableBiMap < K , V > ( new Object[] { k1 , v1 , k2 , v2 , k3 , v3 , k4 , v4 , k5 , v5 , k6 , v6 , k7 , v7 }
public static < E extends Enum < E > > ImmutableSet < E > immutableEnumSet ( E anElement , E . . . otherElements ) { return ImmutableEnumSet . asImmutable ( EnumSet . of ( anElement , otherElements ) ) ; }
private static < K extends @Nullable Object , V extends @Nullable Object > Map < K , V > filterFiltered ( AbstractFilteredMap < K , V > map , Predicate < ? super Entry < K , V > > entryPredicate ) { return new FilteredEntryMap < > ( map . unfiltered , Predicates . and ( map . predicate , entryPredicate ) ) ; }
private NullsBeforeB ( ) { super ( "b" ) ; }
public NavigableMap < K , V > tailMap ( @ParametricNullness K fromKey , boolean inclusive ) { return asMap ( set . tailSet ( fromKey , inclusive ) , function ) ; }
public static < T extends @Nullable Object > Predicate < T > isNull ( ) { return ObjectPredicate . IS_NULL . withNarrowedType ( ) ; }
public void testCopyOf_collection_oneElement ( ) { Collection < String > c = MinimalCollection . of ( "a" ) ; List < String > list = ImmutableList . copyOf ( c ) ; assertEquals ( singletonList ( "a" ) , list ) ; }
public Test allTests ( ) { TestSuite suite = new TestSuite ( "java . util Maps" ) ; suite . addTest ( testsForCheckedMap ( ) ) ; suite . addTest ( testsForCheckedSortedMap ( ) ) ; suite . addTest ( testsForEmptyMap ( ) ) ; suite . addTest ( testsForSingletonMap ( ) ) ; suite . addTest ( testsForHashMap ( ) ) ; suite . addTest ( testsForHashtable ( ) ) ; suite . addTest ( testsForLinkedHashMap ( ) ) ; suite . addTest ( testsForTreeMapNatural ( ) ) ; suite . addTest ( testsForTreeMapWithComparator ( ) ) ; suite . addTest ( testsForUnmodifiableMap ( ) ) ; suite . addTest ( testsForUnmodifiableSortedMap ( ) ) ; suite . addTest ( testsForEnumMap ( ) ) ; suite . addTest ( testsForConcurrentHashMap ( ) ) ; suite . addTest ( testsForConcurrentSkipListMapNatural ( ) ) ; suite . addTest ( testsForConcurrentSkipListMapWithComparator ( ) ) ; return suite ; }
public static int indexOf ( boolean[] array , boolean target ) { return indexOf ( array , target , 0 , array . length ) ; }
public @Nullable E floor ( E element ) { int index = headIndex ( element , true ) - 1 ; return ( index = = - 1 ) ? null : elements . get ( index ) ; }
public final ImmutableList < V > replaceValues ( K key , Iterable < ? extends V > values ) { throw new UnsupportedOperationException ( ) ; }
public void run ( ) { try { f . get ( ) ; }
public void testList ( ) { assertFreshInstance ( new TypeToken < List < String > > ( ) { }
public void testRemoveAtIndex_middle ( ) { runRemoveTest ( getNumElements ( ) / 2 ) ; }
public void testTransformValuesIsView ( ) { Multimap < String , String > multimap = LinkedListMultimap . create ( ) ; multimap . put ( "a" , "a" ) ; Multimap < String , Integer > transformed = Multimaps . transformValues ( multimap , new Function < String , Integer > ( ) { @Override public Integer apply ( String str ) { return str . length ( ) ; }
public void testAddAll_supportedNonePresent ( ) { assertTrue ( "addAll ( nonePresent ) should return true" , collection . addAll ( createDisjointCollection ( ) ) ) ; expectAdded ( e3 ( ) , e4 ( ) ) ; }
public void testEqualsForSmallerMap ( ) { if ( ! supportsRemove ) { return ; }
public void putAll ( Table < ? extends R , ? extends C , ? extends V > table ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; delegate . putAll ( table ) ; }
public @Nullable V remove ( @Nullable Object key ) { updateBackingRowMapField ( ) ; if ( backingRowMap = = null ) { return null ; }
public static < E extends Enum < E > > EnumMultiset < E > create ( Class < E > type ) { return new EnumMultiset < > ( type ) ; }
public boolean removeAll ( Collection < ? > c ) { return delegate . entrySet ( ) . removeAll ( c ) ; }
public void testLenientFormat ( ) { assertEquals ( "%s" , Strings . lenientFormat ( "%s" ) ) ; assertEquals ( "5" , Strings . lenientFormat ( "%s" , 5 ) ) ; assertEquals ( "foo [5]" , Strings . lenientFormat ( "foo" , 5 ) ) ; assertEquals ( "foo [5 , 6 , 7]" , Strings . lenientFormat ( "foo" , 5 , 6 , 7 ) ) ; assertEquals ( "%s 1 2" , Strings . lenientFormat ( "%s %s %s" , "%s" , 1 , 2 ) ) ; assertEquals ( " [5 , 6]" , Strings . lenientFormat ( "" , 5 , 6 ) ) ; assertEquals ( "123" , Strings . lenientFormat ( "%s%s%s" , 1 , 2 , 3 ) ) ; assertEquals ( "1%s%s" , Strings . lenientFormat ( "%s%s%s" , 1 ) ) ; assertEquals ( "5 + 6 = 11" , Strings . lenientFormat ( "%s + 6 = 11" , 5 ) ) ; assertEquals ( "5 + 6 = 11" , Strings . lenientFormat ( "5 + %s = 11" , 6 ) ) ; assertEquals ( "5 + 6 = 11" , Strings . lenientFormat ( "5 + 6 = %s" , 11 ) ) ; assertEquals ( "5 + 6 = 11" , Strings . lenientFormat ( "%s + %s = %s" , 5 , 6 , 11 ) ) ; assertEquals ( "5 + 6 = 11" , Strings . lenientFormat ( "%s + %s = %s" , ( Object[] ) new Integer[] { 5 , 6 , 11 }
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( ListMultimapTestSuiteBuilder . using ( new TestStringListMultimapGenerator ( ) { @Override protected ListMultimap < String , String > create ( Entry < String , String > [] entries ) { ListMultimap < String , String > multimap = ArrayListMultimap . create ( ) ; for ( Entry < String , String > entry : entries ) { multimap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; }
public static < K , V > ImmutableBiMap < K , V > of ( ) { return ( ImmutableBiMap < K , V > ) RegularImmutableBiMap . EMPTY ; }
public void testPutTwoElements ( ) { int size = getNumElements ( ) ; List < V > values = copyToList ( multimap ( ) . get ( k0 ( ) ) ) ; assertTrue ( multimap ( ) . put ( k0 ( ) , v1 ( ) ) ) ; assertTrue ( multimap ( ) . put ( k0 ( ) , v2 ( ) ) ) ; values . add ( v1 ( ) ) ; values . add ( v2 ( ) ) ; assertGet ( k0 ( ) , values ) ; assertEquals ( size + 2 , multimap ( ) . size ( ) ) ; }
public boolean contains ( @Nullable Object obj ) { if ( obj instanceof List ) { List < ? > list = ( List < ? > ) obj ; return isPermutation ( inputList , list ) ; }
public Comparator < Electronics > topLevelClassIsNotSupertype ( Mall < Indoor > . Shop < Electronics > shop ) { return notSubtype ( shop ) ; }
protected Collection < Method > suppressForConcurrentSkipListMap ( ) { List < Method > methods = new ArrayList < > ( ) ; methods . addAll ( super . suppressForConcurrentSkipListMap ( ) ) ; methods . add ( getContainsEntryWithIncomparableKeyMethod ( ) ) ; methods . add ( getContainsEntryWithIncomparableValueMethod ( ) ) ; return methods ; }
public void testEqualsSymmetric ( ) { Set < String > delegate = newHashSet ( "foo" ) ; ForwardingObject forward = new ForwardingObject ( ) { @Override protected Object delegate ( ) { return delegate ; }
public static int compare ( short a , short b ) { return Short . compare ( a , b ) ; }
public boolean encloses ( Range < C > range ) { if ( ! restriction . isEmpty ( ) & & restriction . encloses ( range ) ) { Range < C > enclosing = TreeRangeSet . this . rangeEnclosing ( range ) ; return enclosing ! = null & & ! enclosing . intersection ( restriction ) . isEmpty ( ) ; }
private static < R , C , V > Table < R , C , V > wrap ( Table < R , C , V > delegate ) { return new ForwardingTable < R , C , V > ( ) { @Override protected Table < R , C , V > delegate ( ) { return delegate ; }
public void testSetValueNullUnsupported ( ) { for ( Entry < K , V > entry : getMap ( ) . entrySet ( ) ) { assertThrows ( NullPointerException . class , ( ) - > entry . setValue ( null ) ) ; expectUnchanged ( ) ; }
public void testOf4 ( ) { assertThat ( ImmutableDoubleArray . of ( 0 , 1 , 3 , 6 ) . asList ( ) ) . containsExactly ( 0 . 0 , 1 . 0 , 3 . 0 , 6 . 0 ) . inOrder ( ) ; }
public static void checkArgument ( boolean expression , String errorMessageTemplate , char p1 , @Nullable Object p2 ) { if ( ! expression ) { throw new IllegalArgumentException ( Platform . lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; }
public void testPutPresent ( ) { int size = getNumElements ( ) ; assertGet ( k0 ( ) , v0 ( ) ) ; assertTrue ( multimap ( ) . put ( k0 ( ) , v3 ( ) ) ) ; assertGet ( k0 ( ) , v0 ( ) , v3 ( ) ) ; assertEquals ( size + 1 , multimap ( ) . size ( ) ) ; }
protected BiMap < String , String > create ( Entry < String , String > [] entries ) { Map < String , String > builder = new LinkedHashMap < > ( ) ; for ( Entry < String , String > entry : entries ) { builder . put ( entry . getKey ( ) , entry . getValue ( ) ) ; }
public AtomicDouble ( double initialValue ) { value = new AtomicLong ( doubleToRawLongBits ( initialValue ) ) ; }
public void testAtMostOneSeparator ( ) { BaseEncoding separated = base64 ( ) . withSeparator ( "\n" , 3 ) ; assertThrows ( UnsupportedOperationException . class , ( ) - > separated . withSeparator ( "$" , 4 ) ) ; }
protected SortedMap < String , String > create ( Entry < String , String > [] entries ) { SortedMap < String , String > map = new NonNavigableSortedMap ( ) ; putEntries ( map , entries ) ; map . putAll ( ENTRIES_TO_FILTER ) ; return Maps . filterValues ( map , FILTER_VALUES ) ; }
public void testFind_matchAlways ( ) { Iterable < String > list = Lists . newArrayList ( "cool" , "pants" ) ; Iterator < String > iterator = list . iterator ( ) ; assertEquals ( "cool" , find ( iterator , Predicates . alwaysTrue ( ) ) ) ; }
public boolean add ( @ParametricNullness V value ) { refreshIfEmpty ( ) ; boolean wasEmpty = delegate . isEmpty ( ) ; boolean changed = delegate . add ( value ) ; if ( changed ) { totalSize + + ; if ( wasEmpty ) { addToMap ( ) ; }
private Collection < V > createCollection ( V v ) { return ( ( TestMultimapGenerator < K , V , M > ) multimapGenerator . getInnerGenerator ( ) ) . createCollection ( singleton ( v ) ) ; }
public static ImmutableLongArray copyOf ( LongStream stream ) { / / Note this uses very different growth behavior from copyOf ( Iterable ) and the builder . long[] array = stream . toArray ( ) ; return ( array . length = = 0 ) ? EMPTY : new ImmutableLongArray ( array ) ; }
public void incidentNodes_selfLoop ( ) { assume ( ) . that ( network . allowsSelfLoops ( ) ) . isTrue ( ) ; addEdge ( N1 , N1 , E11 ) ; assertThat ( network . incidentNodes ( E11 ) . nodeU ( ) ) . isEqualTo ( N1 ) ; assertThat ( network . incidentNodes ( E11 ) . nodeV ( ) ) . isEqualTo ( N1 ) ; }
public void testReverseIndexed ( ) { testReverse ( new double[] { }
public void testRetainAll_containsNonNullWithNull ( ) { initCollectionWithNullElement ( ) ; expectReturnsTrue ( disjoint ) ; expectContents ( ) ; }
public void forGraph_depthFirstPostOrder_multigraph ( ) { Traverser < Character > traverser = Traverser . forGraph ( MULTI_GRAPH ) ; assertEqualCharNodes ( traverser . depthFirstPostOrder ( 'a' ) , "dbca" ) ; assertEqualCharNodes ( traverser . depthFirstPostOrder ( 'b' ) , "db" ) ; assertEqualCharNodes ( traverser . depthFirstPostOrder ( 'c' ) , "dbac" ) ; assertEqualCharNodes ( traverser . depthFirstPostOrder ( 'd' ) , "d" ) ; }
protected List < String > create ( String[] elements ) { Set < String > set = new HashSet < > ( ) ; ImmutableSortedMultiset . Builder < String > builder = ImmutableSortedMultiset . naturalOrder ( ) ; for ( String s : elements ) { checkArgument ( set . add ( s ) ) ; builder . addCopies ( s , 2 ) ; }
protected Set < String > create ( String[] elements ) { CompactLinkedHashSet < String > set = CompactLinkedHashSet . create ( ) ; set . convertToHashFloodingResistantImplementation ( ) ; Collections . addAll ( set , elements ) ; return set ; }
public List < Runnable > shutdownNow ( ) { lastMethodCalled = "shutdownNow" ; return ImmutableList . of ( ) ; }
public void forTree_depthFirstPostOrderIterable_iterableIsLazy ( ) { RequestSavingGraph graph = new RequestSavingGraph ( TREE ) ; Iterable < Character > result = Traverser . forGraph ( graph ) . depthFirstPostOrder ( charactersOf ( "dg" ) ) ; assertEqualCharNodes ( Iterables . limit ( result , 2 ) , "ab" ) ; assertThat ( graph . requestedNodes ) . containsExactly ( 'a' , 'b' , 'd' , 'd' , 'g' ) ; / / Iterate again to see if calculation is done again assertEqualCharNodes ( Iterables . limit ( result , 2 ) , "ab" ) ; assertThat ( graph . requestedNodes ) . containsExactly ( 'a' , 'a' , 'b' , 'b' , 'd' , 'd' , 'd' , 'g' ) ; }
public void testFilteredKeysSetMultimapReplaceValues ( ) { SetMultimap < String , Integer > multimap = LinkedHashMultimap . create ( ) ; multimap . put ( "foo" , 1 ) ; multimap . put ( "bar" , 2 ) ; multimap . put ( "baz" , 3 ) ; multimap . put ( "bar" , 4 ) ; SetMultimap < String , Integer > filtered = filterKeys ( multimap , Predicates . in ( ImmutableSet . of ( "foo" , "bar" ) ) ) ; assertEquals ( ImmutableSet . of ( ) , filtered . replaceValues ( "baz" , ImmutableSet . < Integer > of ( ) ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > filtered . replaceValues ( "baz" , ImmutableSet . of ( 5 ) ) ) ; }
public void testCreateCopy ( ) { for ( Range < Integer > range1 : QUERY_RANGES ) { for ( Range < Integer > range2 : QUERY_RANGES ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( range1 ) ; rangeSet . add ( range2 ) ; assertEquals ( rangeSet , TreeRangeSet . create ( rangeSet ) ) ; }
protected final < T extends @Nullable Object > RunnableFuture < T > newTaskFor ( Callable < T > callable ) { return TrustedListenableFutureTask . create ( callable ) ; }
public E[] createArray ( int length ) { return delegate . createArray ( length ) ; }
protected DiscreteDomain ( ) { this ( false ) ; }
public void testGetNameWithoutExtension ( ) { assertEquals ( "" , MoreFiles . getNameWithoutExtension ( FS . getPath ( " . txt" ) ) ) ; assertEquals ( "blah" , MoreFiles . getNameWithoutExtension ( FS . getPath ( "blah . txt" ) ) ) ; assertEquals ( "blah . " , MoreFiles . getNameWithoutExtension ( FS . getPath ( "blah . . txt" ) ) ) ; assertEquals ( " . blah" , MoreFiles . getNameWithoutExtension ( FS . getPath ( " . blah . txt" ) ) ) ; assertEquals ( "blah" , MoreFiles . getNameWithoutExtension ( root ( ) . resolve ( "tmp / blah . txt" ) ) ) ; assertEquals ( "blah . tar" , MoreFiles . getNameWithoutExtension ( FS . getPath ( "blah . tar . gz" ) ) ) ; assertEquals ( "" , MoreFiles . getNameWithoutExtension ( root ( ) ) ) ; assertEquals ( "" , MoreFiles . getNameWithoutExtension ( FS . getPath ( " . " ) ) ) ; assertEquals ( " . " , MoreFiles . getNameWithoutExtension ( FS . getPath ( " . . " ) ) ) ; assertEquals ( " . . " , MoreFiles . getNameWithoutExtension ( FS . getPath ( " . . . " ) ) ) ; assertEquals ( "blah" , MoreFiles . getNameWithoutExtension ( FS . getPath ( "blah" ) ) ) ; assertEquals ( "blah" , MoreFiles . getNameWithoutExtension ( FS . getPath ( "blah . " ) ) ) ; assertEquals ( " . blah" , MoreFiles . getNameWithoutExtension ( FS . getPath ( " . blah . " ) ) ) ; assertEquals ( "blah" , MoreFiles . getNameWithoutExtension ( root ( ) . resolve ( "foo . bar / blah" ) ) ) ; assertEquals ( "blah" , MoreFiles . getNameWithoutExtension ( root ( ) . resolve ( "foo / . bar / blah" ) ) ) ; }
public void testIndexIterator ( ) { Multimap < String , Object > stringToObject = new ImmutableMultimap . Builder < String , Object > ( ) . put ( "1" , 1 ) . put ( "1" , 1L ) . put ( "1" , "1" ) . put ( "2" , 2 ) . put ( "2" , 2L ) . build ( ) ; ImmutableMultimap < String , Object > outputMap = Multimaps . index ( stringToObject . values ( ) . iterator ( ) , Functions . toStringFunction ( ) ) ; assertEquals ( stringToObject , outputMap ) ; }
public void testNewDataInput_readLong ( ) { byte[] data = { 0x12 , 0x34 , 0x56 , 0x78 , 0x76 , 0x54 , 0x32 , 0x10 }
public void hasEdgeConnecting_directed_backwards ( ) { graph = ValueGraphBuilder . directed ( ) . build ( ) ; graph . putEdgeValue ( 1 , 2 , "A" ) ; assertThat ( graph . hasEdgeConnecting ( EndpointPair . ordered ( 2 , 1 ) ) ) . isFalse ( ) ; }
public SampleDoubles ( ) { super ( 0 . 0 , 1 . 0 , 2 . 0 , 3 . 0 , 4 . 0 ) ; }
public void remove ( ) { checkState ( lastReturned ! = null ) ; LocalCache . this . remove ( lastReturned . getKey ( ) ) ; lastReturned = null ; }
public NavigableMap < Cut < C > , Range < C > > subMap ( Cut < C > fromKey , boolean fromInclusive , Cut < C > toKey , boolean toInclusive ) { return subMap ( Range . range ( fromKey , BoundType . forBoolean ( fromInclusive ) , toKey , BoundType . forBoolean ( toInclusive ) ) ) ; }
public int compare ( Number a , Number b ) { return ( ( Double ) a . doubleValue ( ) ) . compareTo ( b . doubleValue ( ) ) ; }
public void testDouble ( ) { Sink sink = new Sink ( 8 ) ; sink . putDouble ( Double . longBitsToDouble ( 0x0807060504030201L ) ) ; HashCode unused = sink . hash ( ) ; sink . assertInvariants ( 8 ) ; sink . assertBytes ( new byte[] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }
public void testGet_list ( ) { testGetOnAbc ( newArrayList ( "a" , "b" , "c" ) ) ; }
public ImmutableSet < Object > create ( List < ? > list ) { ImmutableSet . Builder < Object > builder = ImmutableSet . builder ( ) ; builder . add ( list . toArray ( ) ) ; return builder . build ( ) ; }
public final < S extends @Nullable T > Wrapper < S > wrap ( @ParametricNullness S reference ) { return new Wrapper < > ( this , reference ) ; }
public void testHashCode_containingNullValue ( ) { Entry < K , V > entryWithNull = entry ( k3 ( ) , null ) ; runEntryWithNullTest ( entryWithNull ) ; }
public ImmutableList < E > asList ( ) { ImmutableList < E > result = asList ; return ( result = = null ) ? asList = super . asList ( ) : result ; }
public void testGet_withDefault_lastPlusOne ( ) { ArrayList < String > list = newArrayList ( "a" , "b" , "c" ) ; assertEquals ( "d" , Iterables . get ( list , 3 , "d" ) ) ; }
public static LinearTransformation vertical ( double x ) { checkArgument ( isFinite ( x ) ) ; return new VerticalLinearTransformation ( x ) ; }
public void testGenericInterfaceReturnedByGenericMethod ( ) { new GenericInterface2DefaultValueChecker ( ) . check ( ) ; }
public void run ( ) { integer . getAndIncrement ( ) ; }
protected Map < String , Integer > makePopulatedMap ( ) { return ImmutableBiMap . of ( 1 , "one" , 2 , "two" , 3 , "three" ) . inverse ( ) ; }
public Class < ? > apply ( Throwable input ) { return input . getClass ( ) ; }
private void bmix64 ( long k1 , long k2 ) { h1 ^ = mixK1 ( k1 ) ; h1 = Long . rotateLeft ( h1 , 27 ) ; h1 + = h2 ; h1 = h1 * 5 + 0x52dce729 ; h2 ^ = mixK2 ( k2 ) ; h2 = Long . rotateLeft ( h2 , 31 ) ; h2 + = h1 ; h2 = h2 * 5 + 0x38495ab5 ; }
public SpecialRandom ( long seed ) { super ( seed ) ; this . hasSeed = true ; this . seed = seed ; }
public void testPutAllNullValueOnPresentKey_supported ( ) { assertTrue ( multimap ( ) . putAll ( k0 ( ) , newArrayList ( v3 ( ) , null ) ) ) ; assertGet ( k0 ( ) , v0 ( ) , v3 ( ) , null ) ; }
public @Nullable K ceilingKey ( K key ) { return standardCeilingKey ( key ) ; }
public void testMultipleInterfacesDefaultValue ( ) { new MultipleInterfacesDefaultValueChecker ( ) . check ( ) ; }
private long measureTotalTimeMillis ( RateLimiter rateLimiter , int permits , Random random ) { long startTime = stopwatch . instant ; while ( permits > 0 ) { int nextPermitsToAcquire = max ( 1 , random . nextInt ( permits ) ) ; permits - = nextPermitsToAcquire ; rateLimiter . acquire ( nextPermitsToAcquire ) ; }
public void testColumnKeySet ( ) { assertEquals ( ImmutableSet . of ( 1 ) , testTable . columnKeySet ( ) ) ; }
public void testEntrySetSetValueSameValue ( ) { / / TODO: Investigate the extent to which , in practice , maps that support / / put ( ) also support Entry . setValue ( ) . if ( ! supportsPut ) { return ; }
public void testCopyOf_array_empty ( ) { / * * We don't guarantee the same - as property , so we aren't obligated to test it . However , it's * useful in testing - when two things are the same then one can't have bugs the other doesn't . * / assertThat ( ImmutableIntArray . copyOf ( new int[0] ) ) . isSameInstanceAs ( ImmutableIntArray . of ( ) ) ; }
protected Set < String > create ( String[] elements ) { Set < String > difference = newHashSet ( elements ) ; Set < String > set = newHashSet ( samples ( ) ) ; set . addAll ( difference ) ; Set < String > subset = newHashSet ( samples ( ) ) ; subset . removeAll ( difference ) ; return difference ( set , subset ) ; }
public boolean retainAll ( Collection < ? > c ) { return delegate . values ( ) . retainAll ( c ) ; }
public int hashCode ( ) { return SequentialFunnel . class . hashCode ( ) ^ elementFunnel . hashCode ( ) ; }
public void testMod ( ) { for ( long x : ALL_LONG_CANDIDATES ) { for ( long m : POSITIVE_LONG_CANDIDATES ) { assertEquals ( valueOf ( x ) . mod ( valueOf ( m ) ) . longValue ( ) , LongMath . mod ( x , m ) ) ; }
public UnmodifiableIterator < E > iterator ( ) { return super . iterator ( ) ; }
public static Test suite ( ) { return CollectionTestSuiteBuilder . using ( new TestStringCollectionGenerator ( ) { @Override public Collection < String > create ( String[] elements ) { / / TODO: MinimalCollection should perhaps throw for ( Object element : elements ) { if ( element = = null ) { throw new NullPointerException ( ) ; }
public void testConstructorLenient_classObject ( ) { String toTest = MoreObjects . toStringHelper ( TestClass . class ) . toString ( ) ; assertTrue ( toTest , toTest . matches ( " . * \\ { \\ }
public void testSynchronizedArrayListMultimapRandomAccess ( ) { ListMultimap < String , Integer > delegate = ArrayListMultimap . create ( ) ; delegate . put ( "foo" , 1 ) ; delegate . put ( "foo" , 3 ) ; ListMultimap < String , Integer > multimap = synchronizedListMultimap ( delegate ) ; assertTrue ( multimap . get ( "foo" ) instanceof RandomAccess ) ; assertTrue ( multimap . get ( "bar" ) instanceof RandomAccess ) ; }
public void testStatsNoops ( ) { CacheBuilder < Object , Object > builder = createCacheBuilder ( ) . concurrencyLevel ( 1 ) ; LocalLoadingCache < Object , Object > cache = makeCache ( builder , identityLoader ( ) ) ; ConcurrentMap < Object , Object > map = cache . localCache ; / / modifiable map view assertThat ( cache . stats ( ) ) . isEqualTo ( EMPTY_STATS ) ; Object one = new Object ( ) ; assertThat ( map . put ( one , one ) ) . isNull ( ) ; assertThat ( map . get ( one ) ) . isSameInstanceAs ( one ) ; assertThat ( map . containsKey ( one ) ) . isTrue ( ) ; assertThat ( map . containsValue ( one ) ) . isTrue ( ) ; Object two = new Object ( ) ; assertThat ( map . replace ( one , two ) ) . isSameInstanceAs ( one ) ; assertThat ( map . containsKey ( one ) ) . isTrue ( ) ; assertThat ( map . containsValue ( one ) ) . isFalse ( ) ; Object three = new Object ( ) ; assertThat ( map . replace ( one , two , three ) ) . isTrue ( ) ; assertThat ( map . remove ( one , three ) ) . isTrue ( ) ; assertThat ( map . containsKey ( one ) ) . isFalse ( ) ; assertThat ( map . containsValue ( one ) ) . isFalse ( ) ; assertThat ( map . putIfAbsent ( two , three ) ) . isNull ( ) ; assertThat ( map . remove ( two ) ) . isSameInstanceAs ( three ) ; assertThat ( map . put ( three , one ) ) . isNull ( ) ; assertThat ( map . put ( one , two ) ) . isNull ( ) ; assertThat ( map ) . containsEntry ( three , one ) ; assertThat ( map ) . containsEntry ( one , two ) ; / / TODO ( cgruber ) : Confirm with fry@ that this is a reasonable substitute . / / Set < Entry < Object , Object > > entries = map . entrySet ( ) ; / / assertThat ( entries ) . containsExactly ( / / Maps . immutableEntry ( three , one ) , Maps . immutableEntry ( one , two ) ) ; / / Set < Object > keys = map . keySet ( ) ; / / assertThat ( keys ) . containsExactly ( one , three ) ; / / Collection < Object > values = map . values ( ) ; / / assertThat ( values ) . containsExactly ( one , two ) ; map . clear ( ) ; assertThat ( cache . stats ( ) ) . isEqualTo ( EMPTY_STATS ) ; }
public int drainTo ( Collection < ? super E > c , int maxElements ) { return delegate ( ) . drainTo ( c , maxElements ) ; }
public void testEnsureCapacity ( ) { assertThat ( Shorts . ensureCapacity ( EMPTY , 0 , 1 ) ) . isSameInstanceAs ( EMPTY ) ; assertThat ( Shorts . ensureCapacity ( ARRAY1 , 0 , 1 ) ) . isSameInstanceAs ( ARRAY1 ) ; assertThat ( Shorts . ensureCapacity ( ARRAY1 , 1 , 1 ) ) . isSameInstanceAs ( ARRAY1 ) ; assertThat ( Shorts . ensureCapacity ( ARRAY1 , 2 , 1 ) ) . isEqualTo ( new short[] { ( short ) 1 , ( short ) 0 , ( short ) 0 }
public void testBuilderPutAll ( ) { Map < String , Integer > toPut = new LinkedHashMap < > ( ) ; toPut . put ( "one" , 1 ) ; toPut . put ( "two" , 2 ) ; toPut . put ( "three" , 3 ) ; Map < String , Integer > moreToPut = new LinkedHashMap < > ( ) ; moreToPut . put ( "four" , 4 ) ; moreToPut . put ( "five" , 5 ) ; ImmutableSortedMap < String , Integer > map = ImmutableSortedMap . < String , Integer > naturalOrder ( ) . putAll ( toPut ) . putAll ( moreToPut ) . build ( ) ; assertMapEquals ( map , "five" , 5 , "four" , 4 , "one" , 1 , "three" , 3 , "two" , 2 ) ; }
public void testNullPointerExceptions ( ) { new NullPointerTester ( ) . testAllPublicStaticMethods ( Interners . class ) ; }
protected Iterator < String > newTargetIterator ( ) { * return actualElements . iterator ( ) ; * }
private < N1 extends N > GraphBuilder < N1 > cast ( ) { return ( GraphBuilder < N1 > ) this ; }
public Hasher putBytes ( byte[] bytes , int off , int len ) { checkPositionIndexes ( off , off + len , bytes . length ) ; int i ; for ( i = 0 ; i + 4 < = len ; i + = 4 ) { update ( 4 , getIntLittleEndian ( bytes , off + i ) ) ; }
public Stats xStats ( ) { return xStats ; }
public Integer call ( ) { holder . count + + ; return Thread . currentThread ( ) . getStackTrace ( ) . length ; }
public static < K , V > SetMultimap < K , V > unmodifiableSetMultimap ( ImmutableSetMultimap < K , V > delegate ) { return checkNotNull ( delegate ) ; }
public V setValue ( @ParametricNullness V value ) { updateIndex ( ) ; if ( index = = ABSENT ) { HashBiMap . this . put ( key , value ) ; return unsafeNull ( ) ; / / See the discussion in getValue ( ) . }
public void testForSupplierSerializable ( ) { checkCanReserialize ( Functions . forSupplier ( new CountingSupplier ( ) ) ) ; }
public @Nullable E pollLast ( ) { return delegate ( ) . pollLast ( ) ; }
public void testSetValueWithNullValuesPresent ( ) { for ( Entry < K , V > entry : getMap ( ) . entrySet ( ) ) { if ( entry . getKey ( ) . equals ( k0 ( ) ) ) { assertEquals ( "entry . setValue ( ) should return the old value" , v0 ( ) , entry . setValue ( null ) ) ; break ; }
public void testCycleUsingIteratorTester ( ) { new IteratorTester < Integer > ( 5 , UNMODIFIABLE , asList ( 1 , 2 , 1 , 2 , 1 , 2 , 1 , 2 , 1 , 2 , 1 , 2 ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { @Override protected Iterator < Integer > newTargetIterator ( ) { return Iterators . cycle ( asList ( 1 , 2 ) ) ; }
protected void standardPutAll ( Map < ? extends K , ? extends V > map ) { Maps . putAllImpl ( this , map ) ; }
public WeakValueReference < K , V , StrongKeyWeakValueEntry < K , V > > getWeakValueReferenceForTesting ( InternalEntry < K , V , ? > e ) { return castForTesting ( e ) . getValueReference ( ) ; }
public Iterator < E > iterator ( ) { return asList ( ) . iterator ( ) ; }
public void testPartition_badSize ( ) { List < Integer > source = singletonList ( 1 ) ; assertThrows ( IllegalArgumentException . class , ( ) - > partition ( source , 0 ) ) ; }
public @Nullable V forcePut ( @ParametricNullness K key , @ParametricNullness V value ) { checkArgument ( apply ( key , value ) ) ; return unfiltered ( ) . forcePut ( key , value ) ; }
public boolean equals ( @Nullable Object object ) { return equalsImpl ( this , object ) ; }
public void testRoundTrip ( ) { for ( ExpectedHashCode expected : expectedHashCodes ) { String string = HashCode . fromBytes ( expected . bytes ) . toString ( ) ; assertEquals ( expected . toString , string ) ; assertEquals ( expected . toString , HashCode . fromBytes ( BaseEncoding . base16 ( ) . lowerCase ( ) . decode ( string ) ) . toString ( ) ) ; }
public < T extends B > @Nullable T putInstance ( TypeToken < @NonNull T > type , @ParametricNullness T value ) { return this . < T > trustedPut ( type . rejectTypeVariables ( ) , value ) ; }
public void testSlice_illegalArguments ( ) { assertThrows ( "expected IllegalArgumentException for call to slice with offset - 1: " + source , IllegalArgumentException . class , ( ) - > source . slice ( - 1 , 0 ) ) ; assertThrows ( "expected IllegalArgumentException for call to slice with length - 1: " + source , IllegalArgumentException . class , ( ) - > source . slice ( 0 , - 1 ) ) ; }
public static boolean awaitUninterruptibly ( CountDownLatch latch , long timeout , TimeUnit unit ) { boolean interrupted = false ; try { long remainingNanos = unit . toNanos ( timeout ) ; long end = System . nanoTime ( ) + remainingNanos ; while ( true ) { try { / / CountDownLatch treats negative timeouts just like zero . return latch . await ( remainingNanos , NANOSECONDS ) ; }
public List < E > subList ( int fromIndex , int toIndex ) { synchronized ( mutex ) { return list ( delegate ( ) . subList ( fromIndex , toIndex ) , mutex ) ; }
public Stats xStats ( ) { return xStats . snapshot ( ) ; }
public void stableIncidentEdgeOrder_predecessors_returnsInConnectingEdgeInsertionOrder ( ) { assume ( ) . that ( graph . incidentEdgeOrder ( ) . type ( ) ) . isEqualTo ( ElementOrder . Type . STABLE ) ; populateTShapedGraph ( ) ; assertThat ( graph . adjacentNodes ( 1 ) ) . containsExactly ( 2 , 4 , 3 ) . inOrder ( ) ; }
public int size ( ) { return entryList . size ( ) ; }
public void testGetParameters ( ) { assertEquals ( ImmutableListMultimap . of ( ) , MediaType . parse ( "text / plain" ) . parameters ( ) ) ; assertEquals ( ImmutableListMultimap . of ( "charset" , "utf - 8" ) , MediaType . parse ( "application / atom + xml ; charset = utf - 8" ) . parameters ( ) ) ; assertEquals ( PARAMETERS , MediaType . parse ( "application / atom + xml ; a = 1 ; a = 2 ; b = 3" ) . parameters ( ) ) ; }
public String toString ( ) { return ByteSource . this . toString ( ) + " . slice ( " + offset + " , " + length + " ) " ; }
public void testCount ( ) { assertThat ( EMPTY_PAIRED_STATS . count ( ) ) . isEqualTo ( 0 ) ; assertThat ( ONE_VALUE_PAIRED_STATS . count ( ) ) . isEqualTo ( 1 ) ; assertThat ( TWO_VALUES_PAIRED_STATS . count ( ) ) . isEqualTo ( 2 ) ; assertThat ( MANY_VALUES_PAIRED_STATS . count ( ) ) . isEqualTo ( MANY_VALUES_COUNT ) ; }
private TestCondition ( Lock lock , Condition condition ) { this . lock = lock ; this . condition = condition ; }
private static @Nullable String stringOrNull ( char @Nullable [] in ) { return ( in = = null ) ? null : new String ( in ) ; }
public < T > Iterable < ? extends T > supertypeWithWildcardULowerBound_notMatch ( List < String > list ) { return notSubtype ( list ) ; }
public @Nullable V putIfAbsent ( K key , V value ) { throw new UnsupportedOperationException ( ) ; }
protected List < String > create ( String[] elements ) { List < String > list = asList ( elements ) ; Collections . reverse ( list ) ; return ImmutableList . copyOf ( list ) . reverse ( ) ; }
public boolean equals ( @Nullable Object object ) { if ( object instanceof ValueDifference ) { ValueDifference < ? > that = ( ValueDifference < ? > ) object ; return Objects . equals ( this . left , that . leftValue ( ) ) & & Objects . equals ( this . right , that . rightValue ( ) ) ; }
public Hasher putChar ( char c ) { ByteBuffer scratch = scratch ( ) ; scratch . putChar ( c ) ; return update ( scratch , Chars . BYTES ) ; }
public void testMean_doubleIterable ( ) { assertThat ( DoubleMath . mean ( ImmutableList . of ( 1 . 1 , - 2 . 2 , 4 . 4 , - 8 . 8 ) ) ) . isWithin ( 1 . 0e - 10 ) . of ( - 1 . 375 ) ; assertThat ( DoubleMath . mean ( ImmutableList . of ( 1 . 1 ) ) ) . isWithin ( 1 . 0e - 10 ) . of ( 1 . 1 ) ; assertThrows ( IllegalArgumentException . class , ( ) - > DoubleMath . mean ( ImmutableList . < Double > of ( ) ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > DoubleMath . mean ( ImmutableList . of ( Double . NaN ) ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > DoubleMath . mean ( ImmutableList . of ( Double . POSITIVE_INFINITY ) ) ) ; }
public E element ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . element ( ) ; }
public V last ( ) { refreshIfEmpty ( ) ; return getSortedSetDelegate ( ) . last ( ) ; }
protected BiMap < String , String > create ( Entry < String , String > [] entries ) { BiMap < String , String > result = HashBiMap . create ( ) ; for ( Entry < String , String > entry : entries ) { checkArgument ( ! result . containsKey ( entry . getKey ( ) ) ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; }
public void testTruncateIllegalArguments ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Ascii . truncate ( "foobar" , 2 , " . . . " ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > Ascii . truncate ( "foobar" , 8 , "1234567890" ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > Ascii . truncate ( "foobar" , - 1 , " . . . " ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > Ascii . truncate ( "foobar" , - 1 , "" ) ) ; }
public void testRotateIndexed ( ) { testRotate ( new float[] { }
public void testAddAllPrimitiveIntStream ( ) { StatsAccumulator accumulator = new StatsAccumulator ( ) ; accumulator . addAll ( megaPrimitiveDoubleStreamPart1 ( ) . mapToInt ( x - > ( int ) x ) ) ; accumulator . addAll ( megaPrimitiveDoubleStreamPart2 ( ) . mapToInt ( x - > ( int ) x ) ) ; assertThat ( accumulator . count ( ) ) . isEqualTo ( MEGA_STREAM_COUNT ) ; assertThat ( accumulator . mean ( ) ) . isWithin ( ALLOWED_ERROR * MEGA_STREAM_COUNT ) . of ( MEGA_STREAM_MEAN ) ; assertThat ( accumulator . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR * MEGA_STREAM_COUNT ) . of ( MEGA_STREAM_POPULATION_VARIANCE ) ; assertThat ( accumulator . min ( ) ) . isEqualTo ( MEGA_STREAM_MIN ) ; assertThat ( accumulator . max ( ) ) . isEqualTo ( MEGA_STREAM_MAX ) ; }
public E next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; }
public static < K extends @Nullable Object , V extends @Nullable Object > HashBiMap < K , V > create ( Map < ? extends K , ? extends V > map ) { HashBiMap < K , V > bimap = create ( map . size ( ) ) ; bimap . putAll ( map ) ; return bimap ; }
